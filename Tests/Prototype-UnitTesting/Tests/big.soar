# This file was generated by concatenating all agents from the old Demos
# directory, to serve as a torture test for the parser.
sp {hello-world
   (state <s> ^type state)
-->
   (write |Hello World|)
   (halt)
}
sp {elaborate*top-state*top-state
   (state <s> ^superstate nil)
-->
   (<s> ^top-state <s>)
}
sp {elaborate*state*name
   (state <s> ^superstate <ss>)
   (<ss> ^operator <op>)
   (<op> ^name <name>)
-->
   (<s> ^name <name>)
}
sp {elaborate*state*top-state
   (state <s> ^superstate <ss>)
   (<ss> ^top-state <ts>)
-->
   (<s> ^top-state <ts>)
}
sp {kb*propose*test-notify
   (state <s> ^name kb
              ^phase test
              ^sub-phase notify
              ^result <result>
              ^step <step>
              ^max-tests <max>
              ^current-test {<c> <= <max>}
              ^tests <ts>)
   (<ts> ^test <t>)
   (<t> ^id <c>
        ^steps {>= <step>})
-->
   (<s> ^operator <op> + =)
   (<op> ^name test-notify
         ^test <c>
         ^step <step>
         ^result <result>)
}
sp {apply*test-notify*success
   (state <s> ^operator <op>
              ^tests <ts>)
   (<ts> ^test <t>)
   (<op> ^name test-notify
         ^test <c>
         ^step <step>
         ^result success)
   (<t> ^id <c>
        ^step <st>)
   (<st> ^id <step>)
-->
   (<s> ^step <step> -
        ^step (+ <step> 1)
        ^result success -
        ^sub-phase notify -
        ^sub-phase cue)
   (write | | <step> |: complete.| (crlf) | |)
}
sp {apply*test-notify*clean*query
   (state <s> ^operator <op>
              ^epmem <epmem>)
   (<op> ^name test-notify
         ^result success)
   (<epmem> ^command <cmd>)
   (<cmd> ^query <q>)
-->
   (<cmd> ^query <q> -)
}
sp {apply*test-notify*clean*neg-query
   (state <s> ^operator <op>
              ^epmem <epmem>)
   (<op> ^name test-notify
         ^result success)
   (<epmem> ^command <cmd>)
   (<cmd> ^neg-query <q>)
-->
   (<cmd> ^neg-query <q> -)
}
sp {apply*test-notify*clean*retrieve
   (state <s> ^operator <op>
              ^epmem <epmem>)
   (<op> ^name test-notify
         ^result success)
   (<epmem> ^command <cmd>)
   (<cmd> ^retrieve <q>)
-->
   (<cmd> ^retrieve <q> -)
}
sp {apply*test-notify*clean*next
   (state <s> ^operator <op>
              ^epmem <epmem>)
   (<op> ^name test-notify
         ^result success)
   (<epmem> ^command <cmd>)
   (<cmd> ^next <q>)
-->
   (<cmd> ^next <q> -)
}
sp {apply*test-notify*clean*previous
   (state <s> ^operator <op>
              ^epmem <epmem>)
   (<op> ^name test-notify
         ^result success)
   (<epmem> ^command <cmd>)
   (<cmd> ^previous <q>)
-->
   (<cmd> ^previous <q> -)
}
sp {apply*test-notify*clean*before
   (state <s> ^operator <op>
              ^epmem <epmem>)
   (<op> ^name test-notify
         ^result success)
   (<epmem> ^command <cmd>)
   (<cmd> ^before <q>)
-->
   (<cmd> ^before <q> -)
}
sp {apply*test-notify*clean*after
   (state <s> ^operator <op>
              ^epmem <epmem>)
   (<op> ^name test-notify
         ^result success)
   (<epmem> ^command <cmd>)
   (<cmd> ^after <q>)
-->
   (<cmd> ^after <q> -)
}
sp {apply*test-notify*clean*prohibit
   (state <s> ^operator <op>
              ^epmem <epmem>)
   (<op> ^name test-notify
         ^result success)
   (<epmem> ^command <cmd>)
   (<cmd> ^prohibit <q>)
-->
   (<cmd> ^prohibit <q> -)
}
sp {apply*test-notify*failure
   (state <s> ^operator <op>
              ^tests <ts>)
   (<op> ^name test-notify
         ^test <c>
         ^step <step>
         ^result failure)
   (<ts> ^test <t>)
   (<t> ^id <c>
        ^step <st>)
   (<st> ^id <step>)
-->
   (write | | <step> |: failed.| (crlf) | |)
   (halt)
}
sp {kb*propose*done
   (state <s> ^name kb
              ^phase test
              ^sub-phase init
              ^max-tests <max>
              ^current-test {<c> > <max>})
-->
   (<s> ^operator <op> + =)
   (<op> ^name done
         ^test <c>)
}
sp {apply*done
   (state <s> ^operator <op>)
   (<op> ^name done)
-->
   (write (crlf) |All tests complete!| (crlf))
   (halt)
}
sp {kb*propose*test-init
   (state <s> ^name kb
              ^phase test
              ^sub-phase init
              ^max-tests <max>
              ^current-test {<c> <= <max>})
-->
   (<s> ^operator <op> + =)
   (<op> ^name test-init
         ^test <c>)
}
sp {apply*test-init
   (state <s> ^operator <op>
              ^tests <ts>)
   (<ts> ^test <t>)
   (<op> ^name test-init
         ^test <c>)
   (<t> ^id <c>
        ^name <t-name>
        ^note <t-note>)
-->
   (<s> ^sub-phase init -
        ^sub-phase cue
        ^step 1)
   (write (crlf) |Test (| <c> |) "| <t-name> |" - begin|)
   (write (crlf) <t-note> (crlf) | |)
}
sp {kb*propose*test-cue
   (state <s> ^name kb
              ^phase test
              ^sub-phase cue
              ^step <step>
              ^max-tests <max>
              ^current-test {<c> <= <max>}
              ^tests <ts>)
   (<ts> ^test <t>)
   (<t> ^id <c>
        ^steps {>= <step>})
-->
   (<s> ^operator <op> + =)
   (<op> ^name test-cue
         ^test <c>
         ^step <step>)
}
sp {apply*test-cue*prepare
   (state <s> ^operator <op>
              ^tests <ts>
              ^epmem <epmem>)
   (<ts> ^test <t>)
   (<epmem> ^command <e-cmd>)
   (<op> ^name test-cue
         ^test <c>
         ^step <step>)
   (<t> ^id <c>
        ^step <st>)
   (<st> ^id <step>
         ^command <st-cmd>)
   (<st-cmd> ^<t-cmd-name> <t-cmd-val>)
-->
   (<e-cmd> ^<t-cmd-name> <t-cmd-val>)
   (write (crlf) | | <step>|: cue | <t-cmd-name> )
}
sp {apply*test-cue*next
   (state <s> ^operator <op>)
   (<op> ^name test-cue)
-->
   (<s> ^sub-phase cue -
        ^sub-phase result)
}
sp {kb*propose*transition
   (state <s> ^name kb
              ^phase load
              ^max-entries <max>
              ^current-entry {> <max>})
-->
   (<s> ^operator <op> + =)
   (<op> ^name transition)
}
sp {apply*transition*clean
   (state <s> ^operator <op>
              ^observing <e>)
   (<op> ^name transition)
-->
   (<s> ^observing <e> -)
}
sp {apply*transition
   (state <s> ^operator <op>)
   (<op> ^name transition)
-->
   (<s> ^phase load -
        ^phase test)
   (cmd epmem --set trigger none)
   (write | | (crlf) |loading done, proceeding to tests| (crlf) | |)
}
sp {propose*initialize-kb
   (state <s> ^superstate nil
             -^name)
-->
   (<s> ^operator <o> +)
   (<o> ^name initialize-kb)
}
sp {apply*initialize-kb*params
   (state <s> ^operator <op>)
   (<op> ^name initialize-kb)
-->
   (<s> ^phase load
        ^sub-phase init
        ^current-entry 1
        ^current-test 1
        ^max-entries 5        
        ^max-tests 14
        ^entries <e>
        ^tests <t>)
}
sp {apply*intialize-kb*fill
   (state <s> ^operator <op>
              ^max-entries <max-entries>
              ^max-tests <max-tests>
              ^entries <e>
              ^tests <t>)
   (<op> ^name initialize-kb)
-->
   (<s> ^name kb)
   (<e> ^entry <e1>
        ^entry <e2>
        ^entry <e3>
        ^entry <e4>
        ^entry <e5>)
   (<t> ^test <t1>
        ^test <t2>
        ^test <t3>
        ^test <t4>
        ^test <t5>
        ^test <t6>
        ^test <t7>
        ^test <t8>
        ^test <t9>
        ^test <t10>
        ^test <t11>
        ^test <t13>
        ^test <t14>
        ^test <t15>)
   (<e1> ^id 1
         ^name |Sei whale|
         ^scientific-name |Balaenoptera borealis|
         ^attributes <a1>)
   (<a1> ^kind-of rorqual
         ^order Cetacea
         ^is warm-blooded
         ^may-catch rabies)
   (<e2> ^id 2
         ^name |humpback whale|
         ^scientific-name |Megaptera novaeangliae|
         ^attributes <a1>)
   (<e3> ^id 3
         ^name |killer whale|
         ^scientific-name |Orcinus orca|
         ^attributes <a3>)
   (<a3> ^kind-of |dolphin or porpoise|
         ^order Cetacea
         ^is warm-blooded
         ^may-catch rabies)
   (<e4> ^id 4
         ^name |blue dolphin|
         ^scientific-name |Stenella caeruleoalba|
         ^attributes <a3>)
   (<e5> ^id 5
         ^name |True's beaked whale|
         ^scientific-name |Mesoplodon mirus|
         ^attributes <a5>)
   (<a5> ^kind-of |beaked whale|
         ^order Cetacea
         ^is warm-blooded
         ^may-catch rabies)
   ###
   (<t1> ^id 1
         ^name |bad retrieval|
         ^note |attempting to retrieve known bad memory ids|         
         ^steps 2
         ^step <st1-1>
         ^step <st1-2>)
   (<st1-1> ^id 1            
            ^type retrieve
            ^status none
            ^command <c1-1>)
   (<c1-1> ^retrieve 100)
   (<st1-2> ^id 2            
            ^type retrieve
            ^status none
            ^command <c1-2>)
   (<c1-2> ^retrieve 99999)
   ###
   (<t2> ^id 2
         ^name |good retrieval|
         ^note |attempting to retrieve a known good memory id|
         ^steps 1
         ^step <st2-1>)
   (<st2-1> ^id 1            
            ^type retrieve
            ^status good
            ^command <c2-1>
            ^expected 1)
   (<c2-1> ^retrieve 1)
   ###
   (<t3> ^id 3         
         ^name |bad query|
         ^note |attempting to query for a known bad state name|
         ^steps 1
         ^step <st3-1>)
   (<st3-1> ^id 1
            ^type query
            ^status failure
            ^command <c3-1>)
   (<c3-1> ^query <q3-1>)
   (<q3-1> ^name bad-state-name)
   ###
   (<t4> ^id 4
         ^name |soar query|
         ^note |state name; superstate; good state, bad state; state, superstate; io|
         ^steps 5
         ^step <st4-1>
         ^step <st4-2>
         ^step <st4-3>
         ^step <st4-4>
         ^step <st4-5>)
   (<st4-1> ^id 1
            ^type query
            ^status success
            ^command <c4-1>
            ^expected <max-entries>
            ^score 1.)
   (<c4-1> ^query <q4-1>)
   (<q4-1> ^name kb)
   (<st4-2> ^id 2
            ^type query
            ^status success
            ^command <c4-2>
            ^expected <max-entries>
            ^score 1.)
   (<c4-2> ^query <q4-2>)
   (<q4-2> ^superstate nil)   
   (<st4-3> ^id 3
            ^type query
            ^status success
            ^command <c4-3>
            ^expected <max-entries>
            ^score 1.)
   (<c4-3> ^query <q4-3>)
   (<q4-3> ^name kb
           ^name bad-state-name)
   (<st4-4> ^id 4
            ^type query
            ^status success
            ^command <c4-4>
            ^expected <max-entries>
            ^score 2.)
   (<c4-4> ^query <q4-4>)
   (<q4-4> ^name kb
           ^superstate nil)
   (<st4-5> ^id 5
            ^type query
            ^status success
            ^command <c4-5>
            ^expected <max-entries>
            ^score 1.)
   (<c4-5> ^query <q4-5>)
   (<q4-5> ^io <io4-5>)
   ###
   (<t5> ^id 5
         ^name |observing query|
         ^note |query by "observing": 0, 1, last, last+1|
         ^steps 4
         ^step <st5-1>
         ^step <st5-2>
         ^step <st5-3>
         ^step <st5-4>)
   (<st5-1> ^id 1
            ^type query
            ^status failure
            ^command <c5-1>)
   (<c5-1> ^query <q5-1>)
   (<q5-1> ^observing 0)
   (<st5-2> ^id 2
            ^type query
            ^status success
            ^command <c5-2>
            ^expected 1
            ^score 1.)
   (<c5-2> ^query <q5-2>)
   (<q5-2> ^observing 1)
   (<st5-3> ^id 3
            ^type query
            ^status success
            ^command <c5-3>
            ^expected <max-entries>
            ^score 1.)
   (<c5-3> ^query <q5-3>)
   (<q5-3> ^observing <max-entries>)
   (<st5-4> ^id 4
            ^type query
            ^status failure
            ^command <c5-4>)
   (<c5-4> ^query <q5-4>)
   (<q5-4> ^observing (+ <max-entries> 1))
   ###
   (<t6> ^id 6
         ^name |prohibit test|
         ^note |query 1, prohibit the result, failure; query state name, prohibit last, last-1|
         ^steps 4
         ^step <st6-1>
         ^step <st6-2>
         ^step <st6-3>
         ^step <st6-4>)
   (<st6-1> ^id 1
            ^type query
            ^status success
            ^command <c6-1>
            ^expected 1
            ^score 1.)
   (<c6-1> ^query <q6-1>)
   (<q6-1> ^observing 1)
   (<st6-2> ^id 2
            ^type query
            ^status failure
            ^command <c6-2>)
   (<c6-2> ^query <q6-2>
           ^prohibit 1)
   (<q6-2> ^observing 1)
   (<st6-3> ^id 3
            ^type query
            ^status success
            ^command <c6-3>
            ^expected <max-entries>
            ^score 1.)
   (<c6-3> ^query <q6-3>)
   (<q6-3> ^name kb)
   (<st6-4> ^id 4
            ^type query
            ^status success
            ^command <c6-4>
            ^expected (- <max-entries> 1)
            ^score 1.)
   (<c6-4> ^query <q6-4>
           ^prohibit <max-entries>)
   (<q6-4> ^name kb)
   ###
   (<t7> ^id 7
         ^name |next test|
         ^note |query 1, next, 2, next 3; query last, next, failure|
         ^steps 5
         ^step <st7-1>
         ^step <st7-2>
         ^step <st7-3>
         ^step <st7-4>
         ^step <st7-5>)
   (<st7-1> ^id 1
            ^type query
            ^status success
            ^command <c7-1>
            ^expected 1
            ^score 1.)
   (<c7-1> ^query <q7-1>)
   (<q7-1> ^observing 1)
   (<st7-2> ^id 2
            ^type retrieve
            ^status good
            ^command <c7-2>
            ^expected 2)
   (<c7-2> ^next <n7-2>)
   (<st7-3> ^id 3
            ^type retrieve
            ^status good
            ^command <c7-3>
            ^expected 3)
   (<c7-3> ^next <n7-3>)
   (<st7-4> ^id 4
            ^type query
            ^status success
            ^command <c7-4>
            ^expected <max-entries>
            ^score 1.)
   (<c7-4> ^query <q7-4>)
   (<q7-4> ^observing <max-entries>)
   (<st7-5> ^id 5
            ^type retrieve
            ^status none
            ^command <c7-5>)
   (<c7-5> ^next <n7-5>)
   ###
   (<t8> ^id 8
         ^name |previous test|
         ^note |query 1, previous, failure; query last, previous, last-1, previous, last-2|
         ^steps 5
         ^step <st8-1>
         ^step <st8-2>
         ^step <st8-3>
         ^step <st8-4>
         ^step <st8-5>)
   (<st8-1> ^id 1
            ^type query
            ^status success
            ^command <c8-1>
            ^expected 1
            ^score 1.)
   (<c8-1> ^query <q8-1>)
   (<q8-1> ^observing 1)
   (<st8-2> ^id 2
            ^type retrieve
            ^status none
            ^command <c8-2>
            ^expected 2)
   (<c8-2> ^previous <p8-2>)
   (<st8-3> ^id 3
            ^type query
            ^status success
            ^command <c8-3>
            ^expected <max-entries>
            ^score 1.)
   (<c8-3> ^query <q8-3>)
   (<q8-3> ^observing <max-entries>)
   (<st8-4> ^id 4
            ^type retrieve
            ^status good
            ^command <c8-4>
            ^expected (- <max-entries> 1))
   (<c8-4> ^previous <p8-4>)
   (<st8-5> ^id 5
            ^type retrieve
            ^status good
            ^command <c8-5>
            ^expected (- <max-entries> 2))
   (<c8-5> ^previous <p8-5>)
   ###
   (<t9> ^id 9
         ^name |before test|
         ^note |query 1, before 1, failure; query 2, before 2, failure, before 3, 2; query state name, before last, last-1|
         ^steps 7
         ^step <st9-1>
         ^step <st9-2>
         ^step <st9-3>
         ^step <st9-4>
         ^step <st9-5>
         ^step <st9-6>
         ^step <st9-7>)
   (<st9-1> ^id 1
            ^type query
            ^status success
            ^command <c9-1>
            ^expected 1
            ^score 1.)
   (<c9-1> ^query <q9-1>)
   (<q9-1> ^observing 1)
   (<st9-2> ^id 2
            ^type query
            ^status failure
            ^command <c9-2>)
   (<c9-2> ^query <q9-2>
           ^before 1)
   (<q9-2> ^observing 1)
   (<st9-3> ^id 3
            ^type query
            ^status success
            ^command <c9-3>
            ^expected 2
            ^score 1.)
   (<c9-3> ^query <q9-3>)
   (<q9-3> ^observing 2)
   (<st9-4> ^id 4
            ^type query
            ^status failure
            ^command <c9-4>)
   (<c9-4> ^query <q9-4>
           ^before 2)
   (<q9-4> ^observing 2)
   (<st9-5> ^id 5
            ^type query
            ^status success
            ^command <c9-5>
            ^expected 2
            ^score 1.)
   (<c9-5> ^query <q9-5>
           ^before 3)
   (<q9-5> ^observing 2)
   (<st9-6> ^id 6
            ^type query
            ^status success
            ^command <c9-6>
            ^expected <max-entries>
            ^score 1.)
   (<c9-6> ^query <q9-6>)
   (<q9-6> ^name kb)
   (<st9-7> ^id 7
            ^type query
            ^status success
            ^command <c9-7>
            ^expected (- <max-entries> 1)
            ^score 1.)
   (<c9-7> ^query <q9-7>
           ^before <max-entries>)
   (<q9-7> ^name kb)
   ###
   (<t10> ^id 10
          ^name |after test|
          ^note |query last, after last, failure; query last-1, after last-1, failure, after last-2, last-1|
          ^steps 5
          ^step <st10-1>
          ^step <st10-2>
          ^step <st10-3>
          ^step <st10-4>
          ^step <st10-5>)
   (<st10-1> ^id 1
             ^type query
             ^status success
             ^command <c10-1>
             ^expected <max-entries>
             ^score 1.)
   (<c10-1> ^query <q10-1>)
   (<q10-1> ^observing <max-entries>)
   (<st10-2> ^id 2
             ^type query
             ^status failure
             ^command <c10-2>)
   (<c10-2> ^query <q10-2>
            ^after <max-entries>)
   (<q10-2> ^observing <max-entries>)
   (<st10-3> ^id 3
             ^type query
             ^status success
             ^command <c10-3>
             ^expected (- <max-entries> 1)
             ^score 1.)
   (<c10-3> ^query <q10-3>)
   (<q10-3> ^observing (- <max-entries> 1))
   (<st10-4> ^id 4
             ^type query
             ^status failure
             ^command <c10-4>)
   (<c10-4> ^query <q10-4>
            ^after (- <max-entries> 1))
   (<q10-4> ^observing (- <max-entries> 1))
   (<st10-5> ^id 5
             ^type query
             ^status success
             ^command <c10-5>
             ^expected (- <max-entries> 1)
             ^score 1.)
   (<c10-5> ^query <q10-5>
            ^after (- <max-entries> 2))
   (<q10-5> ^observing (- <max-entries> 1))
   ###
   (<t11> ^id 11
          ^name |before/after test|
          ^note |query 3, before last, after 1, before last + after 1, before 4 + after 2, before 3 + after 2 (fail), before 4 + after 3 (fail)|
          ^steps 7
          ^step <st11-1>
          ^step <st11-2>
          ^step <st11-3>
          ^step <st11-4>
          ^step <st11-5>
          ^step <st11-6>
          ^step <st11-7>)
   (<st11-1> ^id 1
             ^type query
             ^status success
             ^command <c11-1>
             ^expected 3
             ^score 1.)
   (<c11-1> ^query <q11-1>)
   (<q11-1> ^observing 3)
   (<st11-2> ^id 2
             ^type query
             ^status success
             ^command <c11-2>
             ^expected 3
             ^score 1.)
   (<c11-2> ^query <q11-2>
            ^before <max-entries>)
   (<q11-2> ^observing 3)
   (<st11-3> ^id 3
             ^type query
             ^status success
             ^command <c11-3>
             ^expected 3
             ^score 1.)
   (<c11-3> ^query <q11-3>
            ^after 1)
   (<q11-3> ^observing 3)
   (<st11-4> ^id 4
             ^type query
             ^status success
             ^command <c11-4>
             ^expected 3
             ^score 1.)
   (<c11-4> ^query <q11-4>
            ^before <max-entries>
            ^after 1)
   (<q11-4> ^observing 3)
   (<st11-5> ^id 5
             ^type query
             ^status success
             ^command <c11-5>
             ^expected 3
             ^score 1.)
   (<c11-5> ^query <q11-5>
            ^before 4
            ^after 2)
   (<q11-5> ^observing 3)
   (<st11-6> ^id 6
             ^type query
             ^status failure
             ^command <c11-6>)
   (<c11-6> ^query <q11-6>
            ^before 3
            ^after 2)
   (<q11-6> ^observing 3)
   (<st11-7> ^id 7
             ^type query
             ^status failure
             ^command <c11-7>)
   (<c11-7> ^query <q11-7>
            ^before 4
            ^after 3)
   (<q11-7> ^observing 3)
   ###
   ###
   (<t13> ^id 12
          ^name |pos+neg tests|
          ^note |+good state -bad state, last; +bad stat -good state, last; +good state -last, last-1; +last -good state, last; +last -last, last; +1 last -last, 1|
          ^steps 6
          ^step <st13-1>
          ^step <st13-2>
          ^step <st13-3>
          ^step <st13-4>
          ^step <st13-5>
          ^step <st13-6>)
   (<st13-1> ^id 1
             ^type query
             ^status success
             ^command <c13-1>
             ^expected <max-entries>
             ^score 1.)
   (<c13-1> ^query <q13-1>
            ^neg-query <nq13-1>)
   (<q13-1> ^name kb)
   (<nq13-1> ^name bad-state-name)
   (<st13-2> ^id 2
             ^type query
             ^status success
             ^command <c13-2>
             ^expected <max-entries>
             ^score -1.)
   (<c13-2> ^query <q13-2>
            ^neg-query <nq13-2>)
   (<q13-2> ^name bad-state-name)
   (<nq13-2> ^name kb)
   (<st13-3> ^id 3
             ^type query
             ^status success
             ^command <c13-3>
             ^expected (- <max-entries> 1)
             ^score 1.)
   (<c13-3> ^query <q13-3>
            ^neg-query <nq13-3>)
   (<q13-3> ^name kb)
   (<nq13-3> ^observing <max-entries>)
   (<st13-4> ^id 4
             ^type query
             ^status success
             ^command <c13-4>
             ^expected <max-entries>
             ^score 0.)
   (<c13-4> ^query <q13-4>
            ^neg-query <nq13-4>)
   (<q13-4> ^observing <max-entries>)
   (<nq13-4> ^name kb)
   (<st13-5> ^id 5
             ^type query
             ^status success
             ^command <c13-5>
             ^expected <max-entries>
             ^score 0.)
   (<c13-5> ^query <q13-5>
            ^neg-query <nq13-5>)
   (<q13-5> ^observing <max-entries>)
   (<nq13-5> ^observing <max-entries>)
   (<st13-6> ^id 6
             ^type query
             ^status success
             ^command <c13-6>
             ^expected 1
             ^score 1.)
   (<c13-6> ^query <q13-6>
            ^neg-query <nq13-6>)
   (<q13-6> ^observing <max-entries>
            ^observing 1)
   (<nq13-6> ^observing <max-entries>)
   ###
   (<t14> ^id 13
          ^name |all together now!|
          ^note |+state, last; +state -last, last-1; +state -last before last after 1, last-1; +state -last before last-1 after 1, last-2; +state -last before last-1 prohibit last-2, last-3; +state +1, 1; +state +1 +2 +3 +4, 4; +state +1 +2 +3 +4 -4, 3; +state +1 +2 +3 +4 -4 before 3, 2; +state +1 +2 +3 +4 -4 before 3 prohibit 2, 1; +state +1 +2 +3 +4 -4 after 3 prohibit 2, last; +state +1 +2 +3 +4 -4 after 3 before last prohibit 2, last-1; next, last; previous, last-1|            
          ^steps 14
          ^step <st14-1>
          ^step <st14-2>
          ^step <st14-3>
          ^step <st14-4>
          ^step <st14-5>
          ^step <st14-6>
          ^step <st14-7>
          ^step <st14-8>
          ^step <st14-9>
          ^step <st14-10>
          ^step <st14-11>
          ^step <st14-12>
          ^step <st14-13>
          ^step <st14-14>)
   (<st14-1> ^id 1
             ^type query
             ^status success
             ^command <c14-1>
             ^expected <max-entries>
             ^score 1.)
   (<c14-1> ^query <q14-1>
            ^neg-query <n14-1>)
   (<q14-1> ^name kb)
   (<st14-2> ^id 2
             ^type query
             ^status success
             ^command <c14-2>
             ^expected (- <max-entries> 1)
             ^score 1.)
   (<c14-2> ^query <q14-2>
            ^neg-query <n14-2>)
   (<q14-2> ^name kb)
   (<n14-2> ^observing <max-entries>)
   (<st14-3> ^id 3
             ^type query
             ^status success
             ^command <c14-3>
             ^expected (- <max-entries> 1)
             ^score 1.)
   (<c14-3> ^query <q14-3>
            ^neg-query <n14-3>
            ^before <max-entries>
            ^after 1)
   (<q14-3> ^name kb)
   (<n14-3> ^observing <max-entries>)
   (<st14-4> ^id 4
             ^type query
             ^status success
             ^command <c14-4>
             ^expected (- <max-entries> 2)
             ^score 1.)
   (<c14-4> ^query <q14-4>
            ^neg-query <n14-4>
            ^before (- <max-entries> 1)
            ^after 1)
   (<q14-4> ^name kb)
   (<n14-4> ^observing <max-entries>)
   (<st14-5> ^id 5
             ^type query
             ^status success
             ^command <c14-5>
             ^expected (- <max-entries> 3)
             ^score 1.)
   (<c14-5> ^query <q14-5>
            ^neg-query <n14-5>
            ^before (- <max-entries> 1)
            ^after 1
            ^prohibit (- <max-entries> 2))
   (<q14-5> ^name kb)
   (<n14-5> ^observing <max-entries>)
   (<st14-6> ^id 6
             ^type query
             ^status success
             ^command <c14-6>
             ^expected 1
             ^score 2.)
   (<c14-6> ^query <q14-6>
            ^neg-query <n14-6>)
   (<q14-6> ^name kb
            ^observing 1)
   (<st14-7> ^id 7
             ^type query
             ^status success
             ^command <c14-7>
             ^expected 4
             ^score 2.)
   (<c14-7> ^query <q14-7>
            ^neg-query <n14-7>)
   (<q14-7> ^name kb
            ^observing 1
            ^observing 2
            ^observing 3
            ^observing 4)
   (<st14-8> ^id 8
             ^type query
             ^status success
             ^command <c14-8>
             ^expected 3
             ^score 2.)
   (<c14-8> ^query <q14-8>
            ^neg-query <n14-8>)
   (<q14-8> ^name kb
            ^observing 1
            ^observing 2
            ^observing 3
            ^observing 4)
   (<n14-8> ^observing 4)
   (<st14-9> ^id 9
             ^type query
             ^status success
             ^command <c14-9>
             ^expected 2
             ^score 2.)
   (<c14-9> ^query <q14-9>
            ^neg-query <n14-9>
            ^before 3)
   (<q14-9> ^name kb
            ^observing 1
            ^observing 2
            ^observing 3
            ^observing 4)
   (<n14-9> ^observing 4)
   (<st14-10> ^id 10
              ^type query
              ^status success
              ^command <c14-10>
              ^expected 1
              ^score 2.)
   (<c14-10> ^query <q14-10>
             ^neg-query <n14-10>
             ^before 3
             ^prohibit 2)
   (<q14-10> ^name kb
             ^observing 1
             ^observing 2
             ^observing 3
             ^observing 4)
   (<n14-10> ^observing 4)
   (<st14-11> ^id 11
              ^type query
              ^status success
              ^command <c14-11>
              ^expected <max-entries>
              ^score 1.)
   (<c14-11> ^query <q14-11>
             ^neg-query <n14-11>
             ^after 3
             ^prohibit 2)
   (<q14-11> ^name kb
             ^observing 1
             ^observing 2
             ^observing 3
             ^observing 4)
   (<n14-11> ^observing 4)
   (<st14-12> ^id 12
              ^type query
              ^status success
              ^command <c14-12>
              ^expected (- <max-entries> 1)
              ^score 1.)
   (<c14-12> ^query <q14-12>
             ^neg-query <n14-12>
             ^after 3
             ^before <max-entries>
             ^prohibit 2)
   (<q14-12> ^name kb
             ^observing 1
             ^observing 2
             ^observing 3
             ^observing 4)
   (<n14-12> ^observing 4)
   (<st14-13> ^id 13
              ^type retrieve
              ^status good
              ^command <c14-13>
              ^expected <max-entries>)
   (<c14-13> ^next <n14-13>)
   (<st14-14> ^id 14
              ^type retrieve
              ^status good
              ^command <c14-14>
              ^expected (- <max-entries> 1))
   (<c14-14> ^previous <p14-14>)
   ###
  (<t15> ^id 14
          ^name |mode 3 checks|
          ^note |warm-blooded, score 1; warm-blooded and Cetacea, score 2; warm-blooded, rabies, not Cetacea, score 1; warm-blooded, rabies, not beaked whale, score 2|
          ^steps 4
          ^step <st15-1>
          ^step <st15-2>
          ^step <st15-3>
          ^step <st15-4>)
   (<st15-1> ^id 1
             ^type query
             ^status success
             ^command <c15-1>
             ^expected <max-entries>
             ^score 1.)
   (<c15-1> ^query <q15-1>)
   (<q15-1> ^observing-entry <oe15-1>)
   (<oe15-1> ^attributes <a15-1>)
   (<a15-1> ^is warm-blooded)
   (<st15-2> ^id 2
             ^type query
             ^status success
             ^command <c15-2>
             ^expected <max-entries>
             ^score 2.)
   (<c15-2> ^query <q15-2>)
   (<q15-2> ^observing-entry <oe15-2>)
   (<oe15-2> ^attributes <a15-2>)
   (<a15-2> ^is warm-blooded 
            ^order Cetacea)
   (<st15-3> ^id 3
             ^type query
             ^status success
             ^command <c15-3>
             ^expected <max-entries>
             ^score 1.)
   (<c15-3> ^query <q15-3>
            ^neg-query <n15-3>)
   (<q15-3> ^observing-entry <oe15-3>)
   (<oe15-3> ^attributes <a15-3>)
   (<a15-3> ^is warm-blooded 
            ^may-catch rabies)
   (<n15-3> ^observing-entry <noe15-3>)
   (<noe15-3> ^attributes <na15-3>)
   (<na15-3> ^order Cetacea)
   (<st15-4> ^id 4
             ^type query
             ^status success
             ^command <c15-4>
             ^expected (- <max-entries> 1)
             ^score 2.)
   (<c15-4> ^query <q15-4>
            ^neg-query <n15-4>)
   (<q15-4> ^observing-entry <oe15-4>)
   (<oe15-4> ^attributes <a15-4>)
   (<a15-4> ^is warm-blooded 
            ^may-catch rabies)
   (<n15-4> ^observing-entry <noe15-4>)
   (<noe15-4> ^attributes <na15-4>)
   (<na15-4> ^kind-of |beaked whale|)
}
sp {kb*propose*test-result
   (state <s> ^name kb
              ^phase test
              ^sub-phase result
              ^step <step>
              ^max-tests <max>
              ^current-test {<c> <= <max>}
              ^tests <ts>)
   (<ts> ^test <t>)
   (<t> ^id <c>
        ^steps {>= <step>})
-->
   (<s> ^operator <op> + =)
   (<op> ^name test-result
         ^test <c>
         ^step <step>)
}
sp {apply*test-result*retrieve*none*success
   (state <s> ^operator <op>
              ^tests <ts>
              ^epmem <epmem>)
   (<ts> ^test <t>)
   (<epmem> ^result <e-result>)
   (<op> ^name test-result
         ^test <c>
         ^step <step>)
   (<t> ^id <c>
        ^step <st>)
   (<st> ^id <step>
         ^type retrieve
         ^status none)
   (<e-result> ^retrieved no-memory)
-->
   (<s> ^result success
        ^sub-phase result -
        ^sub-phase notify)
   (write |  expecting - no-memory| (crlf))
   (write |  result - no-memory| (crlf))
}
sp {apply*test-result*retrieve*none*failure
   (state <s> ^operator <op>
              ^tests <ts>
              ^epmem <epmem>)
   (<ts> ^test <t>)
   (<epmem> ^result <e-result>)
   (<op> ^name test-result
         ^test <c>
         ^step <step>)
   (<t> ^id <c>
        ^step <st>)
   (<st> ^id <step>
         ^type retrieve
         ^status none)
  -(<e-result> ^retrieved no-memory)
-->
   (<s> ^result failure
        ^sub-phase result -
        ^sub-phase notify)
   (write |  expecting - no-memory| (crlf))
   (write |  result - memory retrieved| (crlf))
}
sp {apply*test-result*retrieve*good*success
   (state <s> ^operator <op>
              ^tests <ts>
              ^epmem <epmem>
              ^entries <es>)
   (<ts> ^test <t>)
   (<epmem> ^result <e-result>)
   (<es> ^entry <entry>)
   (<op> ^name test-result
         ^test <c>
         ^step <step>)
   (<t> ^id <c>
        ^step <st>)
   (<st> ^id <step>
         ^type retrieve
         ^status good
         ^expected <expected>)
   (<e-result> ^retrieved <retrieved>)
   (<retrieved> ^observing <expected>)
   (<entry> ^id <expected>
            ^name <entry-name>
            ^scientific-name <entry-s-name>)
-->
   (<s> ^result success
        ^sub-phase result -
        ^sub-phase notify)
   (write |  expecting - | <entry-name> | (| <entry-s-name> |)| (crlf))
   (write |  result - | <entry-name> | (| <entry-s-name> |)| (crlf))
}
sp {apply*test-result*retrieve*good*wrong
   (state <s> ^operator <op>
              ^tests <ts>
              ^epmem <epmem>
              ^entries <es>)
   (<ts> ^test <t>)
   (<epmem> ^result <e-result>)
   (<es> ^entry <entry1>
         ^entry <entry2>)
   (<op> ^name test-result
         ^test <c>
         ^step <step>)
   (<t> ^id <c>
        ^step <st>)
   (<st> ^id <step>
         ^type retrieve
         ^status good
         ^expected <expected>)
   (<e-result> ^retrieved <retrieved>)
   (<retrieved> ^observing {<observed> <> <expected>})
   (<entry1> ^id <expected>
             ^name <entry1-name>
             ^scientific-name <entry1-s-name>)
   (<entry2> ^id <observed>
             ^name <entry2-name>
             ^scientific-name <entry2-s-name>)
-->
   (<s> ^result failure
        ^sub-phase result -
        ^sub-phase notify)
   (write |  expecting - | <entry1-name> | (| <entry1-s-name> |)| (crlf))
   (write |  result - | <entry2-name> | (| <entry2-s-name> |)| (crlf))
}
sp {apply*test-result*retrieve*good*none
   (state <s> ^operator <op>
              ^tests <ts>
              ^epmem <epmem>
              ^entries <es>)
   (<ts> ^test <t>)
   (<epmem> ^result <e-result>)
   (<es> ^entry <entry1>)
   (<op> ^name test-result
         ^test <c>
         ^step <step>)
   (<t> ^id <c>
        ^step <st>)
   (<st> ^id <step>
         ^type retrieve
         ^status good
         ^expected <expected>)
   (<e-result> ^retrieved no-memory)
   (<entry1> ^id <expected>
             ^name <entry1-name>
             ^scientific-name <entry1-s-name>)
-->
   (<s> ^result failure
        ^sub-phase result -
        ^sub-phase notify)
   (write |  expecting - | <entry1-name> | (| <entry1-s-name> |)| (crlf))
   (write |  result - no-memory| (crlf))
}
sp {apply*test-result*query*failure*success
   (state <s> ^operator <op>
              ^tests <ts>
              ^epmem <epmem>)
   (<ts> ^test <t>)
   (<epmem> ^result <e-result>)
   (<op> ^name test-result
         ^test <c>
         ^step <step>)
   (<t> ^id <c>
        ^step <st>)
   (<st> ^id <step>
         ^type query
         ^status failure)
   (<e-result> ^failure)
-->
   (<s> ^result success
        ^sub-phase result -
        ^sub-phase notify)
   (write |  expecting - query failure| (crlf))
   (write |  result - query failure| (crlf))
}
sp {apply*test-result*query*failure*failure
   (state <s> ^operator <op>
              ^tests <ts>
              ^epmem <epmem>
              ^entries <es>)
   (<ts> ^test <t>)
   (<epmem> ^result <e-result>)
   (<es> ^entry <entry2>)
   (<op> ^name test-result
         ^test <c>
         ^step <step>)
   (<t> ^id <c>
        ^step <st>)
   (<st> ^id <step>
         ^type query
         ^status failure)
   (<e-result> ^success
               ^retrieved <retrieved>)
   (<retrieved> ^observing <observed>)
   (<entry2> ^id <observed>
             ^name <entry2-name>
             ^scientific-name <entry2-s-name>)
-->
   (<s> ^result failure
        ^sub-phase result -
        ^sub-phase notify)
   (write |  expecting - query failure| (crlf))
   (write |  result - | <entry2-name> | (| <entry2-s-name> |)| (crlf))
}
sp {apply*test-result*query*success*failure
   (state <s> ^operator <op>
              ^tests <ts>
              ^epmem <epmem>
              ^entries <es>)
   (<ts> ^test <t>)
   (<epmem> ^result <e-result>)
   (<es> ^entry <entry1>)
   (<op> ^name test-result
         ^test <c>
         ^step <step>)
   (<t> ^id <c>
        ^step <st>)
   (<st> ^id <step>
         ^type query
         ^status success
         ^expected <expected>)
   (<e-result> ^failure)
   (<entry1> ^id <expected>
             ^name <entry1-name>
             ^scientific-name <entry1-s-name>)
-->
   (<s> ^result failure
        ^sub-phase result -
        ^sub-phase notify)
   (write |  expecting - | <entry1-name> | (| <entry1-s-name> |)| (crlf))
   (write |  result - query failure| (crlf))
}
sp {apply*test-result*query*success*success
   (state <s> ^operator <op>
              ^tests <ts>
              ^epmem <epmem>
              ^entries <es>)
   (<ts> ^test <t>)
   (<epmem> ^result <e-result>)
   (<es> ^entry <entry>)
   (<op> ^name test-result
         ^test <c>
         ^step <step>)
   (<t> ^id <c>
        ^step <st>)
   (<st> ^id <step>
         ^type query
         ^status success
         ^expected <expected>
         ^score <score>)
   (<e-result> ^retrieved <retrieved>
               ^match-score <score>)
   (<retrieved> ^observing <expected>)
   (<entry> ^id <expected>
            ^name <entry-name>
            ^scientific-name <entry-s-name>)
-->
   (<s> ^result success
        ^sub-phase result -
        ^sub-phase notify)
   (write |  expecting (| <score> |) = | <entry-name> | (| <entry-s-name> |)| (crlf))
   (write |  result (| <score> |) = | <entry-name> | (| <entry-s-name> |)| (crlf))
}
sp {apply*test-result*query*success*wrong*retrieval
   (state <s> ^operator <op>
              ^tests <ts>
              ^epmem <epmem>
              ^entries <es>)
   (<ts> ^test <t>)
   (<epmem> ^result <e-result>)
   (<es> ^entry <entry1>
         ^entry <entry2>)
   (<op> ^name test-result
         ^test <c>
         ^step <step>)
   (<t> ^id <c>
        ^step <st>)
   (<st> ^id <step>
         ^type query
         ^status success
         ^expected <expected>
         ^score <exp-score>)
   (<e-result> ^retrieved <retrieved>
               ^match-score <obs-score>)
   (<retrieved> ^observing {<observed> <> <expected>})
   (<entry1> ^id <expected>
            ^name <entry1-name>
            ^scientific-name <entry1-s-name>)
   (<entry2> ^id <observed>
            ^name <entry2-name>
            ^scientific-name <entry2-s-name>)
-->
   (<s> ^result failure
        ^sub-phase result -
        ^sub-phase notify)
   (write |  expecting (| <exp-score> |) = | <entry1-name> | (| <entry1-s-name> |)| (crlf))
   (write |  result (| <obs-score> |) = | <entry2-name> | (| <entry2-s-name> |)| (crlf))
}
sp {apply*test-result*query*success*wrong*score
   (state <s> ^operator <op>
              ^tests <ts>
              ^epmem <epmem>
              ^entries <es>)
   (<ts> ^test <t>)
   (<epmem> ^result <e-result>)
   (<es> ^entry <entry>)
   (<op> ^name test-result
         ^test <c>
         ^step <step>)
   (<t> ^id <c>
        ^step <st>)
   (<st> ^id <step>
         ^type query
         ^status success
         ^expected <expected>
         ^score <exp-score>)
   (<e-result> ^retrieved <retrieved>
               ^match-score {<obs-score> <> <exp-score>})
   (<retrieved> ^observing <expected>)
   (<entry> ^id <expected>
            ^name <entry-name>
            ^scientific-name <entry-s-name>)
-->
   (<s> ^result failure
        ^sub-phase result -
        ^sub-phase notify)
   (write |  expecting (| <exp-score> |) = | <entry-name> | (| <entry-s-name> |)| (crlf))
   (write |  result (| <obs-score> |) = | <entry-name> | (| <entry-s-name> |)| (crlf))
}
sp {kb*propose*test-next
   (state <s> ^name kb
              ^phase test
              ^sub-phase cue
              ^step <step>
              ^max-tests <max>
              ^current-test {<c> <= <max>}
              ^tests <ts>)
   (<ts> ^test <t>)
   (<t> ^id <c>
        ^steps {< <step>})
-->
   (<s> ^operator <op> + =)
   (<op> ^name test-next
         ^test <c>
         ^step <step>)
}
sp {apply*test-next
   (state <s> ^operator <op>
              ^tests <ts>)
   (<ts> ^test <t>)
   (<op> ^name test-next
         ^test <c>
         ^step <step>)
   (<t> ^id <c>
        ^name <t-name>)
-->
   (<s> ^sub-phase cue -
        ^sub-phase init
        ^step <step> -
        ^current-test <c> -
        ^current-test (+ <c> 1))
   (write (crlf) |Test (| <c> |) "| <t-name> |" - complete| (crlf) | |)
}
sp {kb*elaborate*observing
   (state <s> ^name kb
              ^observing <c>
              ^entries <es>)
   (<es> ^entry <e>)
   (<e> ^id <c>)
-->
   (<s> ^observing-entry <e>)
}
sp {kb*propose*load
   (state <s> ^name kb
              ^phase load
              ^max-entries <max>
              ^current-entry {<c> <= <max>})
-->
   (<s> ^operator <op> + =)
   (<op> ^name load
         ^entry <c>)
}
sp {apply*load*observe
   (state <s> ^operator <op>
              ^entries <es>)
   (<es> ^entry <e>)
   (<e> ^id <c>
        ^name <name>
        ^scientific-name <s-name>)
   (<op> ^name load
         ^entry <c>)
-->
   (<s> ^observing <c>)
   (write |Observing (| <c> |): | <name> | (| <s-name> |)| (crlf))
   (cmd epmem --set trigger dc)   
}
sp {apply*load*remove
   (state <s> ^operator <op>
              ^observing {<o> <> <c>})
   (<op> ^name load
         ^entry <c>)
-->
   (<s> ^observing <o> -)
}
sp {apply*load*increment
   (state <s> ^operator <op>)
   (<op> ^name load
         ^entry <c>)
-->
   (<s> ^current-entry <c> -
        ^current-entry (+ <c> 1))
}
watch 0
epmem --set learning on
epmem --set balance 1
epmem --set trigger none
watch --epmem
sp {elaborate*top-state*top-state
   (state <s> ^superstate nil)
-->
   (<s> ^top-state <s>)
}
sp {elaborate*state*name
   (state <s> ^superstate.operator.name <name>)
-->
   (<s> ^name <name>)
}
sp {elaborate*state*top-state
   (state <s> ^superstate.top-state <ts>)
-->
   (<s> ^top-state <ts>)
}
sp {process-column*elaborate*arithmetic-problem
   (state <s> ^name 
              ^superstate.arithmetic-problem <ap>)
-->
   (<s> ^arithmetic-problem <ap>)
}
sp {process-column*elaborate*arithmetic-facts
   (state <s> ^name 
              ^superstate.arithmetic <a>)
-->
   (<s> ^arithmetic <a>)
}
sp {process-column*elaborate*current-column
   (state <s> ^name <> compute-result 
              ^superstate.arithmetic-problem <ap>)
   (<ap> ^current-column <cc>)
-->
   (<s> ^current-column <cc>)
}
sp {arithmetic*elaborate*state*top-number*one-column
   (state <s> ^name arithmetic
              ^superstate nil
              ^arithmetic-problem <ap>)
   (<ap> ^one-column <oc>)
   (<oc> ^digit1 <d1>
         ^next-column nil)
-->
 #  (write (crlf) |Top Number: | <d1>)
   (<ap> ^top-number <d1>)
}
sp {arithmetic*elaborate*state*bottom-number*one-column
   (state <s> ^name arithmetic
              ^superstate nil
              ^arithmetic-problem <ap>)
   (<ap> ^one-column <oc>)
   (<oc> ^digit2 <d1>
         ^next-column nil)
-->
 #  (write (crlf) |Bottom Number: | <d1>)
   (<ap> ^bottom-number <d1>)
}
sp {arithmetic*elaborate*state*result-number*one-column
   (state <s> ^name arithmetic
              ^superstate nil
              ^arithmetic-problem <ap>)
   (<ap> ^one-column <oc>)
   (<oc> ^result <d1>
         ^next-column nil)
-->
  # (write (crlf) |Result Number: | <d1>)
   (<ap> ^result-number <d1>)
}
sp {arithmetic*elaborate*state*top-number*two-column
   (state <s> ^name arithmetic
              ^superstate nil
              ^arithmetic-problem <ap>)
   (<ap> ^one-column <oc>)
   (<oc> ^digit1 <d1>
         ^next-column <tc>)
   (<tc> ^digit1 <d2>
         ^next-column nil)
-->
   (<ap> ^top-number (+ (* 10 <d2>) <d1>))
}
sp {arithmetic*elaborate*state*bottom-number*two-column
   (state <s> ^name arithmetic
              ^superstate nil
              ^arithmetic-problem <ap>)
   (<ap> ^one-column <oc>)
   (<oc> ^digit2 <d1>
         ^next-column <tc>)
   (<tc> ^digit2 <d2>
         ^next-column nil)
-->
  # (write (crlf) |Bottom Number: |  (+ (* 10 <d2>) <d1>))
   (<ap> ^bottom-number (+ (* 10 <d2>) <d1>))
}
sp {arithmetic*elaborate*state*result-number*two-column
   (state <s> ^name arithmetic
              ^superstate nil
              ^arithmetic-problem <ap>)
   (<ap> ^one-column <oc>)
   (<oc> ^result <d1>
         ^next-column <tc>)
   (<tc> ^result <d2>
         ^next-column nil)
-->
 #  (write (crlf) |Result Number: |  (+ (* 10 <d2>) <d1>))
   (<ap> ^result-number (+ (* 10 <d2>) <d1>))
}
sp {arithmetic*elaborate*state*top-number*three-column
   (state <s> ^name arithmetic
              ^superstate nil
              ^arithmetic-problem <ap>)
   (<ap> ^one-column <oc>)
   (<oc> ^digit1 <d1>
         ^next-column <tc>)
   (<tc> ^digit1 <d2>
         ^next-column <hc>)
   (<hc> ^digit1 <d3>
         ^next-column nil)
-->
 #  (write (crlf) |Top Number: |  (+ (* 100 <d3>) (* 10 <d2>) <d1>))
   (<ap> ^top-number (+ (* 100 <d3>) (* 10 <d2>) <d1>))
}
sp {arithmetic*elaborate*state*bottom-number*three-column
   (state <s> ^name arithmetic
              ^superstate nil
              ^arithmetic-problem <ap>)
   (<ap> ^one-column <oc>)
   (<oc> ^digit2 <d1>
         ^next-column <tc>)
   (<tc> ^digit2 <d2>
         ^next-column <hc>)
   (<hc> ^digit2 <d3>
         ^next-column nil)
-->
  # (write (crlf) |Bottom Number: |  (+ (* 100 <d3>) (* 10 <d2>) <d1>))
   (<ap> ^bottom-number (+ (* 100 <d3>) (* 10 <d2>) <d1>))
}
sp {arithmetic*elaborate*state*result-number*three-column
   (state <s> ^name arithmetic
              ^superstate nil
              ^arithmetic-problem <ap>)
   (<ap> ^one-column <oc>)
   (<oc> ^result <d1>
         ^next-column <tc>)
   (<tc> ^result <d2>
         ^next-column <hc>)
   (<hc> ^result <d3>
         ^next-column nil)
-->
 #  (write (crlf) |Result Number: |  (+ (* 100 <d3>) (* 10 <d2>) <d1>))
   (<ap> ^result-number (+ (* 100 <d3>) (* 10 <d2>) <d1>))
}
sp {arithmetic*elaborate*state*top-number*four-column
   (state <s> ^name arithmetic
              ^superstate nil
              ^arithmetic-problem <ap>)
   (<ap> ^one-column <oc>)
   (<oc> ^digit1 <d1>
         ^next-column <tc>)
   (<tc> ^digit1 <d2>
         ^next-column <hc>)
   (<hc> ^digit1 <d3>
         ^next-column <thc>)
   (<thc> ^digit1 <d4>
          ^next-column nil)
-->
  # (write (crlf) |Top Number: |  (+ (* 1000 <d4>) (* 100 <d3>) (* 10 <d2>) <d1>))
   (<ap> ^top-number (+ (* 1000 <d4>) (* 100 <d3>) (* 10 <d2>) <d1>))
}
sp {arithmetic*elaborate*state*bottom-number*four-column
   (state <s> ^name arithmetic
              ^superstate nil
              ^arithmetic-problem <ap>)
   (<ap> ^one-column <oc>)
   (<oc> ^digit2 <d1>
         ^next-column <tc>)
   (<tc> ^digit2 <d2>
         ^next-column <hc>)
   (<hc> ^digit2 <d3>
         ^next-column <thc>)
   (<thc> ^digit2 <d4>
          ^next-column nil)
-->
   (<ap> ^bottom-number (+ (* 1000 <d4>) (* 100 <d3>) (* 10 <d2>) <d1>))
}
sp {arithmetic*elaborate*state*result-number*four-column
   (state <s> ^name arithmetic
              ^superstate nil
              ^arithmetic-problem <ap>)
   (<ap> ^one-column <oc>)
   (<oc> ^result <d1>
         ^next-column <tc>)
   (<tc> ^result <d2>
         ^next-column <hc>)
   (<hc> ^result <d3>
         ^next-column <thc>)
   (<thc> ^result <d4>
          ^next-column nil)
-->
  # (write (crlf) |Result Number: |  (+ (* 1000 <d4>) (* 100 <d3>) (* 10 <d2>) <d1>))
   (<ap> ^result-number (+ (* 1000 <d4>) (* 100 <d3>) (* 10 <d2>) <d1>))
}
sp {arithmetic*elaborate*state*compute-answer*add
   (state <s> ^name arithmetic
              ^superstate nil
              ^arithmetic-problem <ap>)
   (<ap> ^top-number <tn>
         ^bottom-number <bn>
         ^operation addition)
-->
   (<ap> ^computed-result (+ <tn> <bn>))
 #  (write (crlf) |Computed Addition Result : | (+ <tn> <bn>))
}
sp {arithmetic*elaborate*state*compute-answer*sub
   (state <s> ^name arithmetic
              ^superstate nil
              ^arithmetic-problem <ap>)
   (<ap> ^top-number <tn>
         ^bottom-number <bn>
         ^operation subtraction)
-->
   (<ap> ^computed-result (- <tn> <bn>))
 #  (write (crlf) |Computed Subtraction Result : | (- <tn> <bn>))
}
sp {arithmetic*elaborate*state*compare-results*not-equal
   (state <s> ^name arithmetic
              ^superstate nil
              ^arithmetic-problem <ap>)
   (<ap> ^computed-result <cr>
         ^top-number <tn>
         ^bottom-number <bn>
         ^operation-symbol <os> 
         ^result-number { <> <cr> <rn>})
-->
   (write (crlf) |***************************Results Incorrect: | <tn> | | <os> | | <bn> | = | <cr> | <> | <rn> | Diff | (- <cr> <rn>))
   (halt)
}
sp {get-digit1*propose*compute-result
   (state <s> ^name get-digit1
              ^digit1 <a1>
              ^digit2 <a2>
             -^result)
-->
   (<s> ^operator <op> + =)
   (<op> ^name compute-result)
}
sp {get-digit1*elaborate*state
   (state <s> ^name get-digit1
              ^superstate.current-column <c>)
   (<c> ^digit1 <a>
        ^carry-borrow <cb>)
-->
   (<s> ^digit1 <a>
        ^digit2 <cb>)
}
sp {process-column*propose*write-digit1
   (state <s> ^name get-digit1
              ^result <a>)
-->
   (<s> ^operator <op> + =)
   (<op> ^name write-digit1)
}
sp {process-column*apply*write-digit1-carry1
   (state <s> ^operator.name write-digit1
              ^result <a>
              ^carry-borrow 1
              ^superstate <ss>)
-->
   (<ss> ^digit1 <a>
         ^carry-borrow 1)
}
sp {process-column*apply*write-digit1*carry0
   (state <s> ^operator.name write-digit1
              ^result <a>
              ^carry-borrow 0
              ^superstate <ss>)
-->
   (<ss> ^digit1 <a>)
}
sp {process-column*propose*get-digit2
   (state <s> ^name process-column
             -^digit2)
-->
   (<s> ^operator <op> + =)
   (<op> ^name get-digit2)
}
sp {process-column*apply*get-digit2
   (state <s> ^operator.name get-digit2
              ^current-column.digit2 <a>)
-->
   (<s> ^digit2 <a>)
}
sp {process-column*propose*compute-result
   (state <s> ^name process-column
              ^digit1 <a1>
              ^digit2 <a2>
             -^result)
-->
   (<s> ^operator <op> + =)
   (<op> ^name compute-result)
}
sp {process-column*apply*compute-result*query*add
   (state <s> ^operator.name compute-result
              ^arithmetic-problem.operation <op>
              ^digit1 <a1>
              ^digit2 <a2>)
-->
   (<s> ^query <q>)
   (<q> ^digit1 <a1>
        ^digit2 <a2>
        ^operation <op>)
}
sp {process-column*apply*compute-result*query*add*smem
   (state <s> ^operator.name compute-result
              ^arithmetic-problem.operation addition
              ^digit1 <a1>
              ^digit2 <a2>
              ^smem.command <cmd>
              ^top-state.fact-source smem)
-->
   (<cmd> ^query <q>)
   (<q> ^digit1 <a1>
        ^digit2 <a2>
        ^sum <sum>
        ^carry-borrow <cb>)
}
sp {process-column*apply*compute-result*clean-query*add
   (state <s> ^operator.name compute-result
              ^digit1 <a1>
              ^digit2 <a2>
              ^arithmetic-problem.operation addition
              ^smem.command <cmd>)
   (<cmd> ^query <q>)
  -(<q> ^digit1 <a1>
        ^digit2 <a2>)
-->
   (<cmd> ^query <q> -)
}
sp {process-column*apply*compute-result*addition*retrieval*wm
   (state <s> ^query <q>
              ^arithmetic.facts <af>
              ^top-state.fact-source wm)
   (<q> ^operation addition
        ^digit1 <d1>
        ^digit2 <d2>)
   (<af> ^digit1 <d1>
         ^digit2 <d2>
         ^sum <sum>
         ^carry-borrow <cb>)
-->
   (<q> ^sum <sum>
        ^carry-borrow <cb>)
}
sp {process-column*apply*compute-result*addition*retrieval*smem
   (state <s> ^query <q>
              ^smem.result.retrieved <af>
              ^top-state.fact-source smem)
   (<q> ^operation addition
        ^digit1 <d1>
        ^digit2 <d2>)
   (<af> ^digit1 <d1>
         ^digit2 <d2>
         ^sum <sum>
         ^carry-borrow <cb>)
-->
   (<q> ^sum <sum>
        ^carry-borrow <cb>)
}
sp {process-column*apply*compute-result*use*wm
   (state <s> ^operator.name compute-result
              ^digit1 <d1>
              ^digit2 <d2>
              ^query <q>
              ^top-state.fact-source wm)
   (<q> ^digit1 <d1>
        ^digit2 <d2>
        ^sum <sum>
        ^carry-borrow <cb>)
-->
   (<s> ^result <sum>
        ^carry-borrow <cb>)
}
sp {process-column*apply*compute-result*use*smem
   (state <s> ^operator.name compute-result
              ^digit1 <d1>
              ^digit2 <d2>
              ^query <q>
              ^top-state.fact-source smem
              ^smem.command <cmd>)
   (<q> ^digit1 <d1>
        ^digit2 <d2>
        ^sum <sum>
        ^carry-borrow <cb>)
   (<cmd> ^query <smem-q>)
-->
   (<s> ^result <sum>
        ^carry-borrow <cb>)
   (<cmd> ^query <smem-q> -)
}
sp {process-column*apply*compute-result*subtraction*wm
   (state <s> ^operator.name compute-result
              ^arithmetic.subtraction-facts <af>
              ^arithmetic-problem.operation subtraction
              ^digit1 <a1>
              ^digit2 <a2>
              ^top-state.fact-source wm)
   (<af> ^digit1 <a1>
         ^digit2 <a2>
         ^result <result>)
-->
   (<s> ^result <result>)
}
sp {process-column*apply*compute-result*clean-query*subtract
   (state <s> ^operator.name compute-result
              ^digit1 <a1>
              ^digit2 <a2>
              ^arithmetic-problem.operation subtraction
              ^smem.command <cmd>)
   (<cmd> ^query <q>)
  -(<q> ^digit1 <a1>
        ^digit2 <a2>)
-->
   (<cmd> ^query <q> -)
}
sp {process-column*apply*compute-result*query*subtract*smem
   (state <s> ^operator.name compute-result
              ^arithmetic-problem.operation subtraction
              ^digit1 <a1>
              ^digit2 <a2>
              ^smem.command <cmd>
              ^top-state.fact-source smem)
-->
   (<cmd> ^query <q>)
   (<q> ^digit1 <a1>
        ^digit2 <a2>
        ^result <result>)
}
sp {process-column*apply*compute-result*subtraction*smem
   (state <s> ^operator.name compute-result
              ^smem <smem>
              ^arithmetic-problem.operation subtraction
              ^digit1 <a1>
              ^digit2 <a2>
              ^top-state.fact-source smem)
   (<af> ^digit1 <a1>
         ^digit2 <a2>
         ^result <result>)
   (<smem> ^result.retrieved <af>
           ^command <cmd>)
   (<cmd> ^query <smem-q>)
-->
   (<s> ^result <result>)
   (<cmd> ^query <smem-q> -)
}
sp {process-column*propose*write-result
   (state <s> ^name process-column
              ^result <a>
             -^carry-borrow 1
             -^current-column.result)
-->
   (<s> ^operator <op> + =)
   (<op> ^name write-result)
}
sp {process-column*propose*write-result2
   (state <s> ^name process-column
              ^result <a>
              ^carry-borrow 1
              ^current-column <cc>)
   (<cc> ^next-column.carry-borrow
        -^result)
-->
   (<s> ^operator <op> + =)
   (<op> ^name write-result)
}
sp {process-column*apply*write-result
   (state <s> ^operator.name write-result
              ^result <a>
              ^current-column <cc>)
-->
   (<cc> ^result <a>)
}
sp {carry-borrow*propose*new-column
   (state <s> ^name carry-borrow
              ^current-column.next-column nil)
-->
   (<s> ^operator.name new-column)}
sp {carry-borrow*apply*new-column
   (state <s> ^operator.name new-column
              ^current-column <cc>)
-->
   (<cc> ^next-column <nc>
                      nil -)
   (<nc> ^digit1 0
         ^digit2 0
         ^column t
         ^next-column nil)
}
sp {process-column*propose*get-digit1
   (state <s> ^name process-column
             -^digit1)
-->
   (<s> ^operator <op> + =)
   (<op> ^name get-digit1)
}
sp {process-column*apply*get-digit1
   (state <s> ^operator.name get-digit1
              ^current-column <cc>)
   (<cc> ^digit1 <a>
        -^new-digit1
        -^carry-borrow 1)
-->
   (<s> ^digit1 <a>)
}
sp {process-column*apply*get-digit1-new 
   (state <s> ^operator.name get-digit1
              ^current-column <cc>)
   (<cc> ^digit1 
         ^new-digit1 <a>
        -^carry-borrow 1)
-->
   (<s> ^digit1 <a>)
}
sp {process-column*propose*carry-borrow
   (state <s> ^name << process-column get-digit1 >>
              ^carry-borrow 1
              ^current-column.next-column <nc>)
   (<nc> -^carry-borrow)
-->
   (<s> ^operator <op> + =)
   (<op> ^name carry-borrow)
}
sp {process-column*apply*carry-borrow
   (state <s> ^operator.name carry-borrow
              ^carry-borrow 1
              ^current-column.next-column <nc>)
   (<nc> ^column t)
-->
   (<nc> ^carry-borrow 1)
}
sp {process-column*compare*carry-borrow
   (state <s> ^name process-column
              ^operator <op1> +
                        <op2> +)
   (<op1> ^name carry-borrow)
   (<op2> ^name write-result)
-->
   (<s> ^operator <op1> > <op2>)
}
sp {compute-result*propose*add-ten
   (state <s> ^name compute-result
              ^current-column.new-digit1 <r>
              ^result <r>)
-->
   (<s> ^operator <op> + =)
   (<op> ^name add-ten)
}
sp {compute-result*apply*add-ten*wm
   (state <s> ^operator <op>
              ^arithmetic.add10-facts <af>
              ^superstate <ss>
              ^top-state.fact-source wm)
   (<ss> ^digit1 <d>)
   (<af> ^digit1 <d>
         ^digit-10 <d10>)
   (<op> ^name add-ten)
-->
   (<ss> ^digit1 <d> -
                 <d10>)
}
sp {compute-result*apply*add-ten*smem*query
   (state <s> ^operator <op>
              ^smem.command <cmd>
              ^superstate <ss>
              ^top-state.fact-source smem)
   (<ss> ^digit1 <d>)
   (<op> ^name add-ten)
-->
   (<cmd> ^query <q>)
   (<q> ^digit1 <d>
        ^digit-10 <d10>)
}
sp {compute-result*apply*add-ten*smem*result
   (state <s> ^operator <op>
              ^smem.result.retrieved <af>
              ^superstate <ss>
              ^top-state.fact-source smem)
   (<ss> ^digit1 <d>)
   (<af> ^digit1 <d>
         ^digit-10 <d10>)
   (<op> ^name add-ten)
-->
   (<ss> ^digit1 <d> -
                 <d10>)
}
sp {compute-result*propose*compute-result
   (state <s> ^name compute-result
              ^digit1 <a1>
              ^digit2 <a2>
             -^result)
-->
   (<s> ^operator <op> + =)
   (<op> ^name compute-result)
}
sp {compute-result*elaborate*substate
   (state <s> ^name compute-result
              ^superstate.current-column <cc>)
   (<cc> ^next-column <nc>)
   (<nc> ^digit1 <d1>)
-->
   (<s> ^current-column <nc>
        ^digit1 <d1>
        ^digit2 1)
}
sp {compute-result*propose*borrow
   (state <s> ^name compute-result
             -^current-column.new-digit1 <r>
              ^result <r>)
-->
   (<s> ^operator <op> + =)
   (<op> ^name borrow)
}
sp {compute-result*apply*borrow
   (state <s> ^operator <op>
              ^result <r>
              ^current-column <cc>)
   (<cc> ^digit1 <d1>)
   (<op> ^name borrow)
-->
   (<cc> ^new-digit1 <r>)
}
sp {arithmetic*propose*next-column
   (state <s> ^name arithmetic
              ^arithmetic-problem.current-column <c>)
   (<c> ^result
        ^next-column <nc>)
   (<nc> ^column t)
-->
   (<s> ^operator <op> + =)
   (<op> ^name next-column)
}
sp {arithmetic*apply*next-column
   (state <s> ^operator.name next-column
              ^arithmetic-problem <ap>)
   (<ap> ^current-column <c>)
   (<c> ^next-column <nc>)
-->
   (<ap> ^current-column <c> -
                         <nc>)
}
sp {arithmetic*propose*generate-facts
   (state <s> ^name arithmetic
             -^arithmetic.facts)
-->
   (<s> ^operator <op> + =, >)
   (<op> ^name generate-facts)
}
sp {arithmetic*apply*generate-facts*smem
   (state <s> ^operator.name generate-facts
              ^fact-source smem)
-->
   (<s> ^arithmetic.facts preloaded)
}
sp {arithmetic*apply*generate-facts*add*sub
   (state <s> ^operator.name generate-facts
              ^fact-source wm)
-->
   (<s> ^arithmetic.facts
                          <a01> <a02> <a03> <a04> <a05> <a06> <a07> <a08> <a09> <a00>
                          <a11> <a12> <a13> <a14> <a15> <a16> <a17> <a18> <a19> <a10>
                          <a21> <a22> <a23> <a24> <a25> <a26> <a27> <a28> <a29> <a20>
                          <a31> <a32> <a33> <a34> <a35> <a36> <a37> <a38> <a39> <a30>
                          <a41> <a42> <a43> <a44> <a45> <a46> <a47> <a48> <a49> <a40>
                          <a51> <a52> <a53> <a54> <a55> <a56> <a57> <a58> <a59> <a50>
                          <a61> <a62> <a63> <a64> <a65> <a66> <a67> <a68> <a69> <a60>
                          <a71> <a72> <a73> <a74> <a75> <a76> <a77> <a78> <a79> <a70>
                          <a81> <a82> <a83> <a84> <a85> <a86> <a87> <a88> <a89> <a80>
                          <a91> <a92> <a93> <a94> <a95> <a96> <a97> <a98> <a99> <a90>)
   (<a00> ^digit1 0 ^digit2 0 ^sum 0 ^carry-borrow 0)
   (<a01> ^digit1 0 ^digit2 1 ^sum 1 ^carry-borrow 0)
   (<a02> ^digit1 0 ^digit2 2 ^sum 2 ^carry-borrow 0)
   (<a03> ^digit1 0 ^digit2 3 ^sum 3 ^carry-borrow 0)
   (<a04> ^digit1 0 ^digit2 4 ^sum 4 ^carry-borrow 0)
   (<a05> ^digit1 0 ^digit2 5 ^sum 5 ^carry-borrow 0)
   (<a06> ^digit1 0 ^digit2 6 ^sum 6 ^carry-borrow 0)
   (<a07> ^digit1 0 ^digit2 7 ^sum 7 ^carry-borrow 0)
   (<a08> ^digit1 0 ^digit2 8 ^sum 8 ^carry-borrow 0)
   (<a09> ^digit1 0 ^digit2 9 ^sum 9 ^carry-borrow 0)
   (<a10> ^digit1 1 ^digit2 0 ^sum 1 ^carry-borrow 0)
   (<a11> ^digit1 1 ^digit2 1 ^sum 2 ^carry-borrow 0)
   (<a12> ^digit1 1 ^digit2 2 ^sum 3 ^carry-borrow 0)
   (<a13> ^digit1 1 ^digit2 3 ^sum 4 ^carry-borrow 0)
   (<a14> ^digit1 1 ^digit2 4 ^sum 5 ^carry-borrow 0)
   (<a15> ^digit1 1 ^digit2 5 ^sum 6 ^carry-borrow 0)
   (<a16> ^digit1 1 ^digit2 6 ^sum 7 ^carry-borrow 0)
   (<a17> ^digit1 1 ^digit2 7 ^sum 8 ^carry-borrow 0)
   (<a18> ^digit1 1 ^digit2 8 ^sum 9 ^carry-borrow 0)
   (<a19> ^digit1 1 ^digit2 9 ^sum 0 ^carry-borrow 1)
   (<a20> ^digit1 2 ^digit2 0 ^sum 2 ^carry-borrow 0)
   (<a21> ^digit1 2 ^digit2 1 ^sum 3 ^carry-borrow 0)
   (<a22> ^digit1 2 ^digit2 2 ^sum 4 ^carry-borrow 0)
   (<a23> ^digit1 2 ^digit2 3 ^sum 5 ^carry-borrow 0)
   (<a24> ^digit1 2 ^digit2 4 ^sum 6 ^carry-borrow 0)
   (<a25> ^digit1 2 ^digit2 5 ^sum 7 ^carry-borrow 0)
   (<a26> ^digit1 2 ^digit2 6 ^sum 8 ^carry-borrow 0)
   (<a27> ^digit1 2 ^digit2 7 ^sum 9 ^carry-borrow 0)
   (<a28> ^digit1 2 ^digit2 8 ^sum 0 ^carry-borrow 1)
   (<a29> ^digit1 2 ^digit2 9 ^sum 1 ^carry-borrow 1)
   (<a30> ^digit1 3 ^digit2 0 ^sum 3 ^carry-borrow 0)
   (<a31> ^digit1 3 ^digit2 1 ^sum 4 ^carry-borrow 0)
   (<a32> ^digit1 3 ^digit2 2 ^sum 5 ^carry-borrow 0)
   (<a33> ^digit1 3 ^digit2 3 ^sum 6 ^carry-borrow 0)
   (<a34> ^digit1 3 ^digit2 4 ^sum 7 ^carry-borrow 0)
   (<a35> ^digit1 3 ^digit2 5 ^sum 8 ^carry-borrow 0)
   (<a36> ^digit1 3 ^digit2 6 ^sum 9 ^carry-borrow 0)
   (<a37> ^digit1 3 ^digit2 7 ^sum 0 ^carry-borrow 1)
   (<a38> ^digit1 3 ^digit2 8 ^sum 1 ^carry-borrow 1)
   (<a39> ^digit1 3 ^digit2 9 ^sum 2 ^carry-borrow 1)
   (<a40> ^digit1 4 ^digit2 0 ^sum 4 ^carry-borrow 0)
   (<a41> ^digit1 4 ^digit2 1 ^sum 5 ^carry-borrow 0)
   (<a42> ^digit1 4 ^digit2 2 ^sum 6 ^carry-borrow 0)
   (<a43> ^digit1 4 ^digit2 3 ^sum 7 ^carry-borrow 0)
   (<a44> ^digit1 4 ^digit2 4 ^sum 8 ^carry-borrow 0)
   (<a45> ^digit1 4 ^digit2 5 ^sum 9 ^carry-borrow 0)
   (<a46> ^digit1 4 ^digit2 6 ^sum 0 ^carry-borrow 1)
   (<a47> ^digit1 4 ^digit2 7 ^sum 1 ^carry-borrow 1)
   (<a48> ^digit1 4 ^digit2 8 ^sum 2 ^carry-borrow 1)
   (<a49> ^digit1 4 ^digit2 9 ^sum 3 ^carry-borrow 1)
   (<a50> ^digit1 5 ^digit2 0 ^sum 5 ^carry-borrow 0)
   (<a51> ^digit1 5 ^digit2 1 ^sum 6 ^carry-borrow 0)
   (<a52> ^digit1 5 ^digit2 2 ^sum 7 ^carry-borrow 0)
   (<a53> ^digit1 5 ^digit2 3 ^sum 8 ^carry-borrow 0)
   (<a54> ^digit1 5 ^digit2 4 ^sum 9 ^carry-borrow 0)
   (<a55> ^digit1 5 ^digit2 5 ^sum 0 ^carry-borrow 1)
   (<a56> ^digit1 5 ^digit2 6 ^sum 1 ^carry-borrow 1)
   (<a57> ^digit1 5 ^digit2 7 ^sum 2 ^carry-borrow 1)
   (<a58> ^digit1 5 ^digit2 8 ^sum 3 ^carry-borrow 1)
   (<a59> ^digit1 5 ^digit2 9 ^sum 4 ^carry-borrow 1)
   (<a60> ^digit1 6 ^digit2 0 ^sum 6 ^carry-borrow 0)
   (<a61> ^digit1 6 ^digit2 1 ^sum 7 ^carry-borrow 0)
   (<a62> ^digit1 6 ^digit2 2 ^sum 8 ^carry-borrow 0)
   (<a63> ^digit1 6 ^digit2 3 ^sum 9 ^carry-borrow 0)
   (<a64> ^digit1 6 ^digit2 4 ^sum 0 ^carry-borrow 1)
   (<a65> ^digit1 6 ^digit2 5 ^sum 1 ^carry-borrow 1)
   (<a66> ^digit1 6 ^digit2 6 ^sum 2 ^carry-borrow 1)
   (<a67> ^digit1 6 ^digit2 7 ^sum 3 ^carry-borrow 1)
   (<a68> ^digit1 6 ^digit2 8 ^sum 4 ^carry-borrow 1)
   (<a69> ^digit1 6 ^digit2 9 ^sum 5 ^carry-borrow 1)
   (<a70> ^digit1 7 ^digit2 0 ^sum 7 ^carry-borrow 0)
   (<a71> ^digit1 7 ^digit2 1 ^sum 8 ^carry-borrow 0)
   (<a72> ^digit1 7 ^digit2 2 ^sum 9 ^carry-borrow 0)
   (<a73> ^digit1 7 ^digit2 3 ^sum 0 ^carry-borrow 1)
   (<a74> ^digit1 7 ^digit2 4 ^sum 1 ^carry-borrow 1)
   (<a75> ^digit1 7 ^digit2 5 ^sum 2 ^carry-borrow 1)
   (<a76> ^digit1 7 ^digit2 6 ^sum 3 ^carry-borrow 1)
   (<a77> ^digit1 7 ^digit2 7 ^sum 4 ^carry-borrow 1)
   (<a78> ^digit1 7 ^digit2 8 ^sum 5 ^carry-borrow 1)
   (<a79> ^digit1 7 ^digit2 9 ^sum 6 ^carry-borrow 1)
   (<a80> ^digit1 8 ^digit2 0 ^sum 8 ^carry-borrow 0)
   (<a81> ^digit1 8 ^digit2 1 ^sum 9 ^carry-borrow 0)
   (<a82> ^digit1 8 ^digit2 2 ^sum 0 ^carry-borrow 1)
   (<a83> ^digit1 8 ^digit2 3 ^sum 1 ^carry-borrow 1)
   (<a84> ^digit1 8 ^digit2 4 ^sum 2 ^carry-borrow 1)
   (<a85> ^digit1 8 ^digit2 5 ^sum 3 ^carry-borrow 1)
   (<a86> ^digit1 8 ^digit2 6 ^sum 4 ^carry-borrow 1)
   (<a87> ^digit1 8 ^digit2 7 ^sum 5 ^carry-borrow 1)
   (<a88> ^digit1 8 ^digit2 8 ^sum 6 ^carry-borrow 1)
   (<a89> ^digit1 8 ^digit2 9 ^sum 7 ^carry-borrow 1)
   (<a90> ^digit1 9 ^digit2 0 ^sum 9 ^carry-borrow 0)
   (<a91> ^digit1 9 ^digit2 1 ^sum 0 ^carry-borrow 1)
   (<a92> ^digit1 9 ^digit2 2 ^sum 1 ^carry-borrow 1)
   (<a93> ^digit1 9 ^digit2 3 ^sum 2 ^carry-borrow 1)
   (<a94> ^digit1 9 ^digit2 4 ^sum 3 ^carry-borrow 1)
   (<a95> ^digit1 9 ^digit2 5 ^sum 4 ^carry-borrow 1)
   (<a96> ^digit1 9 ^digit2 6 ^sum 5 ^carry-borrow 1)
   (<a97> ^digit1 9 ^digit2 7 ^sum 6 ^carry-borrow 1)
   (<a98> ^digit1 9 ^digit2 8 ^sum 7 ^carry-borrow 1)
   (<a99> ^digit1 9 ^digit2 9 ^sum 8 ^carry-borrow 1)
}
sp {arithmetic*apply*generate-facts*sub
   (state <s> ^operator.name generate-facts
              ^fact-source wm)
-->
   (<s> ^arithmetic.subtraction-facts
                          <a01> <a02> <a03> <a04> <a05> <a06> <a07> <a08> <a09> <a00>
                          <a11> <a12> <a13> <a14> <a15> <a16> <a17> <a18> <a19> <a10>
                          <a21> <a22> <a23> <a24> <a25> <a26> <a27> <a28> <a29> <a20>
                          <a31> <a32> <a33> <a34> <a35> <a36> <a37> <a38> <a39> <a30>
                          <a41> <a42> <a43> <a44> <a45> <a46> <a47> <a48> <a49> <a40>
                          <a51> <a52> <a53> <a54> <a55> <a56> <a57> <a58> <a59> <a50>
                          <a61> <a62> <a63> <a64> <a65> <a66> <a67> <a68> <a69> <a60>
                          <a71> <a72> <a73> <a74> <a75> <a76> <a77> <a78> <a79> <a70>
                          <a81> <a82> <a83> <a84> <a85> <a86> <a87> <a88> <a89> <a80>
                          <a91> <a92> <a93> <a94> <a95> <a96> <a97> <a98> <a99> <a90>)
   (<a00> ^digit1 0 ^digit2 0 ^result 0)
   (<a01> ^digit1 10 ^digit2 1 ^result 9)
   (<a02> ^digit1 10 ^digit2 2 ^result 8)
   (<a03> ^digit1 10 ^digit2 3 ^result 7)
   (<a04> ^digit1 10 ^digit2 4 ^result 6)
   (<a05> ^digit1 10 ^digit2 5 ^result 5)
   (<a06> ^digit1 10 ^digit2 6 ^result 4)
   (<a07> ^digit1 10 ^digit2 7 ^result 3)
   (<a08> ^digit1 10 ^digit2 8 ^result 2)
   (<a09> ^digit1 10 ^digit2 9 ^result 1)
   (<a10> ^digit1 1 ^digit2 0 ^result 1)
   (<a11> ^digit1 1 ^digit2 1 ^result 0)
   (<a12> ^digit1 11 ^digit2 2 ^result 9)
   (<a13> ^digit1 11 ^digit2 3 ^result 8)
   (<a14> ^digit1 11 ^digit2 4 ^result 7)
   (<a15> ^digit1 11 ^digit2 5 ^result 6)
   (<a16> ^digit1 11 ^digit2 6 ^result 5)
   (<a17> ^digit1 11 ^digit2 7 ^result 4)
   (<a18> ^digit1 11 ^digit2 8 ^result 3)
   (<a19> ^digit1 11 ^digit2 9 ^result 2)
   (<a20> ^digit1 2 ^digit2 0 ^result 2)
   (<a21> ^digit1 2 ^digit2 1 ^result 1)
   (<a22> ^digit1 2 ^digit2 2 ^result 0)
   (<a23> ^digit1 12 ^digit2 3 ^result 9)
   (<a24> ^digit1 12 ^digit2 4 ^result 8)
   (<a25> ^digit1 12 ^digit2 5 ^result 7)
   (<a26> ^digit1 12 ^digit2 6 ^result 6)
   (<a27> ^digit1 12 ^digit2 7 ^result 5)
   (<a28> ^digit1 12 ^digit2 8 ^result 4)
   (<a29> ^digit1 12 ^digit2 9 ^result 3)
   (<a30> ^digit1 3 ^digit2 0 ^result 3)
   (<a31> ^digit1 3 ^digit2 1 ^result 2)
   (<a32> ^digit1 3 ^digit2 2 ^result 1)
   (<a33> ^digit1 3 ^digit2 3 ^result 0)
   (<a34> ^digit1 13 ^digit2 4 ^result 9)
   (<a35> ^digit1 13 ^digit2 5 ^result 8)
   (<a36> ^digit1 13 ^digit2 6 ^result 7)
   (<a37> ^digit1 13 ^digit2 7 ^result 6)
   (<a38> ^digit1 13 ^digit2 8 ^result 5)
   (<a39> ^digit1 13 ^digit2 9 ^result 4)
   (<a40> ^digit1 4 ^digit2 0 ^result 4)
   (<a41> ^digit1 4 ^digit2 1 ^result 3)
   (<a42> ^digit1 4 ^digit2 2 ^result 2)
   (<a43> ^digit1 4 ^digit2 3 ^result 1)
   (<a44> ^digit1 4 ^digit2 4 ^result 0)
   (<a45> ^digit1 14 ^digit2 5 ^result 9)
   (<a46> ^digit1 14 ^digit2 6 ^result 8)
   (<a47> ^digit1 14 ^digit2 7 ^result 7)
   (<a48> ^digit1 14 ^digit2 8 ^result 6)
   (<a49> ^digit1 14 ^digit2 9 ^result 5)
   (<a50> ^digit1 5 ^digit2 0 ^result 5)
   (<a51> ^digit1 5 ^digit2 1 ^result 4)
   (<a52> ^digit1 5 ^digit2 2 ^result 3)
   (<a53> ^digit1 5 ^digit2 3 ^result 2)
   (<a54> ^digit1 5 ^digit2 4 ^result 1)
   (<a55> ^digit1 5 ^digit2 5 ^result 0)
   (<a56> ^digit1 15 ^digit2 6 ^result 9)
   (<a57> ^digit1 15 ^digit2 7 ^result 8)
   (<a58> ^digit1 15 ^digit2 8 ^result 7)
   (<a59> ^digit1 15 ^digit2 9 ^result 6)
   (<a60> ^digit1 6 ^digit2 0 ^result 6)
   (<a61> ^digit1 6 ^digit2 1 ^result 5)
   (<a62> ^digit1 6 ^digit2 2 ^result 4)
   (<a63> ^digit1 6 ^digit2 3 ^result 3)
   (<a64> ^digit1 6 ^digit2 4 ^result 2)
   (<a65> ^digit1 6 ^digit2 5 ^result 1)
   (<a66> ^digit1 6 ^digit2 6 ^result 0)
   (<a67> ^digit1 16 ^digit2 7 ^result 9)
   (<a68> ^digit1 16 ^digit2 8 ^result 8)
   (<a69> ^digit1 16 ^digit2 9 ^result 7)
   (<a70> ^digit1 7 ^digit2 0 ^result 7)
   (<a71> ^digit1 7 ^digit2 1 ^result 6)
   (<a72> ^digit1 7 ^digit2 2 ^result 5)
   (<a73> ^digit1 7 ^digit2 3 ^result 4)
   (<a74> ^digit1 7 ^digit2 4 ^result 3)
   (<a75> ^digit1 7 ^digit2 5 ^result 2)
   (<a76> ^digit1 7 ^digit2 6 ^result 1)
   (<a77> ^digit1 7 ^digit2 7 ^result 0)
   (<a78> ^digit1 17 ^digit2 8 ^result 9)
   (<a79> ^digit1 17 ^digit2 9 ^result 8)
   (<a80> ^digit1 8 ^digit2 0 ^result 8)
   (<a81> ^digit1 8 ^digit2 1 ^result 7)
   (<a82> ^digit1 8 ^digit2 2 ^result 6)
   (<a83> ^digit1 8 ^digit2 3 ^result 5)
   (<a84> ^digit1 8 ^digit2 4 ^result 4)
   (<a85> ^digit1 8 ^digit2 5 ^result 3)
   (<a86> ^digit1 8 ^digit2 6 ^result 2)
   (<a87> ^digit1 8 ^digit2 7 ^result 1)
   (<a88> ^digit1 8 ^digit2 8 ^result 0)
   (<a89> ^digit1 18 ^digit2 9 ^result 9)
   (<a90> ^digit1 9 ^digit2 0 ^result 9)
   (<a91> ^digit1 9 ^digit2 1 ^result 8)
   (<a92> ^digit1 9 ^digit2 2 ^result 7)
   (<a93> ^digit1 9 ^digit2 3 ^result 6)
   (<a94> ^digit1 9 ^digit2 4 ^result 5)
   (<a95> ^digit1 9 ^digit2 5 ^result 4)
   (<a96> ^digit1 9 ^digit2 6 ^result 3)
   (<a97> ^digit1 9 ^digit2 7 ^result 2)
   (<a98> ^digit1 9 ^digit2 8 ^result 1)
   (<a99> ^digit1 9 ^digit2 9 ^result 0)
}
sp {arithmetic*apply*generate-facts*add10
   (state <s> ^operator.name generate-facts
              ^fact-source wm)
-->
   (<s> ^arithmetic.add10-facts
                          <a01> <a02> <a03> <a04> <a05> <a06> <a07> <a08> <a09> <a00>)
   (<a00> ^digit1 0 ^digit-10 10)
   (<a01> ^digit1 1 ^digit-10 11)
   (<a02> ^digit1 2 ^digit-10 12)
   (<a03> ^digit1 3 ^digit-10 13)
   (<a04> ^digit1 4 ^digit-10 14)
   (<a05> ^digit1 5 ^digit-10 15)
   (<a06> ^digit1 6 ^digit-10 16)
   (<a07> ^digit1 7 ^digit-10 17)
   (<a08> ^digit1 8 ^digit-10 18)
   (<a09> ^digit1 9 ^digit-10 19)
}
sp {arithmetic*propose*stop-arithmetic
   (state <s> ^name arithmetic
              ^count 0)
-->
   (<s> ^operator <op> + =)
   (<op> ^name stop-arithmetic)
}
sp {arithmetic*apply*stop-arithmetic
   (state <s> ^operator <op>)
   (<op> ^name stop-arithmetic)
-->
   (write |Finished|)
   (halt)
}
sp {generate-problem*propose*generate-digit2
   (state <s> ^name generate-problem
              ^digits <d>
              ^current-column  { <> nil <cc> })
   (<cc> -^digit2
          ^digit1)
-->
   (<s> ^operator <op> + =)
   (<op> ^name generate-digit2
         ^digit2 <d>)
}
sp {generate-problem*compare*generate-digit2
   (state <s> ^name generate-problem
              ^current-column <cc>
              ^problem.operation subtraction
              ^operator <op1> +)
   (<op1> ^name generate-digit2
          ^digit2 >= <d>)
   (<cc> ^digit1 <d>
         ^next-column nil)
-->
   (<s> ^operator <op1> <)
}
sp {generate-problem*apply*generate-digit2
   (state <s> ^operator <op>
              ^current-column <c1>)
   (<op> ^name generate-digit2
         ^digit2 <d>)
-->
   (<c1> ^digit2 <d>)
}
sp {generate-problem*propose*next-column
   (state <s> ^name generate-problem
              ^current-column <c1>)
   (<c1> ^digit1
         ^digit2
         ^next-column <x>)
-->
   (<s> ^operator <op> + =)
   (<op> ^name next-column)
}
sp {generate-problem*apply*next-column
   (state <s> ^operator <op>
              ^current-column <cc>)
   (<op> ^name next-column)
   (<cc> ^next-column <nc>)
-->
   (<s> ^current-column <cc> -
                        <nc>)
}
sp {generate-problem*propose*generate-operation-add
   (state <s> ^quiescence t
              ^name generate-problem
             -^problem)
-->
   (<s> ^operator <op> + =)
   (<op> ^name generate-operation
         ^operation addition
         ^operation-symbol |+|)
}
sp {generate-problem*propose*generate-operation-sub
   (state <s> ^quiescence t
              ^name generate-problem
             -^problem)
-->
   (<s> ^operator <op> + =)
   (<op> ^name generate-operation
         ^operation subtraction
         ^operation-symbol |-|)
}
sp {generate-problem*apply*generate-operation
   (state <s> ^operator <op>)
   (<op> ^name generate-operation
         ^operation <oper>
         ^operation-symbol <os>)
-->
   (<s> ^digits 0 1 2 3 4 5 6 7 8 9
        ^problem <p>
        ^current-column <c1>)
   (<p> ^operation <oper>
        ^operation-symbol <os>
        ^current-column <c1>
        ^one-column <c1>)
   (<c1> ^next-column <c2>
         ^column t)
   (<c2> ^next-column <c3>
         ^column t)
   (<c3> ^next-column nil
         ^column t)}
sp {generate-problem*propose*finish-problem-generation
   (state <s> ^name generate-problem
              ^current-column nil)
-->
   (<s> ^operator <op> + =)
   (<op> ^name finish-problem-generation)
}
sp {generate-problem*apply*finish-problem-generation
   (state <s> ^operator <op>
              ^superstate <ss>
              ^problem <p>)
   (<op> ^name finish-problem-generation)
-->
   (<ss> ^arithmetic-problem <p>)
}
sp {generate-problem*propose*generate-digit1
   (state <s> ^name generate-problem
              ^digits <d>
              ^current-column { <> nil <cc> })
   (<cc> -^digit1)
-->
   (<s> ^operator <op> + =)
   (<op> ^name generate-digit1
         ^digit1 <d>)
}
sp {generate-problem*compare*generate-digit1
   (state <s> ^name generate-problem
              ^current-column <cc>
              ^problem.operation subtraction
              ^operator <op1> +)
   (<op1> ^name generate-digit1
          ^digit1 0)
   (<cc> ^next-column nil)
-->
   (<s> ^operator <op1> -)
}
sp {generate-problem*apply*generate-digit1
   (state <s> ^operator <op>
              ^current-column <c1>)
   (<op> ^name generate-digit1
         ^digit1 <d>)
-->
   (<c1> ^digit1 <d>)
}
sp {arithmetic*propose*initialize-arithmetic
   (state <s> ^superstate nil
             -^name)
-->
   (<s> ^operator <o> +)
   (<o> ^name initialize-arithmetic)
}
sp {arithmetic*apply*initialize-arithmetic
   (state <s> ^operator.name initialize-arithmetic)
-->
   (<s> ^name arithmetic
        ^fact-source smem
        ^output yes
        ^count 1000)}
sp {arithmetic*propose*generate-problem
   (state <s> ^name arithmetic
             -^arithmetic-problem
             -^count 0)
-->
   (<s> ^operator <op> + =)
   (<op> ^name generate-problem)
}
sp {arithmetic*propose*finish-problem
   (state <s> ^name arithmetic
              ^count <count>
              ^arithmetic-problem.current-column <c>)
   (<c> ^result
        ^next-column nil)
-->
   (<s> ^operator <op> + =)
   (<op> ^name finish-problem
         ^count <count>)
}
sp {arithmetic*apply*finish-problem*decrement-count
   (state <s> ^name arithmetic
              ^operator <o>
              ^arithmetic-problem <ap>
              ^count <c>)
   (<o>  ^name finish-problem
         ^count <c>)
-->
   (<s> ^arithmetic-problem <ap> -
        ^count <c> -
               (- <c> 1))
}
sp {generate-facts*propose*clean
   (state <s> ^name generate-facts
              ^phase clean)
-->
   (<s> ^operator <op> + =)
   (<op> ^name clean)
}
sp {apply*clean
   (state <s> ^operator <op>
              ^superstate <ss>)
   (<op> ^name clean)
   (<ss> ^operator <ss-op>)
-->
   (<ss> ^arithmetic.facts new)
}
sp {generate-facts*propose*store
   (state <s> ^name generate-facts
              ^phase store)
-->
   (<s> ^operator <op> + =)
   (<op> ^name store)
}
sp {apply*store
   (state <s> ^operator <op>)
   (<op> ^name store)
-->
   (<s> ^phase store -
        ^phase clean)
}
sp {arithmetic*apply*store*add
   (state <s> ^operator.name store
              ^smem.command <cmd>)
   (<cmd> ^store <arithmetic>)
-->
   (<cmd> ^store
                          <a01> <a02> <a03> <a04> <a05> <a06> <a07> <a08> <a09> <a00>
                          <a11> <a12> <a13> <a14> <a15> <a16> <a17> <a18> <a19> <a10>
                          <a21> <a22> <a23> <a24> <a25> <a26> <a27> <a28> <a29> <a20>
                          <a31> <a32> <a33> <a34> <a35> <a36> <a37> <a38> <a39> <a30>
                          <a41> <a42> <a43> <a44> <a45> <a46> <a47> <a48> <a49> <a40>
                          <a51> <a52> <a53> <a54> <a55> <a56> <a57> <a58> <a59> <a50>
                          <a61> <a62> <a63> <a64> <a65> <a66> <a67> <a68> <a69> <a60>
                          <a71> <a72> <a73> <a74> <a75> <a76> <a77> <a78> <a79> <a70>
                          <a81> <a82> <a83> <a84> <a85> <a86> <a87> <a88> <a89> <a80>
                          <a91> <a92> <a93> <a94> <a95> <a96> <a97> <a98> <a99> <a90>)
   (<arithmetic> ^facts
                          <a01> <a02> <a03> <a04> <a05> <a06> <a07> <a08> <a09> <a00>
                          <a11> <a12> <a13> <a14> <a15> <a16> <a17> <a18> <a19> <a10>
                          <a21> <a22> <a23> <a24> <a25> <a26> <a27> <a28> <a29> <a20>
                          <a31> <a32> <a33> <a34> <a35> <a36> <a37> <a38> <a39> <a30>
                          <a41> <a42> <a43> <a44> <a45> <a46> <a47> <a48> <a49> <a40>
                          <a51> <a52> <a53> <a54> <a55> <a56> <a57> <a58> <a59> <a50>
                          <a61> <a62> <a63> <a64> <a65> <a66> <a67> <a68> <a69> <a60>
                          <a71> <a72> <a73> <a74> <a75> <a76> <a77> <a78> <a79> <a70>
                          <a81> <a82> <a83> <a84> <a85> <a86> <a87> <a88> <a89> <a80>
                          <a91> <a92> <a93> <a94> <a95> <a96> <a97> <a98> <a99> <a90>)
   (<a00> ^digit1 0 ^digit2 0 ^sum 0 ^carry-borrow 0)
   (<a01> ^digit1 0 ^digit2 1 ^sum 1 ^carry-borrow 0)
   (<a02> ^digit1 0 ^digit2 2 ^sum 2 ^carry-borrow 0)
   (<a03> ^digit1 0 ^digit2 3 ^sum 3 ^carry-borrow 0)
   (<a04> ^digit1 0 ^digit2 4 ^sum 4 ^carry-borrow 0)
   (<a05> ^digit1 0 ^digit2 5 ^sum 5 ^carry-borrow 0)
   (<a06> ^digit1 0 ^digit2 6 ^sum 6 ^carry-borrow 0)
   (<a07> ^digit1 0 ^digit2 7 ^sum 7 ^carry-borrow 0)
   (<a08> ^digit1 0 ^digit2 8 ^sum 8 ^carry-borrow 0)
   (<a09> ^digit1 0 ^digit2 9 ^sum 9 ^carry-borrow 0)
   (<a10> ^digit1 1 ^digit2 0 ^sum 1 ^carry-borrow 0)
   (<a11> ^digit1 1 ^digit2 1 ^sum 2 ^carry-borrow 0)
   (<a12> ^digit1 1 ^digit2 2 ^sum 3 ^carry-borrow 0)
   (<a13> ^digit1 1 ^digit2 3 ^sum 4 ^carry-borrow 0)
   (<a14> ^digit1 1 ^digit2 4 ^sum 5 ^carry-borrow 0)
   (<a15> ^digit1 1 ^digit2 5 ^sum 6 ^carry-borrow 0)
   (<a16> ^digit1 1 ^digit2 6 ^sum 7 ^carry-borrow 0)
   (<a17> ^digit1 1 ^digit2 7 ^sum 8 ^carry-borrow 0)
   (<a18> ^digit1 1 ^digit2 8 ^sum 9 ^carry-borrow 0)
   (<a19> ^digit1 1 ^digit2 9 ^sum 0 ^carry-borrow 1)
   (<a20> ^digit1 2 ^digit2 0 ^sum 2 ^carry-borrow 0)
   (<a21> ^digit1 2 ^digit2 1 ^sum 3 ^carry-borrow 0)
   (<a22> ^digit1 2 ^digit2 2 ^sum 4 ^carry-borrow 0)
   (<a23> ^digit1 2 ^digit2 3 ^sum 5 ^carry-borrow 0)
   (<a24> ^digit1 2 ^digit2 4 ^sum 6 ^carry-borrow 0)
   (<a25> ^digit1 2 ^digit2 5 ^sum 7 ^carry-borrow 0)
   (<a26> ^digit1 2 ^digit2 6 ^sum 8 ^carry-borrow 0)
   (<a27> ^digit1 2 ^digit2 7 ^sum 9 ^carry-borrow 0)
   (<a28> ^digit1 2 ^digit2 8 ^sum 0 ^carry-borrow 1)
   (<a29> ^digit1 2 ^digit2 9 ^sum 1 ^carry-borrow 1)
   (<a30> ^digit1 3 ^digit2 0 ^sum 3 ^carry-borrow 0)
   (<a31> ^digit1 3 ^digit2 1 ^sum 4 ^carry-borrow 0)
   (<a32> ^digit1 3 ^digit2 2 ^sum 5 ^carry-borrow 0)
   (<a33> ^digit1 3 ^digit2 3 ^sum 6 ^carry-borrow 0)
   (<a34> ^digit1 3 ^digit2 4 ^sum 7 ^carry-borrow 0)
   (<a35> ^digit1 3 ^digit2 5 ^sum 8 ^carry-borrow 0)
   (<a36> ^digit1 3 ^digit2 6 ^sum 9 ^carry-borrow 0)
   (<a37> ^digit1 3 ^digit2 7 ^sum 0 ^carry-borrow 1)
   (<a38> ^digit1 3 ^digit2 8 ^sum 1 ^carry-borrow 1)
   (<a39> ^digit1 3 ^digit2 9 ^sum 2 ^carry-borrow 1)
   (<a40> ^digit1 4 ^digit2 0 ^sum 4 ^carry-borrow 0)
   (<a41> ^digit1 4 ^digit2 1 ^sum 5 ^carry-borrow 0)
   (<a42> ^digit1 4 ^digit2 2 ^sum 6 ^carry-borrow 0)
   (<a43> ^digit1 4 ^digit2 3 ^sum 7 ^carry-borrow 0)
   (<a44> ^digit1 4 ^digit2 4 ^sum 8 ^carry-borrow 0)
   (<a45> ^digit1 4 ^digit2 5 ^sum 9 ^carry-borrow 0)
   (<a46> ^digit1 4 ^digit2 6 ^sum 0 ^carry-borrow 1)
   (<a47> ^digit1 4 ^digit2 7 ^sum 1 ^carry-borrow 1)
   (<a48> ^digit1 4 ^digit2 8 ^sum 2 ^carry-borrow 1)
   (<a49> ^digit1 4 ^digit2 9 ^sum 3 ^carry-borrow 1)
   (<a50> ^digit1 5 ^digit2 0 ^sum 5 ^carry-borrow 0)
   (<a51> ^digit1 5 ^digit2 1 ^sum 6 ^carry-borrow 0)
   (<a52> ^digit1 5 ^digit2 2 ^sum 7 ^carry-borrow 0)
   (<a53> ^digit1 5 ^digit2 3 ^sum 8 ^carry-borrow 0)
   (<a54> ^digit1 5 ^digit2 4 ^sum 9 ^carry-borrow 0)
   (<a55> ^digit1 5 ^digit2 5 ^sum 0 ^carry-borrow 1)
   (<a56> ^digit1 5 ^digit2 6 ^sum 1 ^carry-borrow 1)
   (<a57> ^digit1 5 ^digit2 7 ^sum 2 ^carry-borrow 1)
   (<a58> ^digit1 5 ^digit2 8 ^sum 3 ^carry-borrow 1)
   (<a59> ^digit1 5 ^digit2 9 ^sum 4 ^carry-borrow 1)
   (<a60> ^digit1 6 ^digit2 0 ^sum 6 ^carry-borrow 0)
   (<a61> ^digit1 6 ^digit2 1 ^sum 7 ^carry-borrow 0)
   (<a62> ^digit1 6 ^digit2 2 ^sum 8 ^carry-borrow 0)
   (<a63> ^digit1 6 ^digit2 3 ^sum 9 ^carry-borrow 0)
   (<a64> ^digit1 6 ^digit2 4 ^sum 0 ^carry-borrow 1)
   (<a65> ^digit1 6 ^digit2 5 ^sum 1 ^carry-borrow 1)
   (<a66> ^digit1 6 ^digit2 6 ^sum 2 ^carry-borrow 1)
   (<a67> ^digit1 6 ^digit2 7 ^sum 3 ^carry-borrow 1)
   (<a68> ^digit1 6 ^digit2 8 ^sum 4 ^carry-borrow 1)
   (<a69> ^digit1 6 ^digit2 9 ^sum 5 ^carry-borrow 1)
   (<a70> ^digit1 7 ^digit2 0 ^sum 7 ^carry-borrow 0)
   (<a71> ^digit1 7 ^digit2 1 ^sum 8 ^carry-borrow 0)
   (<a72> ^digit1 7 ^digit2 2 ^sum 9 ^carry-borrow 0)
   (<a73> ^digit1 7 ^digit2 3 ^sum 0 ^carry-borrow 1)
   (<a74> ^digit1 7 ^digit2 4 ^sum 1 ^carry-borrow 1)
   (<a75> ^digit1 7 ^digit2 5 ^sum 2 ^carry-borrow 1)
   (<a76> ^digit1 7 ^digit2 6 ^sum 3 ^carry-borrow 1)
   (<a77> ^digit1 7 ^digit2 7 ^sum 4 ^carry-borrow 1)
   (<a78> ^digit1 7 ^digit2 8 ^sum 5 ^carry-borrow 1)
   (<a79> ^digit1 7 ^digit2 9 ^sum 6 ^carry-borrow 1)
   (<a80> ^digit1 8 ^digit2 0 ^sum 8 ^carry-borrow 0)
   (<a81> ^digit1 8 ^digit2 1 ^sum 9 ^carry-borrow 0)
   (<a82> ^digit1 8 ^digit2 2 ^sum 0 ^carry-borrow 1)
   (<a83> ^digit1 8 ^digit2 3 ^sum 1 ^carry-borrow 1)
   (<a84> ^digit1 8 ^digit2 4 ^sum 2 ^carry-borrow 1)
   (<a85> ^digit1 8 ^digit2 5 ^sum 3 ^carry-borrow 1)
   (<a86> ^digit1 8 ^digit2 6 ^sum 4 ^carry-borrow 1)
   (<a87> ^digit1 8 ^digit2 7 ^sum 5 ^carry-borrow 1)
   (<a88> ^digit1 8 ^digit2 8 ^sum 6 ^carry-borrow 1)
   (<a89> ^digit1 8 ^digit2 9 ^sum 7 ^carry-borrow 1)
   (<a90> ^digit1 9 ^digit2 0 ^sum 9 ^carry-borrow 0)
   (<a91> ^digit1 9 ^digit2 1 ^sum 0 ^carry-borrow 1)
   (<a92> ^digit1 9 ^digit2 2 ^sum 1 ^carry-borrow 1)
   (<a93> ^digit1 9 ^digit2 3 ^sum 2 ^carry-borrow 1)
   (<a94> ^digit1 9 ^digit2 4 ^sum 3 ^carry-borrow 1)
   (<a95> ^digit1 9 ^digit2 5 ^sum 4 ^carry-borrow 1)
   (<a96> ^digit1 9 ^digit2 6 ^sum 5 ^carry-borrow 1)
   (<a97> ^digit1 9 ^digit2 7 ^sum 6 ^carry-borrow 1)
   (<a98> ^digit1 9 ^digit2 8 ^sum 7 ^carry-borrow 1)
   (<a99> ^digit1 9 ^digit2 9 ^sum 8 ^carry-borrow 1)
}
sp {arithmetic*apply*store*sub
   (state <s> ^operator.name store
              ^smem.command <cmd>)
   (<cmd> ^store <arithmetic>)
-->
   (<cmd> ^store
                          <a01> <a02> <a03> <a04> <a05> <a06> <a07> <a08> <a09> <a00>
                          <a11> <a12> <a13> <a14> <a15> <a16> <a17> <a18> <a19> <a10>
                          <a21> <a22> <a23> <a24> <a25> <a26> <a27> <a28> <a29> <a20>
                          <a31> <a32> <a33> <a34> <a35> <a36> <a37> <a38> <a39> <a30>
                          <a41> <a42> <a43> <a44> <a45> <a46> <a47> <a48> <a49> <a40>
                          <a51> <a52> <a53> <a54> <a55> <a56> <a57> <a58> <a59> <a50>
                          <a61> <a62> <a63> <a64> <a65> <a66> <a67> <a68> <a69> <a60>
                          <a71> <a72> <a73> <a74> <a75> <a76> <a77> <a78> <a79> <a70>
                          <a81> <a82> <a83> <a84> <a85> <a86> <a87> <a88> <a89> <a80>
                          <a91> <a92> <a93> <a94> <a95> <a96> <a97> <a98> <a99> <a90>)
   (<arithmetic> ^subtraction-facts
                          <a01> <a02> <a03> <a04> <a05> <a06> <a07> <a08> <a09> <a00>
                          <a11> <a12> <a13> <a14> <a15> <a16> <a17> <a18> <a19> <a10>
                          <a21> <a22> <a23> <a24> <a25> <a26> <a27> <a28> <a29> <a20>
                          <a31> <a32> <a33> <a34> <a35> <a36> <a37> <a38> <a39> <a30>
                          <a41> <a42> <a43> <a44> <a45> <a46> <a47> <a48> <a49> <a40>
                          <a51> <a52> <a53> <a54> <a55> <a56> <a57> <a58> <a59> <a50>
                          <a61> <a62> <a63> <a64> <a65> <a66> <a67> <a68> <a69> <a60>
                          <a71> <a72> <a73> <a74> <a75> <a76> <a77> <a78> <a79> <a70>
                          <a81> <a82> <a83> <a84> <a85> <a86> <a87> <a88> <a89> <a80>
                          <a91> <a92> <a93> <a94> <a95> <a96> <a97> <a98> <a99> <a90>)
   (<a00> ^digit1 0 ^digit2 0 ^result 0)
   (<a01> ^digit1 10 ^digit2 1 ^result 9)
   (<a02> ^digit1 10 ^digit2 2 ^result 8)
   (<a03> ^digit1 10 ^digit2 3 ^result 7)
   (<a04> ^digit1 10 ^digit2 4 ^result 6)
   (<a05> ^digit1 10 ^digit2 5 ^result 5)
   (<a06> ^digit1 10 ^digit2 6 ^result 4)
   (<a07> ^digit1 10 ^digit2 7 ^result 3)
   (<a08> ^digit1 10 ^digit2 8 ^result 2)
   (<a09> ^digit1 10 ^digit2 9 ^result 1)
   (<a10> ^digit1 1 ^digit2 0 ^result 1)
   (<a11> ^digit1 1 ^digit2 1 ^result 0)
   (<a12> ^digit1 11 ^digit2 2 ^result 9)
   (<a13> ^digit1 11 ^digit2 3 ^result 8)
   (<a14> ^digit1 11 ^digit2 4 ^result 7)
   (<a15> ^digit1 11 ^digit2 5 ^result 6)
   (<a16> ^digit1 11 ^digit2 6 ^result 5)
   (<a17> ^digit1 11 ^digit2 7 ^result 4)
   (<a18> ^digit1 11 ^digit2 8 ^result 3)
   (<a19> ^digit1 11 ^digit2 9 ^result 2)
   (<a20> ^digit1 2 ^digit2 0 ^result 2)
   (<a21> ^digit1 2 ^digit2 1 ^result 1)
   (<a22> ^digit1 2 ^digit2 2 ^result 0)
   (<a23> ^digit1 12 ^digit2 3 ^result 9)
   (<a24> ^digit1 12 ^digit2 4 ^result 8)
   (<a25> ^digit1 12 ^digit2 5 ^result 7)
   (<a26> ^digit1 12 ^digit2 6 ^result 6)
   (<a27> ^digit1 12 ^digit2 7 ^result 5)
   (<a28> ^digit1 12 ^digit2 8 ^result 4)
   (<a29> ^digit1 12 ^digit2 9 ^result 3)
   (<a30> ^digit1 3 ^digit2 0 ^result 3)
   (<a31> ^digit1 3 ^digit2 1 ^result 2)
   (<a32> ^digit1 3 ^digit2 2 ^result 1)
   (<a33> ^digit1 3 ^digit2 3 ^result 0)
   (<a34> ^digit1 13 ^digit2 4 ^result 9)
   (<a35> ^digit1 13 ^digit2 5 ^result 8)
   (<a36> ^digit1 13 ^digit2 6 ^result 7)
   (<a37> ^digit1 13 ^digit2 7 ^result 6)
   (<a38> ^digit1 13 ^digit2 8 ^result 5)
   (<a39> ^digit1 13 ^digit2 9 ^result 4)
   (<a40> ^digit1 4 ^digit2 0 ^result 4)
   (<a41> ^digit1 4 ^digit2 1 ^result 3)
   (<a42> ^digit1 4 ^digit2 2 ^result 2)
   (<a43> ^digit1 4 ^digit2 3 ^result 1)
   (<a44> ^digit1 4 ^digit2 4 ^result 0)
   (<a45> ^digit1 14 ^digit2 5 ^result 9)
   (<a46> ^digit1 14 ^digit2 6 ^result 8)
   (<a47> ^digit1 14 ^digit2 7 ^result 7)
   (<a48> ^digit1 14 ^digit2 8 ^result 6)
   (<a49> ^digit1 14 ^digit2 9 ^result 5)
   (<a50> ^digit1 5 ^digit2 0 ^result 5)
   (<a51> ^digit1 5 ^digit2 1 ^result 4)
   (<a52> ^digit1 5 ^digit2 2 ^result 3)
   (<a53> ^digit1 5 ^digit2 3 ^result 2)
   (<a54> ^digit1 5 ^digit2 4 ^result 1)
   (<a55> ^digit1 5 ^digit2 5 ^result 0)
   (<a56> ^digit1 15 ^digit2 6 ^result 9)
   (<a57> ^digit1 15 ^digit2 7 ^result 8)
   (<a58> ^digit1 15 ^digit2 8 ^result 7)
   (<a59> ^digit1 15 ^digit2 9 ^result 6)
   (<a60> ^digit1 6 ^digit2 0 ^result 6)
   (<a61> ^digit1 6 ^digit2 1 ^result 5)
   (<a62> ^digit1 6 ^digit2 2 ^result 4)
   (<a63> ^digit1 6 ^digit2 3 ^result 3)
   (<a64> ^digit1 6 ^digit2 4 ^result 2)
   (<a65> ^digit1 6 ^digit2 5 ^result 1)
   (<a66> ^digit1 6 ^digit2 6 ^result 0)
   (<a67> ^digit1 16 ^digit2 7 ^result 9)
   (<a68> ^digit1 16 ^digit2 8 ^result 8)
   (<a69> ^digit1 16 ^digit2 9 ^result 7)
   (<a70> ^digit1 7 ^digit2 0 ^result 7)
   (<a71> ^digit1 7 ^digit2 1 ^result 6)
   (<a72> ^digit1 7 ^digit2 2 ^result 5)
   (<a73> ^digit1 7 ^digit2 3 ^result 4)
   (<a74> ^digit1 7 ^digit2 4 ^result 3)
   (<a75> ^digit1 7 ^digit2 5 ^result 2)
   (<a76> ^digit1 7 ^digit2 6 ^result 1)
   (<a77> ^digit1 7 ^digit2 7 ^result 0)
   (<a78> ^digit1 17 ^digit2 8 ^result 9)
   (<a79> ^digit1 17 ^digit2 9 ^result 8)
   (<a80> ^digit1 8 ^digit2 0 ^result 8)
   (<a81> ^digit1 8 ^digit2 1 ^result 7)
   (<a82> ^digit1 8 ^digit2 2 ^result 6)
   (<a83> ^digit1 8 ^digit2 3 ^result 5)
   (<a84> ^digit1 8 ^digit2 4 ^result 4)
   (<a85> ^digit1 8 ^digit2 5 ^result 3)
   (<a86> ^digit1 8 ^digit2 6 ^result 2)
   (<a87> ^digit1 8 ^digit2 7 ^result 1)
   (<a88> ^digit1 8 ^digit2 8 ^result 0)
   (<a89> ^digit1 18 ^digit2 9 ^result 9)
   (<a90> ^digit1 9 ^digit2 0 ^result 9)
   (<a91> ^digit1 9 ^digit2 1 ^result 8)
   (<a92> ^digit1 9 ^digit2 2 ^result 7)
   (<a93> ^digit1 9 ^digit2 3 ^result 6)
   (<a94> ^digit1 9 ^digit2 4 ^result 5)
   (<a95> ^digit1 9 ^digit2 5 ^result 4)
   (<a96> ^digit1 9 ^digit2 6 ^result 3)
   (<a97> ^digit1 9 ^digit2 7 ^result 2)
   (<a98> ^digit1 9 ^digit2 8 ^result 1)
   (<a99> ^digit1 9 ^digit2 9 ^result 0)
}
sp {arithmetic*apply*store*add10
   (state <s> ^operator.name store
              ^smem.command <cmd>)
   (<cmd> ^store <arithmetic>)
-->
   (<cmd> ^store
                          <a01> <a02> <a03> <a04> <a05> <a06> <a07> <a08> <a09> <a00>)
   (<arithmetic> ^add10-facts
                          <a01> <a02> <a03> <a04> <a05> <a06> <a07> <a08> <a09> <a00>)
   (<a00> ^digit1 0 ^digit-10 10)
   (<a01> ^digit1 1 ^digit-10 11)
   (<a02> ^digit1 2 ^digit-10 12)
   (<a03> ^digit1 3 ^digit-10 13)
   (<a04> ^digit1 4 ^digit-10 14)
   (<a05> ^digit1 5 ^digit-10 15)
   (<a06> ^digit1 6 ^digit-10 16)
   (<a07> ^digit1 7 ^digit-10 17)
   (<a08> ^digit1 8 ^digit-10 18)
   (<a09> ^digit1 9 ^digit-10 19)
}
sp {generate-facts*propose*init
   (state <s> ^name generate-facts
             -^phase)
-->
   (<s> ^operator <op> + =)
   (<op> ^name init)
}
sp {apply*init
   (state <s> ^operator <op>
              ^smem.command <cmd>)
   (<op> ^name init)
-->
   (<s> ^phase check)
   (<cmd> ^query.facts <fact>)
}
sp {generate-facts*propose*check
   (state <s> ^name generate-facts
              ^phase check)
-->
   (<s> ^operator <op> + =)
   (<op> ^name check)
}
sp {apply*check*new
   (state <s> ^operator <op>
              ^smem <smem>)
   (<op> ^name check)
   (<smem> ^result.failure <q>
           ^command <cmd>)
   (<cmd> ^query <q>)
-->
   (<s> ^phase check -
        ^phase store)
   (<cmd> ^query <q> -
          ^store <arithmetic>)
}
sp {apply*check*existing
   (state <s> ^operator <op>
              ^smem.result.success <q>
              ^superstate <ss>)
   (<op> ^name check)
   (<ss> ^operator <ss-op>)
-->
   (<ss> ^arithmetic.facts existing)
}
sp {arithmetic*propose*process-column
   (state <s> ^name arithmetic
              ^arithmetic-problem.current-column <cc>)
  -(<cc> ^result)
-->
   (<s> ^operator <op> + =)
   (<op> ^name process-column)
}
smem --set learning on
smem --add {
   (<arithmetic> ^facts
                          <a01> <a02> <a03> <a04> <a05> <a06> <a07> <a08> <a09> <a00>
                          <a11> <a12> <a13> <a14> <a15> <a16> <a17> <a18> <a19> <a10>
                          <a21> <a22> <a23> <a24> <a25> <a26> <a27> <a28> <a29> <a20>
                          <a31> <a32> <a33> <a34> <a35> <a36> <a37> <a38> <a39> <a30>
                          <a41> <a42> <a43> <a44> <a45> <a46> <a47> <a48> <a49> <a40>
                          <a51> <a52> <a53> <a54> <a55> <a56> <a57> <a58> <a59> <a50>
                          <a61> <a62> <a63> <a64> <a65> <a66> <a67> <a68> <a69> <a60>
                          <a71> <a72> <a73> <a74> <a75> <a76> <a77> <a78> <a79> <a70>
                          <a81> <a82> <a83> <a84> <a85> <a86> <a87> <a88> <a89> <a80>
                          <a91> <a92> <a93> <a94> <a95> <a96> <a97> <a98> <a99> <a90>)
   (<a00> ^digit1 0 ^digit2 0 ^sum 0 ^carry-borrow 0)
   (<a01> ^digit1 0 ^digit2 1 ^sum 1 ^carry-borrow 0)
   (<a02> ^digit1 0 ^digit2 2 ^sum 2 ^carry-borrow 0)
   (<a03> ^digit1 0 ^digit2 3 ^sum 3 ^carry-borrow 0)
   (<a04> ^digit1 0 ^digit2 4 ^sum 4 ^carry-borrow 0)
   (<a05> ^digit1 0 ^digit2 5 ^sum 5 ^carry-borrow 0)
   (<a06> ^digit1 0 ^digit2 6 ^sum 6 ^carry-borrow 0)
   (<a07> ^digit1 0 ^digit2 7 ^sum 7 ^carry-borrow 0)
   (<a08> ^digit1 0 ^digit2 8 ^sum 8 ^carry-borrow 0)
   (<a09> ^digit1 0 ^digit2 9 ^sum 9 ^carry-borrow 0)
   (<a10> ^digit1 1 ^digit2 0 ^sum 1 ^carry-borrow 0)
   (<a11> ^digit1 1 ^digit2 1 ^sum 2 ^carry-borrow 0)
   (<a12> ^digit1 1 ^digit2 2 ^sum 3 ^carry-borrow 0)
   (<a13> ^digit1 1 ^digit2 3 ^sum 4 ^carry-borrow 0)
   (<a14> ^digit1 1 ^digit2 4 ^sum 5 ^carry-borrow 0)
   (<a15> ^digit1 1 ^digit2 5 ^sum 6 ^carry-borrow 0)
   (<a16> ^digit1 1 ^digit2 6 ^sum 7 ^carry-borrow 0)
   (<a17> ^digit1 1 ^digit2 7 ^sum 8 ^carry-borrow 0)
   (<a18> ^digit1 1 ^digit2 8 ^sum 9 ^carry-borrow 0)
   (<a19> ^digit1 1 ^digit2 9 ^sum 0 ^carry-borrow 1)
   (<a20> ^digit1 2 ^digit2 0 ^sum 2 ^carry-borrow 0)
   (<a21> ^digit1 2 ^digit2 1 ^sum 3 ^carry-borrow 0)
   (<a22> ^digit1 2 ^digit2 2 ^sum 4 ^carry-borrow 0)
   (<a23> ^digit1 2 ^digit2 3 ^sum 5 ^carry-borrow 0)
   (<a24> ^digit1 2 ^digit2 4 ^sum 6 ^carry-borrow 0)
   (<a25> ^digit1 2 ^digit2 5 ^sum 7 ^carry-borrow 0)
   (<a26> ^digit1 2 ^digit2 6 ^sum 8 ^carry-borrow 0)
   (<a27> ^digit1 2 ^digit2 7 ^sum 9 ^carry-borrow 0)
   (<a28> ^digit1 2 ^digit2 8 ^sum 0 ^carry-borrow 1)
   (<a29> ^digit1 2 ^digit2 9 ^sum 1 ^carry-borrow 1)
   (<a30> ^digit1 3 ^digit2 0 ^sum 3 ^carry-borrow 0)
   (<a31> ^digit1 3 ^digit2 1 ^sum 4 ^carry-borrow 0)
   (<a32> ^digit1 3 ^digit2 2 ^sum 5 ^carry-borrow 0)
   (<a33> ^digit1 3 ^digit2 3 ^sum 6 ^carry-borrow 0)
   (<a34> ^digit1 3 ^digit2 4 ^sum 7 ^carry-borrow 0)
   (<a35> ^digit1 3 ^digit2 5 ^sum 8 ^carry-borrow 0)
   (<a36> ^digit1 3 ^digit2 6 ^sum 9 ^carry-borrow 0)
   (<a37> ^digit1 3 ^digit2 7 ^sum 0 ^carry-borrow 1)
   (<a38> ^digit1 3 ^digit2 8 ^sum 1 ^carry-borrow 1)
   (<a39> ^digit1 3 ^digit2 9 ^sum 2 ^carry-borrow 1)
   (<a40> ^digit1 4 ^digit2 0 ^sum 4 ^carry-borrow 0)
   (<a41> ^digit1 4 ^digit2 1 ^sum 5 ^carry-borrow 0)
   (<a42> ^digit1 4 ^digit2 2 ^sum 6 ^carry-borrow 0)
   (<a43> ^digit1 4 ^digit2 3 ^sum 7 ^carry-borrow 0)
   (<a44> ^digit1 4 ^digit2 4 ^sum 8 ^carry-borrow 0)
   (<a45> ^digit1 4 ^digit2 5 ^sum 9 ^carry-borrow 0)
   (<a46> ^digit1 4 ^digit2 6 ^sum 0 ^carry-borrow 1)
   (<a47> ^digit1 4 ^digit2 7 ^sum 1 ^carry-borrow 1)
   (<a48> ^digit1 4 ^digit2 8 ^sum 2 ^carry-borrow 1)
   (<a49> ^digit1 4 ^digit2 9 ^sum 3 ^carry-borrow 1)
   (<a50> ^digit1 5 ^digit2 0 ^sum 5 ^carry-borrow 0)
   (<a51> ^digit1 5 ^digit2 1 ^sum 6 ^carry-borrow 0)
   (<a52> ^digit1 5 ^digit2 2 ^sum 7 ^carry-borrow 0)
   (<a53> ^digit1 5 ^digit2 3 ^sum 8 ^carry-borrow 0)
   (<a54> ^digit1 5 ^digit2 4 ^sum 9 ^carry-borrow 0)
   (<a55> ^digit1 5 ^digit2 5 ^sum 0 ^carry-borrow 1)
   (<a56> ^digit1 5 ^digit2 6 ^sum 1 ^carry-borrow 1)
   (<a57> ^digit1 5 ^digit2 7 ^sum 2 ^carry-borrow 1)
   (<a58> ^digit1 5 ^digit2 8 ^sum 3 ^carry-borrow 1)
   (<a59> ^digit1 5 ^digit2 9 ^sum 4 ^carry-borrow 1)
   (<a60> ^digit1 6 ^digit2 0 ^sum 6 ^carry-borrow 0)
   (<a61> ^digit1 6 ^digit2 1 ^sum 7 ^carry-borrow 0)
   (<a62> ^digit1 6 ^digit2 2 ^sum 8 ^carry-borrow 0)
   (<a63> ^digit1 6 ^digit2 3 ^sum 9 ^carry-borrow 0)
   (<a64> ^digit1 6 ^digit2 4 ^sum 0 ^carry-borrow 1)
   (<a65> ^digit1 6 ^digit2 5 ^sum 1 ^carry-borrow 1)
   (<a66> ^digit1 6 ^digit2 6 ^sum 2 ^carry-borrow 1)
   (<a67> ^digit1 6 ^digit2 7 ^sum 3 ^carry-borrow 1)
   (<a68> ^digit1 6 ^digit2 8 ^sum 4 ^carry-borrow 1)
   (<a69> ^digit1 6 ^digit2 9 ^sum 5 ^carry-borrow 1)
   (<a70> ^digit1 7 ^digit2 0 ^sum 7 ^carry-borrow 0)
   (<a71> ^digit1 7 ^digit2 1 ^sum 8 ^carry-borrow 0)
   (<a72> ^digit1 7 ^digit2 2 ^sum 9 ^carry-borrow 0)
   (<a73> ^digit1 7 ^digit2 3 ^sum 0 ^carry-borrow 1)
   (<a74> ^digit1 7 ^digit2 4 ^sum 1 ^carry-borrow 1)
   (<a75> ^digit1 7 ^digit2 5 ^sum 2 ^carry-borrow 1)
   (<a76> ^digit1 7 ^digit2 6 ^sum 3 ^carry-borrow 1)
   (<a77> ^digit1 7 ^digit2 7 ^sum 4 ^carry-borrow 1)
   (<a78> ^digit1 7 ^digit2 8 ^sum 5 ^carry-borrow 1)
   (<a79> ^digit1 7 ^digit2 9 ^sum 6 ^carry-borrow 1)
   (<a80> ^digit1 8 ^digit2 0 ^sum 8 ^carry-borrow 0)
   (<a81> ^digit1 8 ^digit2 1 ^sum 9 ^carry-borrow 0)
   (<a82> ^digit1 8 ^digit2 2 ^sum 0 ^carry-borrow 1)
   (<a83> ^digit1 8 ^digit2 3 ^sum 1 ^carry-borrow 1)
   (<a84> ^digit1 8 ^digit2 4 ^sum 2 ^carry-borrow 1)
   (<a85> ^digit1 8 ^digit2 5 ^sum 3 ^carry-borrow 1)
   (<a86> ^digit1 8 ^digit2 6 ^sum 4 ^carry-borrow 1)
   (<a87> ^digit1 8 ^digit2 7 ^sum 5 ^carry-borrow 1)
   (<a88> ^digit1 8 ^digit2 8 ^sum 6 ^carry-borrow 1)
   (<a89> ^digit1 8 ^digit2 9 ^sum 7 ^carry-borrow 1)
   (<a90> ^digit1 9 ^digit2 0 ^sum 9 ^carry-borrow 0)
   (<a91> ^digit1 9 ^digit2 1 ^sum 0 ^carry-borrow 1)
   (<a92> ^digit1 9 ^digit2 2 ^sum 1 ^carry-borrow 1)
   (<a93> ^digit1 9 ^digit2 3 ^sum 2 ^carry-borrow 1)
   (<a94> ^digit1 9 ^digit2 4 ^sum 3 ^carry-borrow 1)
   (<a95> ^digit1 9 ^digit2 5 ^sum 4 ^carry-borrow 1)
   (<a96> ^digit1 9 ^digit2 6 ^sum 5 ^carry-borrow 1)
   (<a97> ^digit1 9 ^digit2 7 ^sum 6 ^carry-borrow 1)
   (<a98> ^digit1 9 ^digit2 8 ^sum 7 ^carry-borrow 1)
   (<a99> ^digit1 9 ^digit2 9 ^sum 8 ^carry-borrow 1)
}
smem --add {
   (<arithmetic> ^subtraction-facts
                          <a01> <a02> <a03> <a04> <a05> <a06> <a07> <a08> <a09> <a00>
                          <a11> <a12> <a13> <a14> <a15> <a16> <a17> <a18> <a19> <a10>
                          <a21> <a22> <a23> <a24> <a25> <a26> <a27> <a28> <a29> <a20>
                          <a31> <a32> <a33> <a34> <a35> <a36> <a37> <a38> <a39> <a30>
                          <a41> <a42> <a43> <a44> <a45> <a46> <a47> <a48> <a49> <a40>
                          <a51> <a52> <a53> <a54> <a55> <a56> <a57> <a58> <a59> <a50>
                          <a61> <a62> <a63> <a64> <a65> <a66> <a67> <a68> <a69> <a60>
                          <a71> <a72> <a73> <a74> <a75> <a76> <a77> <a78> <a79> <a70>
                          <a81> <a82> <a83> <a84> <a85> <a86> <a87> <a88> <a89> <a80>
                          <a91> <a92> <a93> <a94> <a95> <a96> <a97> <a98> <a99> <a90>)
   (<a00> ^digit1 0 ^digit2 0 ^result 0)
   (<a01> ^digit1 10 ^digit2 1 ^result 9)
   (<a02> ^digit1 10 ^digit2 2 ^result 8)
   (<a03> ^digit1 10 ^digit2 3 ^result 7)
   (<a04> ^digit1 10 ^digit2 4 ^result 6)
   (<a05> ^digit1 10 ^digit2 5 ^result 5)
   (<a06> ^digit1 10 ^digit2 6 ^result 4)
   (<a07> ^digit1 10 ^digit2 7 ^result 3)
   (<a08> ^digit1 10 ^digit2 8 ^result 2)
   (<a09> ^digit1 10 ^digit2 9 ^result 1)
   (<a10> ^digit1 1 ^digit2 0 ^result 1)
   (<a11> ^digit1 1 ^digit2 1 ^result 0)
   (<a12> ^digit1 11 ^digit2 2 ^result 9)
   (<a13> ^digit1 11 ^digit2 3 ^result 8)
   (<a14> ^digit1 11 ^digit2 4 ^result 7)
   (<a15> ^digit1 11 ^digit2 5 ^result 6)
   (<a16> ^digit1 11 ^digit2 6 ^result 5)
   (<a17> ^digit1 11 ^digit2 7 ^result 4)
   (<a18> ^digit1 11 ^digit2 8 ^result 3)
   (<a19> ^digit1 11 ^digit2 9 ^result 2)
   (<a20> ^digit1 2 ^digit2 0 ^result 2)
   (<a21> ^digit1 2 ^digit2 1 ^result 1)
   (<a22> ^digit1 2 ^digit2 2 ^result 0)
   (<a23> ^digit1 12 ^digit2 3 ^result 9)
   (<a24> ^digit1 12 ^digit2 4 ^result 8)
   (<a25> ^digit1 12 ^digit2 5 ^result 7)
   (<a26> ^digit1 12 ^digit2 6 ^result 6)
   (<a27> ^digit1 12 ^digit2 7 ^result 5)
   (<a28> ^digit1 12 ^digit2 8 ^result 4)
   (<a29> ^digit1 12 ^digit2 9 ^result 3)
   (<a30> ^digit1 3 ^digit2 0 ^result 3)
   (<a31> ^digit1 3 ^digit2 1 ^result 2)
   (<a32> ^digit1 3 ^digit2 2 ^result 1)
   (<a33> ^digit1 3 ^digit2 3 ^result 0)
   (<a34> ^digit1 13 ^digit2 4 ^result 9)
   (<a35> ^digit1 13 ^digit2 5 ^result 8)
   (<a36> ^digit1 13 ^digit2 6 ^result 7)
   (<a37> ^digit1 13 ^digit2 7 ^result 6)
   (<a38> ^digit1 13 ^digit2 8 ^result 5)
   (<a39> ^digit1 13 ^digit2 9 ^result 4)
   (<a40> ^digit1 4 ^digit2 0 ^result 4)
   (<a41> ^digit1 4 ^digit2 1 ^result 3)
   (<a42> ^digit1 4 ^digit2 2 ^result 2)
   (<a43> ^digit1 4 ^digit2 3 ^result 1)
   (<a44> ^digit1 4 ^digit2 4 ^result 0)
   (<a45> ^digit1 14 ^digit2 5 ^result 9)
   (<a46> ^digit1 14 ^digit2 6 ^result 8)
   (<a47> ^digit1 14 ^digit2 7 ^result 7)
   (<a48> ^digit1 14 ^digit2 8 ^result 6)
   (<a49> ^digit1 14 ^digit2 9 ^result 5)
   (<a50> ^digit1 5 ^digit2 0 ^result 5)
   (<a51> ^digit1 5 ^digit2 1 ^result 4)
   (<a52> ^digit1 5 ^digit2 2 ^result 3)
   (<a53> ^digit1 5 ^digit2 3 ^result 2)
   (<a54> ^digit1 5 ^digit2 4 ^result 1)
   (<a55> ^digit1 5 ^digit2 5 ^result 0)
   (<a56> ^digit1 15 ^digit2 6 ^result 9)
   (<a57> ^digit1 15 ^digit2 7 ^result 8)
   (<a58> ^digit1 15 ^digit2 8 ^result 7)
   (<a59> ^digit1 15 ^digit2 9 ^result 6)
   (<a60> ^digit1 6 ^digit2 0 ^result 6)
   (<a61> ^digit1 6 ^digit2 1 ^result 5)
   (<a62> ^digit1 6 ^digit2 2 ^result 4)
   (<a63> ^digit1 6 ^digit2 3 ^result 3)
   (<a64> ^digit1 6 ^digit2 4 ^result 2)
   (<a65> ^digit1 6 ^digit2 5 ^result 1)
   (<a66> ^digit1 6 ^digit2 6 ^result 0)
   (<a67> ^digit1 16 ^digit2 7 ^result 9)
   (<a68> ^digit1 16 ^digit2 8 ^result 8)
   (<a69> ^digit1 16 ^digit2 9 ^result 7)
   (<a70> ^digit1 7 ^digit2 0 ^result 7)
   (<a71> ^digit1 7 ^digit2 1 ^result 6)
   (<a72> ^digit1 7 ^digit2 2 ^result 5)
   (<a73> ^digit1 7 ^digit2 3 ^result 4)
   (<a74> ^digit1 7 ^digit2 4 ^result 3)
   (<a75> ^digit1 7 ^digit2 5 ^result 2)
   (<a76> ^digit1 7 ^digit2 6 ^result 1)
   (<a77> ^digit1 7 ^digit2 7 ^result 0)
   (<a78> ^digit1 17 ^digit2 8 ^result 9)
   (<a79> ^digit1 17 ^digit2 9 ^result 8)
   (<a80> ^digit1 8 ^digit2 0 ^result 8)
   (<a81> ^digit1 8 ^digit2 1 ^result 7)
   (<a82> ^digit1 8 ^digit2 2 ^result 6)
   (<a83> ^digit1 8 ^digit2 3 ^result 5)
   (<a84> ^digit1 8 ^digit2 4 ^result 4)
   (<a85> ^digit1 8 ^digit2 5 ^result 3)
   (<a86> ^digit1 8 ^digit2 6 ^result 2)
   (<a87> ^digit1 8 ^digit2 7 ^result 1)
   (<a88> ^digit1 8 ^digit2 8 ^result 0)
   (<a89> ^digit1 18 ^digit2 9 ^result 9)
   (<a90> ^digit1 9 ^digit2 0 ^result 9)
   (<a91> ^digit1 9 ^digit2 1 ^result 8)
   (<a92> ^digit1 9 ^digit2 2 ^result 7)
   (<a93> ^digit1 9 ^digit2 3 ^result 6)
   (<a94> ^digit1 9 ^digit2 4 ^result 5)
   (<a95> ^digit1 9 ^digit2 5 ^result 4)
   (<a96> ^digit1 9 ^digit2 6 ^result 3)
   (<a97> ^digit1 9 ^digit2 7 ^result 2)
   (<a98> ^digit1 9 ^digit2 8 ^result 1)
   (<a99> ^digit1 9 ^digit2 9 ^result 0)
}
smem --add {
   (<arithmetic> ^add10-facts
                          <a01> <a02> <a03> <a04> <a05> <a06> <a07> <a08> <a09> <a00>)
   (<a00> ^digit1 0 ^digit-10 10)
   (<a01> ^digit1 1 ^digit-10 11)
   (<a02> ^digit1 2 ^digit-10 12)
   (<a03> ^digit1 3 ^digit-10 13)
   (<a04> ^digit1 4 ^digit-10 14)
   (<a05> ^digit1 5 ^digit-10 15)
   (<a06> ^digit1 6 ^digit-10 16)
   (<a07> ^digit1 7 ^digit-10 17)
   (<a08> ^digit1 8 ^digit-10 18)
   (<a09> ^digit1 9 ^digit-10 19)
}
smem --set learning on
sp {propose*init
   (state <s> ^superstate nil
             -^name)
-->
   (<s> ^operator <op> +)
   (<op> ^name init)
}
sp {apply*init
   (state <s> ^operator.name init
              ^smem.command <cmd>)
-->
   (<s> ^name friends)
   (<cmd> ^store <a> <b> <c>)
   (<a> ^name alice ^friend <b>)
   (<b> ^name bob ^friend <a>)
   (<c> ^name charley)
}
sp {propose*mod
   (state <s> ^name friends
              ^smem.command <cmd>)
   (<cmd> ^store <a> <b> <c>)
   (<a> ^name alice)
   (<b> ^name bob)
   (<c> ^name charley)
-->
   (<s> ^operator <op> +)
   (<op> ^name mod)
}
sp {apply*mod
   (state <s> ^operator.name mod
              ^smem.command <cmd>)
   (<cmd> ^store <a> <b> <c>)
   (<a> ^name alice)
   (<b> ^name bob)
   (<c> ^name charley)
-->
   (<a> ^name alice -)
   (<a> ^name anna
        ^friend <c>)
   (<cmd> ^store <b> -)
   (<cmd> ^store <c> -)
}
sp {propose*ncb-retrieval
   (state <s> ^name friends
              ^smem.command <cmd>)
   (<cmd> ^store <a>)
   (<a> ^name anna
        ^friend <f>)
-->
   (<s> ^operator <op> + =)
   (<op> ^name ncb-retrieval
         ^friend <f>)
}
sp {apply*ncb-retrieval*retrieve
   (state <s> ^operator <op>
              ^smem.command <cmd>)
   (<op> ^name ncb-retrieval
         ^friend <f>)
   (<cmd> ^store <a>)
-->
   (<cmd> ^store <a> -
          ^retrieve <f>)
}
sp {apply*ncb-retrieval*clean
   (state <s> ^operator <op>
              ^smem.command <cmd>)
   (<op> ^name ncb-retrieval
         ^friend <f>)
   (<f> ^<attr> <val>)
-->
   (<f> ^<attr> <val> -)
}
sp {propose*cb-retrieval
   (state <s> ^name friends
              ^smem.command <cmd>)
   (<cmd> ^retrieve)
-->
   (<s> ^operator <op> + =)
   (<op> ^name cb-retrieval)
}
sp {apply*cb-retrieval
   (state <s> ^operator <op>
              ^smem.command <cmd>)
   (<op> ^name cb-retrieval)
   (<cmd> ^retrieve <lti>)
-->
   (<cmd> ^retrieve <lti> -
          ^query <cue>)
   (<cue> ^name <any-name>
          ^friend <lti>)
}
sp {done
   (state <s> ^smem <smem>)
   (<smem> ^command.query <q>
           ^result.<status> <q>)
-->
   (halt)
}
sp {towers-of-hanoi*object*disk*elaborate*state*larger
   "If size-of(i) > size-of(j), then larger(i,j)."
   (state <s> ^name towers-of-hanoi
              ^disk <i-disk> { <> <i-disk> <j-disk> })
   (<i-disk> ^size <i-size>)
   (<j-disk> ^size <j-size> > <i-size>)
-->
   (<j-disk> ^larger <i-disk>)}
sp {towers-of-hanoi*object*disk*elaborate*state*upper-disk
   "If not(above(x,disk)), then upper-disk(disk)."
   (state <s> ^name towers-of-hanoi
              ^disk <disk>)
  -{ (<s> ^holds.above <disk>) }
-->
   (<s> ^upper-disk <disk>)}
sp {towers-of-hanoi*object*peg*elaborate*state*clear
   "If not(on(x,peg)), then clear(peg)."
   (state <s> ^name towers-of-hanoi
              ^peg <peg>)
  -{ (<s> ^holds.on <peg>) }
-->
   (<s> ^clear <peg>)}
sp {elaborations*elaborate*top-state
   (state <s> ^superstate nil)
-->
   (<s> ^top-state <s>)}
sp {elaborations*elaborate*super*top-state
   (state <ss> ^superstate.top-state <s>)
-->
   (<ss> ^top-state <s>)
}
sp {tower-of-hanoi*monitor*operator-execution*move-disk
    (state <s> ^operator <o>)
    (<o> ^name move-disk
         ^disk.size <size>
         ^to.name <to-name>)
    -->
    (write (crlf) 
           | Goal Move Disk:| <size>
           | to peg | <to-name>)}
sp {towers-of-hanoi*desired-of-disk*satisfied
   (state <s> ^holds <h1> <h2> <h3> 
                     <h4> <h5> <h6> <h7> <h8> <h9> <h10> <h11>
                     )
   (<h1> ^disk <disk-1> ^on <peg-c>)
   (<h2> ^disk <disk-2> ^on <peg-c>)
   (<h3> ^disk <disk-3> ^on <peg-c>)
   (<h4> ^disk <disk-4> ^on <peg-c>)
   (<h5> ^disk <disk-5> ^on <peg-c>)
   (<h6> ^disk <disk-6> ^on <peg-c>)
   (<h7> ^disk <disk-7> ^on <peg-c>)
   (<h8> ^disk <disk-8> ^on <peg-c>)
   (<h9> ^disk <disk-9> ^on <peg-c>)
   (<h10> ^disk <disk-10> ^on <peg-c>)
   (<h11> ^disk <disk-11> ^on <peg-c>)
   (<disk-1> ^name 1 )
   (<disk-2> ^name 2 )
   (<disk-3> ^name 3 )
   (<disk-4> ^name 4 )
   (<disk-5> ^name 5 )
   (<disk-6> ^name 6 )
   (<disk-7> ^name 7 )
   (<disk-8> ^name 8)
   (<disk-9> ^name 9)
   (<disk-10> ^name 10)
   (<disk-11> ^name 11)
   (<peg-c> ^name |C|)
-->
   (write (crlf) |Success!|)
   (halt)}
sp {tower-of-hanoi*elaborate*desired*not-statisfied
   (state <s> ^name towers-of-hanoi
              ^desired <d>
              ^top-state <ts>)
  -{(<ts> ^holds <h>)
    (<h> ^disk <m-disk>
         ^on <target-peg>)}
   (<d> ^holds <dh>)
   (<dh> ^disk <m-disk>
         ^on <target-peg>)
-->
   (<dh> ^satisfied *no*)}
sp {tower-of-hanoi*elaborate*desired*statisfied
   (state <s> ^name towers-of-hanoi
              ^desired.holds <dh>
              ^top-state.holds <h>)
   (<h> ^disk <m-disk>
        ^on <target-peg>)
   (<dh> ^disk <m-disk>
         ^on <target-peg>)
-->
   (<dh> ^satisfied *yes*)}
sp {towers-of-hanoi*propose*initialize
   (state <s> ^name towers-of-hanoi
             -^disk)
-->
   (<s> ^operator <o> +)
   (<o> ^name initialize)}
sp {towers-of-hanoi*apply*initialize
   (state <s> ^operator.name initialize)
-->
   (<s> ^disk <disk-1> <disk-2> <disk-3> <disk-4> <disk-5> <disk-6> <disk-7>
              <disk-8> <disk-9> <disk-10> <disk-11>
        ^peg <peg-a> <peg-b> <peg-c>
        ^holds <h1> <h2> <h3>
               <h4> <h5> <h6> <h7> <h8> <h9> <h10> <h11>
        ^desired <d>)
   (<h1> ^disk <disk-1> ^above <disk-2> ^on <peg-a>)
   (<h2> ^disk <disk-2> ^above <disk-3> ^on <peg-a>)
   (<h3> ^disk <disk-3> ^above <disk-4> ^on <peg-a>)
   (<h4> ^disk <disk-4> ^above <disk-5> ^on <peg-a>)
   (<h5> ^disk <disk-5> ^above <disk-6> ^on <peg-a>)
   (<h6> ^disk <disk-6> ^above <disk-7> ^on <peg-a>)
   (<h7> ^disk <disk-7> ^above <disk-8> ^on <peg-a>)
   (<h8> ^disk <disk-8> ^above <disk-9> ^on <peg-a>)
   (<h9> ^disk <disk-9> ^above <disk-10> ^on <peg-a>)
   (<h10> ^disk <disk-10> ^above <disk-11> ^on <peg-a>)
   (<h11> ^disk <disk-11> ^above none ^on <peg-a>)
   (<disk-1> ^name 1 ^size 1)
   (<disk-2> ^name 2 ^size 2)
   (<disk-3> ^name 3 ^size 3)
   (<disk-4> ^name 4 ^size 4)
   (<disk-5> ^name 5 ^size 5)
   (<disk-6> ^name 6 ^size 6)
   (<disk-7> ^name 7 ^size 7)
   (<disk-8> ^name 8 ^size 8)
   (<disk-9> ^name 9 ^size 9)
   (<disk-10> ^name 10 ^size 10)
   (<disk-11> ^name 11 ^size 11)
   (<peg-a> ^name |A|)
   (<peg-b> ^name |B|)
   (<peg-c> ^name |C|)
   (<d> ^holds <d1> <d2> <d3>
               <d4> <d5> <d6> <d7> <d8> <d9> <d10> <d11>
               )
   (<d1> ^disk <disk-1> ^above <disk-2> ^on <peg-c>)
   (<d2> ^disk <disk-2> ^above <disk-3> ^on <peg-c>)
   (<d3> ^disk <disk-3> ^above <disk-4> ^on <peg-c>)
   (<d4> ^disk <disk-4> ^above <disk-5> ^on <peg-c>)
   (<d5> ^disk <disk-5> ^above <disk-6> ^on <peg-c>)
   (<d6> ^disk <disk-6> ^above <disk-7> ^on <peg-c>)
   (<d7> ^disk <disk-7> ^above <disk-8> ^on <peg-c>)
   (<d8> ^disk <disk-8> ^above <disk-9> ^on <peg-c>)
   (<d9> ^disk <disk-9> ^above <disk-10> ^on <peg-c>)
   (<d10> ^disk <disk-10> ^above <disk-11> ^on <peg-c>)
   (<d11> ^disk <disk-11> ^above none ^on <peg-c>)
}
sp {tower-of-hanoi*propose*move-disk*mea*onpeg
    (state <s> ^desired <d>)
    (<d> ^holds <dh1>)
    (<dh1> ^disk <m-disk> 
           ^on <target-peg>
           ^satisfied *no*)
  -{(<d> ^holds <dh2>)
    (<dh2> ^disk <x-disk> 
           ^satisfied *no*)
    (<x-disk> ^larger <m-disk>)}
    -->
    (<s> ^operator <o>)
    (<o> ^name move-disk
         ^type put-on-peg
         ^disk <m-disk> 
         ^to <target-peg>)}
sp {tower-of-hanoi*propose*move-disk*mea*clear-disk
    (state <s> ^desired <d>
               ^top-state <ts>)
    (<ts> ^holds <h>
          ^peg { <> <peg1> <> <peg2> <target-peg> })
    (<h> ^disk <m-disk> 
         ^above <disk1>
         ^on <peg2>)
    (<d> ^move-disk <md>)
    (<md> ^disk <disk1>
          ^peg <peg1>)
    -->
    (<s> ^operator <o>)
    (<o> ^name move-disk
         ^type clear-disk
         ^disk <m-disk> 
         ^to <target-peg>)}
sp {tower-of-hanoi*propose*move-disk*mea*clear-smaller
    (state <s> ^desired <d>
               ^top-state <ts>)
    (<ts> ^holds <h1> <h2>
          ^peg { <> <disk1-target> <> <disk1-source> <target-peg> })
    (<h1> ^disk <m-disk>  
          ^on <disk1-target>)
    (<h2> ^disk <disk1> 
          ^on <disk1-source>)
    (<d> ^move-disk <md>)
    (<md> ^disk <disk1>
          ^peg <disk1-target>)
   (<disk1> ^larger <m-disk>)
 -{(<ts> ^holds <h3>)
   (<h3> ^disk <disk3> 
         ^on <disk1-target>)
   (<disk3> ^larger <m-disk>)
   (<disk1> ^larger <disk3>)}
    -->
    (<s> ^operator <o> +)
    (<o> ^name move-disk
         ^type clear-smaller
         ^disk <m-disk> 
         ^to <target-peg>)}
sp {tower-of-hanoi*select*maintain*operator
   (state <s> ^operator <o>)
   -->
   (<s> ^operator <o> >)}
sp {apply*move-disk*source-clear*target-clear
    (state <s> ^operator <o>
               ^top-state <ts>)
    (<o> ^name move-disk
         ^disk <m-disk> 
         ^to <target-peg>)
    (<ts> ^clear <target-peg>
          ^upper-disk <m-disk>
          ^holds <h>)
    (<h> ^disk <m-disk> 
         ^above none 
         ^on { <> <target-peg> <source-peg> })
    (<m-disk> ^name <m-disk-name>)
    (<target-peg> ^name <target-peg-name>)
    (<source-peg> ^name <source-peg-name>) 
    -->
 #   (write (crlf) |Move | <m-disk-name> | from | <source-peg-name> | to | <target-peg-name>)
    (<h> ^on <target-peg> <source-peg> - )}
sp {apply*move-disk*source-not-clear*target-clear
    (state <s> ^operator <o>
               ^top-state <ts>)
    (<ts> ^clear <target-peg> 
          ^upper-disk <m-disk>
          ^holds <h>)    
    (<o> ^name move-disk
         ^disk <m-disk> 
         ^to <target-peg>)
    (<h> ^disk <m-disk> 
         ^above { <> none <adisk> } 
         ^on { <> <target-peg> <source-peg> })
    (<m-disk> ^name <m-disk-name>)
    (<target-peg> ^name <target-peg-name>)
    (<source-peg> ^name <source-peg-name>) 
    -->
    (<h> ^above none <adisk> - 
         ^on <target-peg> <source-peg> - )}
sp {apply*move-disk*target-not-clear
    (state <s> ^operator <o>
               ^top-state <ts>)
    (<ts> ^upper-disk <o-disk>
          ^upper-disk <m-disk>
          ^holds <h> { <> <h> <i> })
    (<o> ^name move-disk
         ^disk <m-disk> 
         ^to <target-peg>)
    (<h> ^disk <m-disk> 
         ^above <adisk> 
         ^on { <> <target-peg> <source-peg> })
    (<i> ^disk <o-disk>
         ^on <target-peg>)
    (<o-disk> ^larger <m-disk>)
    (<m-disk> ^name <m-disk-name>)
    (<target-peg> ^name <target-peg-name>)
    (<source-peg> ^name <source-peg-name>) 
    -->
   # (write (crlf) |Move | <m-disk-name> | from | <source-peg-name> | to | <target-peg-name>)
    (<h> ^above <o-disk> <adisk> - 
         ^on <target-peg> <source-peg> - )}
sp {elaborate*state*desired
    (state <s> ^superstate <ss>)
    (<ss> ^operator <o>)
    (<o> ^disk <disk>
         ^to <peg>)
    -->
    (<s> ^desired.move-disk <md>)
    (<md> ^disk <disk>
          ^peg <peg>)}
sp {towers-of-hanoi*propose*initialize-recursive
   (state <s> ^superstate nil
             -^name)
-->
   (<s> ^operator <o> +)
   (<o> ^name initialize-toh-recursive)}
sp {towers-of-hanoi*apply*initialize-recursive
   (state <s> ^operator.name initialize-toh-recursive)
-->
   (<s> ^name towers-of-hanoi
        ^disk <disk-1> <disk-2> <disk-3> <disk-4> <disk-5> <disk-6> <disk-7>
              <disk-8> <disk-9> <disk-10> <disk-11>
        ^peg <peg-a> <peg-b> <peg-c>
        ^holds <h1> <h2> <h3>
               <h4> <h5> <h6> <h7> <h8> <h9> <h10> <h11>
        ^desired <d>)
   (<h1> ^disk <disk-1> ^above <disk-2> ^on <peg-a>)
   (<h2> ^disk <disk-2> ^above <disk-3> ^on <peg-a>)
   (<h3> ^disk <disk-3> ^above <disk-4> ^on <peg-a>)
   (<h4> ^disk <disk-4> ^above <disk-5> ^on <peg-a>)
   (<h5> ^disk <disk-5> ^above <disk-6> ^on <peg-a>)
   (<h6> ^disk <disk-6> ^above <disk-7> ^on <peg-a>)
   (<h7> ^disk <disk-7> ^above <disk-8> ^on <peg-a>)
   (<h8> ^disk <disk-8> ^above <disk-9> ^on <peg-a>)
   (<h9> ^disk <disk-9> ^above <disk-10> ^on <peg-a>)
   (<h10> ^disk <disk-10> ^above <disk-11> ^on <peg-a>)
   (<h11> ^disk <disk-11> ^above none ^on <peg-a>)
   (<disk-1> ^name 1 ^size 1)
   (<disk-2> ^name 2 ^size 2)
   (<disk-3> ^name 3 ^size 3)
   (<disk-4> ^name 4 ^size 4)
   (<disk-5> ^name 5 ^size 5)
   (<disk-6> ^name 6 ^size 6)
   (<disk-7> ^name 7 ^size 7)
   (<disk-8> ^name 8 ^size 8)
   (<disk-9> ^name 9 ^size 9)
   (<disk-10> ^name 10 ^size 10)
   (<disk-11> ^name 11 ^size 11)
   (<peg-a> ^name |A|)
   (<peg-b> ^name |B|)
   (<peg-c> ^name |C|)
   (<d> ^holds <d1> <d2> <d3>
               <d4> <d5> <d6> <d7> <d8> <d9> <d10> <d11>
               )
   (<d1> ^disk <disk-1> ^above <disk-2> ^on <peg-c>)
   (<d2> ^disk <disk-2> ^above <disk-3> ^on <peg-c>)
   (<d3> ^disk <disk-3> ^above <disk-4> ^on <peg-c>)
   (<d4> ^disk <disk-4> ^above <disk-5> ^on <peg-c>)
   (<d5> ^disk <disk-5> ^above <disk-6> ^on <peg-c>)
   (<d6> ^disk <disk-6> ^above <disk-7> ^on <peg-c>)
   (<d7> ^disk <disk-7> ^above <disk-8> ^on <peg-c>)
   (<d8> ^disk <disk-8> ^above <disk-9> ^on <peg-c>)
   (<d9> ^disk <disk-9> ^above <disk-10> ^on <peg-c>)
   (<d10> ^disk <disk-10> ^above <disk-11> ^on <peg-c>)
   (<d11> ^disk <disk-11> ^above none ^on <peg-c>)
}
multi-attributes disk 7
multi-attributes peg 3
multi-attributes holds 8
multi-attributes upper-disk 2
multi-attributes clear 2
learn --off
multi-attributes disk 3
multi-attributes peg 3
multi-attributes holds 4
multi-attributes upper-disk 2
multi-attributes clear 2
learn --off
sp {top-goal*elaborate*goal*tower-of-hanoi
    (state <s> ^superstate nil)
    -->
    (<s> ^name tower-of-hanoi)}
sp {tower-of-hanoi*propose*state*initial-and-desired-states
    "A 3-Disk Tower of Hanoi Problem." 
    (state <s> ^name tower-of-hanoi)
    -->
    (<s> ^disk <disk-1> <disk-2> <disk-3> <disk-4> <disk-5> <disk-6> <disk-7>
         ^peg <peg-a> <peg-b> <peg-c> 
         ^holds <h1> <h2> <h3> <h4> <h5> <h6> <h7>
         ^top-state <s>)
    (<h1> ^disk <disk-1> ^above <disk-2> ^on <peg-a>)     
    (<h2> ^disk <disk-2> ^above <disk-3> ^on <peg-a>)
    (<h3> ^disk <disk-3> ^above <disk-4> ^on <peg-a>)
    (<h4> ^disk <disk-4> ^above <disk-5> ^on <peg-a>)
    (<h5> ^disk <disk-5> ^above <disk-6> ^on <peg-a>)
    (<h6> ^disk <disk-6> ^above <disk-7> ^on <peg-a>)
    (<h7> ^disk <disk-7> ^above none ^on <peg-a>)
    (<disk-1> ^name 1 ^size 1) 
    (<disk-2> ^name 2 ^size 2)
    (<disk-3> ^name 3 ^size 3)
    (<disk-4> ^name 4 ^size 4)
    (<disk-5> ^name 5 ^size 5)
    (<disk-6> ^name 6 ^size 6)
    (<disk-7> ^name 7 ^size 7)
    (<peg-a> ^name |A|)
    (<peg-b> ^name |B|)
    (<peg-c> ^name |C|)
    (<s> ^desired <d>)
    (<d> ^holds <d1> <d2> <d3> <d4> <d5> <d6> <d7>)
    (<d1> ^disk <disk-1> ^above <disk-2> ^on <peg-c>)
    (<d2> ^disk <disk-2> ^above <disk-3> ^on <peg-c>)
    (<d3> ^disk <disk-3> ^above <disk-4> ^on <peg-c>)
    (<d4> ^disk <disk-4> ^above <disk-5> ^on <peg-c>)
    (<d5> ^disk <disk-5> ^above <disk-6> ^on <peg-c>)
    (<d6> ^disk <disk-6> ^above <disk-7> ^on <peg-c>)
    (<d7> ^disk <disk-7> ^above none ^on <peg-c>)}
sp {tower-of-hanoi*object*disk*elaborate*state*larger
    "If size-of(i) > size-of(j), then larger(i,j)."
    (state <s> ^name tower-of-hanoi
               ^disk <i-disk> { <> <i-disk> <j-disk> })
    (<i-disk> ^size <i-size>)
    (<j-disk> ^size <j-size> > <i-size>)
    -->
    (<j-disk> ^larger <i-disk>)}
sp {tower-of-hanoi*object*disk*elaborate*state*upper-disk
    "If not(above(x,disk)), then upper-disk(disk)."
    (state <s> ^name tower-of-hanoi
               ^disk <disk>)
   -{ (<s> ^holds.above <disk>) }
    -->
    (<s> ^upper-disk <disk>)}
sp {tower-of-hanoi*object*peg*elaborate*state*clear
    "If not(on(x,peg)), then clear(peg)."
    (state <s> ^name tower-of-hanoi
               ^peg <peg>)
   -{ (<s> ^holds.on <peg>) }
    -->
    (<s> ^clear <peg>)}
sp {tower-of-hanoi*propose*move-disk*mea*onpeg
    (state <s> ^desired <d>)
    (<d> ^holds <dh1>)
    (<dh1> ^disk <m-disk> 
           ^on <target-peg>
           ^satisfied *no*)
  -{(<d> ^holds <dh2>)
    (<dh2> ^disk <x-disk> 
           ^satisfied *no*)
    (<x-disk> ^larger <m-disk>)}
    -->
    (<s> ^operator <o>)
    (<o> ^name move-disk
         ^type put-on-peg
         ^disk <m-disk> 
         ^to <target-peg>)}
sp {tower-of-hanoi*propose*move-disk*mea*clear-disk
    (state <s> ^desired <d>
               ^top-state <ts>)
    (<ts> ^holds <h>
          ^peg { <> <peg1> <> <peg2> <target-peg> })
    (<h> ^disk <m-disk> 
         ^above <disk1>
         ^on <peg2>)
    (<d> ^move-disk <md>)
    (<md> ^disk <disk1>
          ^peg <peg1>)
    -->
    (<s> ^operator <o>)
    (<o> ^name move-disk
         ^type clear-disk
         ^disk <m-disk> 
         ^to <target-peg>)}
sp {tower-of-hanoi*propose*move-disk*mea*clear-smaller
    (state <s> ^desired <d>
               ^top-state <ts>)
    (<ts> ^holds <h1> <h2>
          ^peg { <> <disk1-target> <> <disk1-source> <target-peg> })
    (<h1> ^disk <m-disk>  
          ^on <disk1-target>)
    (<h2> ^disk <disk1> 
          ^on <disk1-source>)
    (<d> ^move-disk <md>)
    (<md> ^disk <disk1>
          ^peg <disk1-target>)
   (<disk1> ^larger <m-disk>)
 -{(<ts> ^holds <h3>)
   (<h3> ^disk <disk3> 
         ^on <disk1-target>)
   (<disk3> ^larger <m-disk>)
   (<disk1> ^larger <disk3>)}
    -->
    (<s> ^operator <o> +)
    (<o> ^name move-disk
         ^type clear-smaller
         ^disk <m-disk> 
         ^to <target-peg>)}
sp {tower-of-hanoi*select*maintain*operator
   (state <s> ^operator <o>)
   -->
   (<s> ^operator <o> >)}
sp {tower-of-hanoi*elaborate*desired*not-statisfied
    (state <s> ^name tower-of-hanoi
               ^desired <d>
               ^top-state <ts>)
  -{(<ts> ^holds <h>)
    (<h> ^disk <m-disk>
         ^on <target-peg>)}
    (<d> ^holds <dh>)
    (<dh> ^disk <m-disk> 
          ^on <target-peg>)
    -->
    (<dh> ^satisfied *no*)}
sp {tower-of-hanoi*elaborate*desired*statisfied
    (state <s> ^name tower-of-hanoi
               ^desired.holds <dh>
               ^top-state.holds <h>)
    (<h> ^disk <m-disk>
         ^on <target-peg>)
    (<dh> ^disk <m-disk> 
          ^on <target-peg>)
    -->
    (<dh> ^satisfied *yes*)}
sp {apply*move-disk*source-clear*target-clear
    (state <s> ^operator <o>
               ^top-state <ts>)
    (<o> ^name move-disk
         ^disk <m-disk> 
         ^to <target-peg>)
    (<ts> ^clear <target-peg>
          ^upper-disk <m-disk>
          ^holds <h>)
    (<h> ^disk <m-disk> 
         ^above none 
         ^on { <> <target-peg> <source-peg> })
    (<m-disk> ^name <m-disk-name>)
    (<target-peg> ^name <target-peg-name>)
    (<source-peg> ^name <source-peg-name>) 
    -->
    (write (crlf) |Move | <m-disk-name> | from | <source-peg-name> | to | <target-peg-name>)
    (<h> ^on <target-peg> <source-peg> - )}
sp {apply*move-disk*source-not-clear*target-clear
    (state <s> ^operator <o>
               ^top-state <ts>)
    (<ts> ^clear <target-peg> 
          ^upper-disk <m-disk>
          ^holds <h>)    
    (<o> ^name move-disk
         ^disk <m-disk> 
         ^to <target-peg>)
    (<h> ^disk <m-disk> 
         ^above { <> none <adisk> } 
         ^on { <> <target-peg> <source-peg> })
    (<m-disk> ^name <m-disk-name>)
    (<target-peg> ^name <target-peg-name>)
    (<source-peg> ^name <source-peg-name>) 
    -->
    (write (crlf) |Move | <m-disk-name> | from | <source-peg-name> | to | <target-peg-name>)
    (<h> ^above none <adisk> - 
         ^on <target-peg> <source-peg> - )}
sp {apply*move-disk*target-not-clear
    (state <s> ^operator <o>
               ^top-state <ts>)
    (<ts> ^upper-disk <o-disk>
          ^upper-disk <m-disk>
          ^holds <h> { <> <h> <i> })
    (<o> ^name move-disk
         ^disk <m-disk> 
         ^to <target-peg>)
    (<h> ^disk <m-disk> 
         ^above <adisk> 
         ^on { <> <target-peg> <source-peg> })
    (<i> ^disk <o-disk>
         ^on <target-peg>)
    (<o-disk> ^larger <m-disk>)
    (<m-disk> ^name <m-disk-name>)
    (<target-peg> ^name <target-peg-name>)
    (<source-peg> ^name <source-peg-name>) 
    -->
    (write (crlf) |Move | <m-disk-name> | from | <source-peg-name> | to | <target-peg-name>)
    (<h> ^above <o-disk> <adisk> - 
         ^on <target-peg> <source-peg> - )}
sp {tower-of-hanoi*desired-of-disk*satisfied
    (state <s> ^holds <h1> <h2> <h3> <h4> <h5> <h6> <h7>)
    (<h1> ^disk <disk-1> ^on <peg-c>)     
    (<h2> ^disk <disk-2> ^on <peg-c>)
    (<h3> ^disk <disk-3> ^on <peg-c>)
    (<h4> ^disk <disk-4> ^on <peg-c>)
    (<h5> ^disk <disk-5> ^on <peg-c>)
    (<h6> ^disk <disk-6> ^on <peg-c>)
    (<h7> ^disk <disk-7> ^on <peg-c>)
    (<disk-1> ^name 1 ) 
    (<disk-2> ^name 2 )
    (<disk-3> ^name 3 )
    (<disk-4> ^name 4 )
    (<disk-5> ^name 5 )
    (<disk-6> ^name 6 )
    (<disk-7> ^name 7 )
    (<peg-c> ^name |C|)
    -->
    (write (crlf) |Success!|)
    (halt)}
sp {elaborate*state*top-state
    (state <s> ^superstate <ss>)
    (<ss> ^top-state <ts>)
    -->
    (<s> ^top-state <ts>)}
sp {elaborate*state*desired
    (state <s> ^superstate <ss>)
    (<ss> ^operator <o>)
    (<o> ^disk <disk>
         ^to <peg>)
    -->
    (<s> ^desired.move-disk <md>)
    (<md> ^disk <disk>
          ^peg <peg>)}
sp {tower-of-hanoi*monitor*operator-execution*move-disk
    (state <s> ^operator <o>)
    (<o> ^name move-disk
         ^disk.size <size>
         ^to.name <to-name>)
    -->
    (write (crlf) 
           | Goal Move Disk:| <size>
           | to peg | <to-name>)}
multi-attributes operator 2
multi-attributes disk 7
multi-attributes peg 4
multi-attributes holds 10
multi-attributes clear 3
learn --off
sp {tower-of-hanoi*propose*state*initial-and-desired-states
    "A 3-Disk Tower of Hanoi Problem." 
    (state <s> ^superstate nil)
    -->
    (<s> ^peg a b c
         ^holds <h1> <h2> <h3> <h4> <h5> <h6> <h7> <h8> <h9> <h10> <h11>
         ^last-disk1-peg b
         ^last-disk-moved 2
         ^clear b c)
    (<h1> ^disk 1 ^above 2 ^on a)     
    (<h2> ^disk 2 ^above 3 ^on a)
    (<h3> ^disk 3 ^above 4 ^on a)
    (<h4> ^disk 4 ^above 5 ^on a)
    (<h5> ^disk 5 ^above 6 ^on a)
    (<h6> ^disk 6 ^above 7 ^on a)
    (<h7> ^disk 7 ^above 8 ^on a)
    (<h8> ^disk 8 ^above 9 ^on a)
    (<h9> ^disk 9 ^above 10 ^on a)
    (<h10> ^disk 10 ^above 11 ^on a)
    (<h11> ^disk 11 ^above none ^on a)}
sp {tower-of-hanoi*propose*move-disk1
    (state <s> ^holds <h> 
               ^peg { <> <last-peg> <> <source-peg> <target-peg> }
               ^last-disk1-peg <last-peg>
               ^last-disk-moved <> 1) 	 
    (<h> ^disk 1
         ^on <source-peg>)
    -->
    (<s> ^operator <o>)
    (<o> ^name move-disk
         ^disk 1
         ^from <source-peg> 
         ^to <target-peg>)}
sp {tower-of-hanoi*propose*move-disk*disk-to-move*onto2
    "Target peg is clear."
    (state <s> ^upper-disk <m-disk> 
               ^clear <target-peg>
               ^holds <h>
               ^last-disk-moved 1)	 
     (<h> ^disk { <m-disk> <> 1 }
          ^on <source-peg>)
    -->
    (<s> ^operator <o>)
    (<o> ^name move-disk
         ^disk <m-disk> 
         ^from <source-peg> 
         ^to <target-peg>)}
sp {tower-of-hanoi*propose*move-disk*disk-to-move*above2
    "Upper disk on the target peg is larger."
    (state <s> ^upper-disk <m-disk> { > <m-disk> <o-disk> }
               ^holds <h> { <> <h> <i> }
               ^last-disk-moved 1) 	 
    (<h> ^disk { <> 1 <m-disk> }
         ^on <source-peg>)
    (<i> ^disk { > <m-disk> <o-disk> }
         ^on <target-peg>)
    -->
    (<s> ^operator <o>)
    (<o> ^name move-disk
         ^disk <m-disk> 
         ^from <source-peg> 
         ^to <target-peg>)}
sp {apply*move-disk*source-clear*target-clear
    (state <s> ^operator <o>
               ^clear <target-peg>
               ^holds <h>)
    (<o> ^name move-disk
         ^disk <m-disk> 
         ^from <source-peg> 
         ^to <target-peg>)
    (<h> ^disk <m-disk> 
         ^above none 
         ^on <source-peg>)
    -->
    (<h> ^on <target-peg> <source-peg> -)
    (<s> ^clear <target-peg> -)}
sp {apply*move-disk*source-not-clear*target-clear
    (state <s> ^operator <o>
               ^clear <target-peg> 
               ^holds <h>)    
    (<o> ^name move-disk
         ^disk <m-disk> 
         ^from <source-peg> 
         ^to <target-peg>)
    (<h> ^disk <m-disk> 
         ^above { <> none <adisk> } 
         ^on <source-peg>)
    -->
    (<s> ^clear <target-peg> -)
    (<h> ^above none <adisk> - 
         ^on <target-peg> <source-peg> - )}
sp {apply*move-disk*target-not-clear
    (state <s> ^operator <o>
               ^upper-disk <o-disk>
               ^holds <h> { <> <h> <i> })
    (<o> ^name move-disk
         ^disk <m-disk> 
         ^from <source-peg> 
         ^to <target-peg>)
    (<h> ^disk <m-disk> 
         ^above <adisk> 
         ^on <source-peg>)
    (<i> ^disk <o-disk>
         ^on <target-peg>)
    -->
    (<s> ^upper-disk <o-disk> -)
    (<h> ^above <o-disk> <adisk> - 
         ^on <target-peg> <source-peg> - )}
sp {apply*move-disk*add-clear-source
    (state <s> ^operator <o>
               ^holds <h>)
    (<o> ^name move-disk
         ^disk <m-disk> 
         ^from <source-peg>)
    (<h> ^disk <m-disk> 
         ^above none 
         ^on <source-peg>)
    -->
    (<s> ^clear <source-peg>)}
sp {apply*move-disk*add*upper-disk*source
    (state <s> ^operator <o>
               ^holds <h>)    
    (<o> ^name move-disk
         ^disk <m-disk> 
         ^from <source-peg>)
    (<h> ^disk <m-disk> 
         ^above { <> none <adisk> } 
         ^on <source-peg>)
    -->
    (<s> ^upper-disk <adisk>)}
sp {apply*move-disk*record*last-disk-moved
    (state <s> ^operator <o>
               ^last-disk-moved { <> <m-disk> <old-disk> })
    (<o> ^name move-disk
         ^disk <m-disk>)
    -->
    (<s> ^last-disk-moved <m-disk>
         ^last-disk-moved <old-disk> -)}
sp {apply*move-disk*record*last-disk1-peg
    (state <s> ^operator <o>
               ^last-disk1-peg { <> <peg> <old-peg> })
    (<o> ^name move-disk
         ^disk 1
         ^from <peg>)
    -->
    (<s> ^last-disk1-peg <peg>
         ^last-disk1-peg <old-peg> -)}
sp {tower-of-hanoi*desired-of-disk*satisfied
    (state <s> ^holds <h1> <h2> <h3> <h4> <h5> <h6> <h7> <h8> <h9> <h10> <h11>)
    (<h1> ^disk 1 ^on c)     
    (<h2> ^disk 2 ^on c)
    (<h3> ^disk 3 ^on c)
    (<h4> ^disk 4 ^on c)
    (<h5> ^disk 5 ^on c)
    (<h6> ^disk 6 ^on c)
    (<h7> ^disk 7 ^on c)
    (<h8> ^disk 8 ^on c)
    (<h9> ^disk 9 ^on c)
    (<h10> ^disk 10 ^on c)
    (<h11> ^disk 11 ^on c)
    -->
    (write (crlf) |Success!|)
    (halt)}
sp {tower-of-hanoi*monitor*operator-execution*move-disk
    (state <s> ^operator <o>)
   (<o> ^name move-disk
         ^disk <size>
         ^to <to-name>)
    -->
    (write (crlf) 
           | Move Disk:| <size>
           | to peg | <to-name>)}
excise tower-of-hanoi*monitor*operator-execution*move-disk
multi-attributes operator 2
multi-attributes disk 7
multi-attributes peg 4
multi-attributes holds 10
multi-attributes clear 3
learn --off
sp {top-goal*elaborate*goal*tower-of-hanoi
    (state <s> ^superstate nil)
    -->
    (<s> ^name tower-of-hanoi)}
sp {tower-of-hanoi*propose*state*initial-and-desired-states
    "A 3-Disk Tower of Hanoi Problem." 
    (state <s> ^name tower-of-hanoi)
    -->
    (<s> ^disk <disk-1> <disk-2> <disk-3> <disk-4> <disk-5> <disk-6> <disk-7>
          <disk-8> <disk-9> <disk-10> <disk-11>
         ^peg <peg-a> <peg-b> <peg-c> 
         ^holds <h1> <h2> <h3> <h4> <h5> <h6> <h7> <h8> <h9> <h10> <h11>
         ^last-disk1-peg <peg-b> ;# peg-b if odd number of disks, peg-c if even
         ^last-disk-moved <disk-2>
         ^clear <peg-b> <peg-c>
         ^upper-disk <disk-1>)
    (<h1> ^disk <disk-1> ^above <disk-2> ^on <peg-a>)     
    (<h2> ^disk <disk-2> ^above <disk-3> ^on <peg-a>)
    (<h3> ^disk <disk-3> ^above <disk-4> ^on <peg-a>)
    (<h4> ^disk <disk-4> ^above <disk-5> ^on <peg-a>)
    (<h5> ^disk <disk-5> ^above <disk-6> ^on <peg-a>)
    (<h6> ^disk <disk-6> ^above <disk-7> ^on <peg-a>)
    (<h7> ^disk <disk-7> ^above <disk-8> ^on <peg-a>)
    (<h8> ^disk <disk-8> ^above <disk-9> ^on <peg-a>)
    (<h9> ^disk <disk-9> ^above <disk-10> ^on <peg-a>)
    (<h10> ^disk <disk-10> ^above <disk-11> ^on <peg-a>)
    (<h11> ^disk <disk-11> ^above none ^on <peg-a>)
    (<disk-1> ^name 1 ^size 1) 
    (<disk-2> ^name 2 ^size 2)
    (<disk-3> ^name 3 ^size 3)
    (<disk-4> ^name 4 ^size 4)
    (<disk-5> ^name 5 ^size 5)
    (<disk-6> ^name 6 ^size 6)
    (<disk-7> ^name 7 ^size 7)
    (<disk-8> ^name 8 ^size 8)
    (<disk-9> ^name 9 ^size 9)
    (<disk-10> ^name 10 ^size 10)
    (<disk-11> ^name 11 ^size 11)
    (<peg-a> ^name |A|)
    (<peg-b> ^name |B|)
    (<peg-c> ^name |C|)
    (<s> ^desired <d1> <d2> <d3> <d4> <d5> <d6> <d7> <d8> <d9> <d10> <d11>)
    (<d1> ^disk <disk-1> ^above <disk-2> ^on <peg-c>)
    (<d2> ^disk <disk-2> ^above <disk-3> ^on <peg-c>)
    (<d3> ^disk <disk-3> ^above <disk-4> ^on <peg-c>)
    (<d4> ^disk <disk-4> ^above <disk-5> ^on <peg-c>)
    (<d5> ^disk <disk-5> ^above <disk-6> ^on <peg-c>)
    (<d6> ^disk <disk-6> ^above <disk-7> ^on <peg-c>)
    (<d7> ^disk <disk-7> ^above <disk-8> ^on <peg-c>)
    (<d8> ^disk <disk-8> ^above <disk-9> ^on <peg-c>)
    (<d9> ^disk <disk-9> ^above <disk-10> ^on <peg-c>)
    (<d10> ^disk <disk-10> ^above <disk-11> ^on <peg-c>)
    (<d11> ^disk <disk-11> ^above none ^on <peg-c>)}
sp {tower-of-hanoi*object*disk*elaborate*state*larger
    "If size-of(i) > size-of(j), then larger(i,j)."
    (state <s> ^name tower-of-hanoi
               ^disk <i-disk> { <> <i-disk> <j-disk> })
    (<i-disk> ^size <i-size>)
    (<j-disk> ^size <j-size> > <i-size>)
    -->
    (<j-disk> ^larger <i-disk>)}
sp {tower-of-hanoi*propose*move-disk*disk-to-move*onto
    "Target peg is clear."
    (state <s> ^name tower-of-hanoi
               ^upper-disk <m-disk>
               ^clear { <> <last-peg> <target-peg> }
    	         ^holds <h>
               ^last-disk1-peg <last-peg>
               ^last-disk-moved.name <> 1)
     (<m-disk> ^name 1)
     (<h> ^disk <m-disk> 
          ^on <source-peg>)
    -->
    (<s> ^operator <o>)
    (<o> ^name move-disk
         ^disk <m-disk> 
         ^from <source-peg> 
         ^to <target-peg>)}
sp {tower-of-hanoi*propose*move-disk*disk-to-move*above
    "Upper disk on the target peg is larger."
    (state <s> ^name tower-of-hanoi)
    (<s> ^upper-disk <m-disk> { <> <m-disk> <o-disk> }
         ^holds <h> { <> <h> <i> }
         ^last-disk1-peg <last-peg>
         ^last-disk-moved.name <> 1) 	 
    (<h> ^disk <m-disk> 
         ^on <source-peg>)
    (<i> ^disk <o-disk> 
         ^on { <> <last-peg> <target-peg> })
    (<o-disk> ^larger <m-disk>)
    (<m-disk> ^name 1)
    -->
    (<s> ^operator <o>)
    (<o> ^name move-disk
         ^disk <m-disk> 
         ^from <source-peg> 
         ^to <target-peg>)}
sp {tower-of-hanoi*propose*move-disk*disk-to-move*onto2
    "Target peg is clear."
    (state <s> ^name tower-of-hanoi
               ^upper-disk <m-disk> 
               ^clear <target-peg>
    	         ^holds <h>
               ^last-disk-moved.name 1)	 
     (<h> ^disk <m-disk> 
         ^on <source-peg>)
    (<m-disk> ^name <> 1)
    -->
    (<s> ^operator <o>)
    (<o> ^name move-disk
         ^disk <m-disk> 
         ^from <source-peg> 
         ^to <target-peg>)}
sp {tower-of-hanoi*propose*move-disk*disk-to-move*above2
    "Upper disk on the target peg is larger."
    (state <s> ^name tower-of-hanoi)
    (<s> ^upper-disk <m-disk> { <> <m-disk> <o-disk> }
         ^holds <h> { <> <h> <i> }
         ^last-disk-moved.name 1) 	 
    (<h> ^disk <m-disk> 
         ^on <source-peg>)
    (<i> ^disk <o-disk> 
         ^on <target-peg>)
    (<o-disk> ^larger <m-disk>)
    (<m-disk> ^name <> 1)
    -->
    (<s> ^operator <o>)
    (<o> ^name move-disk
         ^disk <m-disk> 
         ^from <source-peg> 
         ^to <target-peg>)}
sp {apply*move-disk*source-clear*target-clear
    (state <s> ^operator <o>
               ^clear <target-peg>
               ^holds <h>)
    (<o> ^name move-disk
         ^disk <m-disk> 
         ^from <source-peg> 
         ^to <target-peg>)
    (<h> ^disk <m-disk> 
         ^above none 
         ^on <source-peg>)
    -->
    (<h> ^on <target-peg> <source-peg> -)
    (<s> ^clear <target-peg> -)}
sp {apply*move-disk*source-not-clear*target-clear
    (state <s> ^operator <o>
               ^clear <target-peg> 
               ^holds <h>)    
    (<o> ^name move-disk
         ^disk <m-disk> 
         ^from <source-peg> 
         ^to <target-peg>)
    (<h> ^disk <m-disk> 
         ^above { <> none <adisk> } 
         ^on <source-peg>)
    -->
    (<s> ^clear <target-peg> -)
    (<h> ^above none <adisk> - 
         ^on <target-peg> <source-peg> - )}
sp {apply*move-disk*target-not-clear
    (state <s> ^operator <o>
               ^upper-disk <o-disk>
               ^holds <h> { <> <h> <i> })
    (<o> ^name move-disk
         ^disk <m-disk> 
         ^from <source-peg> 
         ^to <target-peg>)
    (<h> ^disk <m-disk> 
         ^above <adisk> 
         ^on <source-peg>)
    (<i> ^disk <o-disk>
         ^on <target-peg>)
    -->
    (<s> ^upper-disk <o-disk> -)
    (<h> ^above <o-disk> <adisk> - 
         ^on <target-peg> <source-peg> - )}
sp {apply*move-disk*add-clear-source
    (state <s> ^operator <o>
               ^holds <h>)
    (<o> ^name move-disk
         ^disk <m-disk> 
         ^from <source-peg>)
    (<h> ^disk <m-disk> 
         ^above none 
         ^on <source-peg>)
    -->
    (<s> ^clear <source-peg>)}
sp {apply*move-disk*add*upper-disk*source
    (state <s> ^operator <o>
               ^holds <h>)    
    (<o> ^name move-disk
         ^disk <m-disk> 
         ^from <source-peg>)
    (<h> ^disk <m-disk> 
         ^above { <> none <adisk> } 
         ^on <source-peg>)
    -->
    (<s> ^upper-disk <adisk>)}
sp {apply*move-disk*record*last-disk-moved
    (state <s> ^operator <o>)
    (<o> ^name move-disk
         ^disk <m-disk>)
    -->
    (<s> ^last-disk-moved <m-disk>)}
sp {apply*move-disk*remove*last-disk-moved
    (state <s> ^operator <o>
               ^last-disk-moved <old-disk>)
    (<o> ^name move-disk
         ^disk <> <old-disk>)
    -->
    (<s> ^last-disk-moved <old-disk> -)}
sp {apply*move-disk*record*last-disk1-peg
    (state <s> ^operator <o>)
    (<o> ^name move-disk
         ^disk.name 1
         ^from <peg>)
    -->
    (<s> ^last-disk1-peg <peg>)}
sp {apply*move-disk*remove*last-disk1-peg
    (state <s> ^operator <o>
               ^last-disk1-peg <old-peg>)
    (<o> ^name move-disk
         ^disk.name 1
         ^from <> <old-peg>)
    -->
    (<s> ^last-disk1-peg <old-peg> -)}
sp {tower-of-hanoi*desired-of-disk*satisfied
    (state <s> ^holds <h1> <h2> <h3> <h4> <h5> <h6> <h7> <h8> <h9> <h10> <h11>)
    (<h1> ^disk <disk-1> ^on <peg-c>)     
    (<h2> ^disk <disk-2> ^on <peg-c>)
    (<h3> ^disk <disk-3> ^on <peg-c>)
    (<h4> ^disk <disk-4> ^on <peg-c>)
    (<h5> ^disk <disk-5> ^on <peg-c>)
    (<h6> ^disk <disk-6> ^on <peg-c>)
    (<h7> ^disk <disk-7> ^on <peg-c>)
    (<h8> ^disk <disk-8> ^on <peg-c>)
    (<h9> ^disk <disk-9> ^on <peg-c>)
    (<h10> ^disk <disk-10> ^on <peg-c>)
    (<h11> ^disk <disk-11> ^on <peg-c>)
    (<disk-1> ^name 1 ) 
    (<disk-2> ^name 2 )
    (<disk-3> ^name 3 )
    (<disk-4> ^name 4 )
    (<disk-5> ^name 5 )
    (<disk-6> ^name 6 )
    (<disk-7> ^name 7 )
    (<disk-8> ^name 8)
    (<disk-9> ^name 9)
    (<disk-10> ^name 10)
    (<disk-11> ^name 11)
    (<peg-c> ^name |C|)
    -->
    (write (crlf) |Success!|)
    (halt)}
sp {tower-of-hanoi*monitor*operator-execution*move-disk
    (state <s> ^operator <o>)
   (<o> ^name move-disk
         ^disk.size <size>
         ^to.name <to-name>)
    -->
    (write (crlf) 
           | Move Disk:| <size>
           | to peg | <to-name>)}
excise tower-of-hanoi*monitor*operator-execution*move-disk
sp {tower-of-hanoi*monitor*state*holds*above*disk
    (state <s> ^superstate nil
               ^holds <h>)
    (<h> ^disk.size <u-size> 
         ^above.size <w-size>
         ^on.name <peg-name>)
    -->
    (write (crlf) 
           |  On(| <u-size> 
           |,| <peg-name> 
           |),Above(| <w-size>
           |).|)}
sp {tower-of-hanoi*monitor*state*holds*above*none
    (state <s> ^superstate nil
               ^holds <h>)
    (<h> ^disk.size <size>
         ^above none 
         ^on.name <peg-name>)
    -->
    (write (crlf) 
           |  On(| <size> 
           |,| <peg-name> 
           |).|)}
sp {tower-of-hanoi*monitor*state*upper-disk
    (state <s> ^superstate nil
               ^upper-disk.size <size>)
    -->
    (write (crlf) 
           |  Upper-Disk(| <size> 
           |).|)}
sp {tower-of-hanoi*monitor*state*clear
    (state <s> ^superstate nil
               ^clear.name <name>)
    -->
    (write (crlf) 
           |  Clear(Peg(| <name> 
           |)).|)}
sp {tower-of-hanoi*desired-state*above*disk
    (state <s> ^desired <d> 
               ^superstate nil)
    (<d> ^disk <u-disk> ^above <w-disk> ^on <peg>)
    (<u-disk> ^size <u-size>)
    (<w-disk> ^size <w-size>)
    (<peg> ^name <peg-name>)
    -->
    (write (crlf) 
           |  Desired/On(| <u-size> 
           |,| <peg-name> 
           |),Above(| <u-size>
           |,| <w-size>
           |)/.|)}
sp {tower-of-hanoi*desired-state*above*none
    (state <s> ^desired <d> ^superstate nil)
    (<d> ^disk <disk> ^above none ^on <peg>)
    (<disk> ^size <size>)
    (<peg> ^name <peg-name>)
    -->
    (write (crlf) 
           |  Desired[On(| <size> 
           |,| <peg-name> 
           |),Above(| <size>
           |,-)].|)}
sp {tower-of-hanoi*monitor*operator-execution*move-disk
    (state <s> ^operator <o>)
    (<o> ^name move-disk
         ^disk.size <size>
         ^from.name <from-name>
         ^to.name <to-name>)
    -->
    (write (crlf) 
           |  Executing(Move-Disk(| <size>
           |,| <from-name> 
           |,| <to-name>
           |)).|)}
sp {towers-of-hanoi*object*disk*elaborate*state*larger
   "If size-of(i) > size-of(j), then larger(i,j)."
   (state <s> ^name towers-of-hanoi
              ^disk <i-disk> { <> <i-disk> <j-disk> })
   (<i-disk> ^size <i-size>)
   (<j-disk> ^size <j-size> > <i-size>)
-->
   (<j-disk> ^larger <i-disk>)}
sp {towers-of-hanoi*object*disk*elaborate*state*upper-disk
   "If not(above(x,disk)), then upper-disk(disk)."
   (state <s> ^name towers-of-hanoi
              ^disk <disk>)
  -{ (<s> ^holds.above <disk>) }
-->
   (<s> ^upper-disk <disk>)}
sp {towers-of-hanoi*object*peg*elaborate*state*clear
   "If not(on(x,peg)), then clear(peg)."
   (state <s> ^name towers-of-hanoi
              ^peg <peg>)
  -{ (<s> ^holds.on <peg>) }
-->
   (<s> ^clear <peg>)}
sp {elaborate*top-state*name
  (state <s> ^superstate nil)
-->
  (<s> ^name towers-of-hanoi)
}
sp {towers-of-hanoi*monitor*operator-execution*move-disk
    (state <s> ^operator <o>)
   (<o> ^name move-disk
         ^disk.size <size>
         ^to.name <to-name>)
    -->
    (write (crlf) 
           | Move Disk:| <size>
           | to peg | <to-name>)}
sp {towers-of-hanoi*desired-of-disk*satisfied
  (state <s> ^holds <h1> <h2> <h3> <h4> <h5> <h6> <h7> <h8> <h9> <h10> <h11>)
  (<h1> ^disk <disk-1> ^on <peg-c>)     
  (<h2> ^disk <disk-2> ^on <peg-c>)
  (<h3> ^disk <disk-3> ^on <peg-c>)
  (<h4> ^disk <disk-4> ^on <peg-c>)
  (<h5> ^disk <disk-5> ^on <peg-c>)
  (<h6> ^disk <disk-6> ^on <peg-c>)
  (<h7> ^disk <disk-7> ^on <peg-c>)
  (<h8> ^disk <disk-8> ^on <peg-c>)
  (<h9> ^disk <disk-9> ^on <peg-c>)
  (<h10> ^disk <disk-10> ^on <peg-c>)
  (<h11> ^disk <disk-11> ^on <peg-c>)
  (<disk-1> ^name 1 ) 
  (<disk-2> ^name 2 )
  (<disk-3> ^name 3 )
  (<disk-4> ^name 4 )
  (<disk-5> ^name 5 )
  (<disk-6> ^name 6 )
  (<disk-7> ^name 7 )
  (<disk-8> ^name 8)
  (<disk-9> ^name 9)
  (<disk-10> ^name 10)
  (<disk-11> ^name 11)
  (<peg-c> ^name |C|)
  -->
  (write (crlf) |Success!|)
  (halt)}
sp {towers-of-hanoi*propose*initialize
   (state <s> ^name towers-of-hanoi
             -^disk)
-->
   (<s> ^operator <o> +)
   (<o> ^name initialize)}
sp {towers-of-hanoi*apply*initialize
   (state <s> ^operator.name initialize)
-->
   (<s> ^disk <disk-1> <disk-2> <disk-3> <disk-4> <disk-5> <disk-6> <disk-7>
              <disk-8> <disk-9> <disk-10> <disk-11>
        ^peg <peg-a> <peg-b> <peg-c>
        ^holds <h1> <h2> <h3> <h4> <h5> <h6> <h7> <h8> <h9> <h10> <h11>
        ^last-disk1-peg <peg-b> ; # peg-b if odd number of disks, peg-c if even
        ^last-disk-moved <disk-2>)
   (<h1> ^disk <disk-1> ^above <disk-2> ^on <peg-a>)
   (<h2> ^disk <disk-2> ^above <disk-3> ^on <peg-a>)
   (<h3> ^disk <disk-3> ^above <disk-4> ^on <peg-a>)
   (<h4> ^disk <disk-4> ^above <disk-5> ^on <peg-a>)
   (<h5> ^disk <disk-5> ^above <disk-6> ^on <peg-a>)
   (<h6> ^disk <disk-6> ^above <disk-7> ^on <peg-a>)
   (<h7> ^disk <disk-7> ^above <disk-8> ^on <peg-a>)
   (<h8> ^disk <disk-8> ^above <disk-9> ^on <peg-a>)
   (<h9> ^disk <disk-9> ^above <disk-10> ^on <peg-a>)
   (<h10> ^disk <disk-10> ^above <disk-11> ^on <peg-a>)
   (<h11> ^disk <disk-11> ^above none ^on <peg-a>)
   (<disk-1> ^name 1 ^size 1)
   (<disk-2> ^name 2 ^size 2)
   (<disk-3> ^name 3 ^size 3)
   (<disk-4> ^name 4 ^size 4)
   (<disk-5> ^name 5 ^size 5)
   (<disk-6> ^name 6 ^size 6)
   (<disk-7> ^name 7 ^size 7)
   (<disk-8> ^name 8 ^size 8)
   (<disk-9> ^name 9 ^size 9)
   (<disk-10> ^name 10 ^size 10)
   (<disk-11> ^name 11 ^size 11)
   (<peg-a> ^name |A|)
   (<peg-b> ^name |B|)
   (<peg-c> ^name |C|)
   (<s> ^desired <d1> <d2> <d3> <d4> <d5> <d6> <d7> <d8> <d9> <d10> <d11>)
   (<d1> ^disk <disk-1> ^above <disk-2> ^on <peg-c>)
   (<d2> ^disk <disk-2> ^above <disk-3> ^on <peg-c>)
   (<d3> ^disk <disk-3> ^above <disk-4> ^on <peg-c>)
   (<d4> ^disk <disk-4> ^above <disk-5> ^on <peg-c>)
   (<d5> ^disk <disk-5> ^above <disk-6> ^on <peg-c>)
   (<d6> ^disk <disk-6> ^above <disk-7> ^on <peg-c>)
   (<d7> ^disk <disk-7> ^above <disk-8> ^on <peg-c>)
   (<d8> ^disk <disk-8> ^above <disk-9> ^on <peg-c>)
   (<d9> ^disk <disk-9> ^above <disk-10> ^on <peg-c>)
   (<d10> ^disk <disk-10> ^above <disk-11> ^on <peg-c>)
   (<d11> ^disk <disk-11> ^above none ^on <peg-c>)}
sp {towers-of-hanoi*propose*move-disk*disk-to-move*onto
   "Target peg is clear."
   (state <s> ^name towers-of-hanoi
              ^upper-disk <m-disk>
              ^clear { <> <last-peg> <target-peg> }
              ^holds <h>
              ^last-disk1-peg <last-peg>
              ^last-disk-moved.name <> 1)
   (<m-disk> ^name 1)
   (<h> ^disk <m-disk>
        ^on <source-peg>)
-->
   (<s> ^operator <o>)
   (<o> ^name move-disk
        ^disk <m-disk>
        ^from <source-peg>
        ^to <target-peg>)}
sp {towers-of-hanoi*propose*move-disk*disk-to-move*above
   "Upper disk on the target peg is larger."
   (state <s> ^name towers-of-hanoi)
   (<s> ^upper-disk <m-disk> { <> <m-disk> <o-disk> }
        ^holds <h> { <> <h> <i> }
        ^last-disk1-peg <last-peg>
        ^last-disk-moved.name <> 1)
   (<h> ^disk <m-disk>
        ^on <source-peg>)
   (<i> ^disk <o-disk>
        ^on { <> <last-peg> <target-peg> })
   (<o-disk> ^larger <m-disk>)
   (<m-disk> ^name 1)
-->
   (<s> ^operator <o>)
   (<o> ^name move-disk
        ^disk <m-disk>
        ^from <source-peg>
        ^to <target-peg>)}
sp {towers-of-hanoi*propose*move-disk*disk-to-move*onto2
   "Target peg is clear."
   (state <s> ^name towers-of-hanoi
              ^upper-disk <m-disk>
              ^clear <target-peg>
              ^holds <h>
              ^last-disk-moved.name 1)
   (<h> ^disk <m-disk>
        ^on <source-peg>)
   (<m-disk> ^name <> 1)
-->
   (<s> ^operator <o>)
   (<o> ^name move-disk
        ^disk <m-disk>
        ^from <source-peg>
        ^to <target-peg>)}
sp {towers-of-hanoi*propose*move-disk*disk-to-move*above2
   "Upper disk on the target peg is larger."
   (state <s> ^name towers-of-hanoi)
   (<s> ^upper-disk <m-disk> { <> <m-disk> <o-disk> }
        ^holds <h> { <> <h> <i> }
        ^last-disk-moved.name 1)
   (<h> ^disk <m-disk>
        ^on <source-peg>)
   (<i> ^disk <o-disk>
        ^on <target-peg>)
   (<o-disk> ^larger <m-disk>)
   (<m-disk> ^name <> 1)
-->
   (<s> ^operator <o>)
   (<o> ^name move-disk
        ^disk <m-disk>
        ^from <source-peg>
        ^to <target-peg>)}
sp {apply*move-disk*source-clear*target-clear
   (state <s> ^operator <o>
              ^clear <target-peg>
              ^holds <h>)
   (<o> ^name move-disk
        ^disk <m-disk>
        ^from <source-peg>
        ^to <target-peg>)
   (<h> ^disk <m-disk>
        ^above none
        ^on <source-peg>)
-->
   (<h> ^on <target-peg> <source-peg> - )}
sp {apply*move-disk*source-not-clear*target-clear
   (state <s> ^operator <o>
              ^clear <target-peg>
              ^holds <h>)
   (<o> ^name move-disk
        ^disk <m-disk>
        ^from <source-peg>
        ^to <target-peg>)
   (<h> ^disk <m-disk>
        ^above { <> none <adisk> }
        ^on <source-peg>)
-->
   (<h> ^above none <adisk> -
        ^on <target-peg> <source-peg> - )}
sp {apply*move-disk*target-not-clear
   (state <s> ^operator <o>
              ^upper-disk <o-disk>
              ^holds <h> { <> <h> <i> })
   (<o> ^name move-disk
        ^disk <m-disk>
        ^from <source-peg>
        ^to <target-peg>)
   (<h> ^disk <m-disk>
        ^above <adisk>
        ^on <source-peg>)
   (<i> ^disk <o-disk>
        ^on <target-peg>)
-->
   (<h> ^above <o-disk> <adisk> -
        ^on <target-peg> <source-peg> - )}
sp {apply*move-disk*record*last-disk-moved
   (state <s> ^operator <o>)
   (<o> ^name move-disk
        ^disk <m-disk>)
-->
   (<s> ^last-disk-moved <m-disk>)}
sp {apply*move-disk*remove*last-disk-moved
   (state <s> ^operator <o>
              ^last-disk-moved <old-disk>)
   (<o> ^name move-disk
        ^disk <> <old-disk>)
-->
   (<s> ^last-disk-moved <old-disk> -)}
sp {apply*move-disk*record*last-disk1-peg
   (state <s> ^operator <o>)
   (<o> ^name move-disk
        ^disk.name 1
        ^from <peg>)
-->
   (<s> ^last-disk1-peg <peg>)}
sp {apply*move-disk*remove*last-disk1-peg
   (state <s> ^operator <o>
              ^last-disk1-peg <old-peg>)
   (<o> ^name move-disk
        ^disk.name 1
        ^from <> <old-peg>)
-->
   (<s> ^last-disk1-peg <old-peg> -)}
sp {towers-of-hanoi*propose*initialize
   (state <s> ^superstate nil
             -^name)
-->
   (<s> ^operator <o> +)
   (<o> ^name initialize-toh)}
sp {towers-of-hanoi*apply*initialize-toh
   (state <s> ^operator.name initialize-toh)
-->
   (<s> ^name towers-of-hanoi
        ^disk <disk-1> <disk-2> <disk-3> <disk-4> <disk-5> <disk-6> <disk-7>
              <disk-8> <disk-9> <disk-10> <disk-11>
        ^peg <peg-a> <peg-b> <peg-c>
        ^holds <h1> <h2> <h3> <h4> <h5> <h6> <h7> <h8> <h9> <h10> <h11>
        ^last-disk1-peg <peg-b> ; # peg-b if odd number of disks, peg-c if even
        ^last-disk-moved <disk-2>)
   (<h1> ^disk <disk-1> ^above <disk-2> ^on <peg-a>)
   (<h2> ^disk <disk-2> ^above <disk-3> ^on <peg-a>)
   (<h3> ^disk <disk-3> ^above <disk-4> ^on <peg-a>)
   (<h4> ^disk <disk-4> ^above <disk-5> ^on <peg-a>)
   (<h5> ^disk <disk-5> ^above <disk-6> ^on <peg-a>)
   (<h6> ^disk <disk-6> ^above <disk-7> ^on <peg-a>)
   (<h7> ^disk <disk-7> ^above <disk-8> ^on <peg-a>)
   (<h8> ^disk <disk-8> ^above <disk-9> ^on <peg-a>)
   (<h9> ^disk <disk-9> ^above <disk-10> ^on <peg-a>)
   (<h10> ^disk <disk-10> ^above <disk-11> ^on <peg-a>)
   (<h11> ^disk <disk-11> ^above none ^on <peg-a>)
   (<disk-1> ^name 1 ^size 1)
   (<disk-2> ^name 2 ^size 2)
   (<disk-3> ^name 3 ^size 3)
   (<disk-4> ^name 4 ^size 4)
   (<disk-5> ^name 5 ^size 5)
   (<disk-6> ^name 6 ^size 6)
   (<disk-7> ^name 7 ^size 7)
   (<disk-8> ^name 8 ^size 8)
   (<disk-9> ^name 9 ^size 9)
   (<disk-10> ^name 10 ^size 10)
   (<disk-11> ^name 11 ^size 11)
   (<peg-a> ^name |A|)
   (<peg-b> ^name |B|)
   (<peg-c> ^name |C|)
   (<s> ^desired <d1> <d2> <d3> <d4> <d5> <d6> <d7> <d8> <d9> <d10> <d11>)
   (<d1> ^disk <disk-1> ^above <disk-2> ^on <peg-c>)
   (<d2> ^disk <disk-2> ^above <disk-3> ^on <peg-c>)
   (<d3> ^disk <disk-3> ^above <disk-4> ^on <peg-c>)
   (<d4> ^disk <disk-4> ^above <disk-5> ^on <peg-c>)
   (<d5> ^disk <disk-5> ^above <disk-6> ^on <peg-c>)
   (<d6> ^disk <disk-6> ^above <disk-7> ^on <peg-c>)
   (<d7> ^disk <disk-7> ^above <disk-8> ^on <peg-c>)
   (<d8> ^disk <disk-8> ^above <disk-9> ^on <peg-c>)
   (<d9> ^disk <disk-9> ^above <disk-10> ^on <peg-c>)
   (<d10> ^disk <disk-10> ^above <disk-11> ^on <peg-c>)
   (<d11> ^disk <disk-11> ^above none ^on <peg-c>)}
multi-attributes disk 7
multi-attributes peg 3
multi-attributes holds 8
multi-attributes upper-disk 2
multi-attributes clear 2
learn --off
max-elaborations 50000
multi-attributes on 3
multi-attributes peg 4
multi-attributes holds 10
multi-attributes clear 3
learn --off
sp {tower-of-hanoi*propose*state*initial-and-desired-states
    "A 3-Disk Tower of Hanoi Problem." 
    (state <s> ^superstate nil)
    -->
    (<s> ^operator <o>
         ^peg a b c
         ^holds <h1> <h2> <h3> <h4> <h5> <h6> <h7> <h8> <h9> <h10> <h11>
         ^last-disk1-peg b
         ^last-disk-moved 2
         ^clear b c)
    (<o> ^name doit)
    (<h1> ^disk 1 ^above 2 ^on a)     
    (<h2> ^disk 2 ^above 3 ^on a)
    (<h3> ^disk 3 ^above 4 ^on a)
    (<h4> ^disk 4 ^above 5 ^on a)
    (<h5> ^disk 5 ^above 6 ^on a)
    (<h6> ^disk 6 ^above 7 ^on a)
    (<h7> ^disk 7 ^above 8 ^on a)
    (<h8> ^disk 8 ^above 9 ^on a)
    (<h9> ^disk 9 ^above 10 ^on a)
    (<h10> ^disk 10 ^above 11 ^on a)
    (<h11> ^disk 11 ^above none ^on a)}
sp {tower-of-hanoi*move-disk1*source-clear*target-not-clear
    (state <s> ^operator.name doit
               ^holds <h> <h2>
               ^upper-disk <t-disk>
               ^peg { <> <last-peg> <> <source-peg> <target-peg> }
               ^last-disk1-peg <last-peg>
               ^last-disk-moved {<> 1 <ldm> }) 	 
    (<h> ^disk 1
         ^above none
         ^on <source-peg>)
    (<h2> ^disk <t-disk>
          ^on <target-peg>)
    -->
    (<h> ^on <target-peg> <source-peg> -
         ^above <t-disk> none -)
    (<s> ^clear <source-peg>
         ^upper-disk <t-disk> -
         ^last-disk1-peg <source-peg> <last-peg> -
         ^last-disk-moved 1 <ldm> -)}
sp {tower-of-hanoi*move-disk1*source-not-clear*target-clear
    (state <s> ^operator.name doit
               ^holds <h> 
               ^clear <target-peg>
               ^peg { <> <last-peg> <> <source-peg> <target-peg> }
               ^last-disk1-peg <last-peg>
               ^last-disk-moved {<> 1 <ldm> }) 	 
    (<h> ^disk 1
         ^above <t-disk>
         ^on <source-peg>)
    -->
    (<h> ^on <target-peg> <source-peg> -
         ^above <t-disk> - none)
    (<s> ^clear <target-peg> -
         ^upper-disk <t-disk>
         ^last-disk1-peg <source-peg> <last-peg> -
         ^last-disk-moved 1 <ldm> -)}
sp {tower-of-hanoi*move-disk1*source-not-clear*target-not-clear
    (state <s> ^operator.name doit
               ^holds <h> <h2>
               ^upper-disk <t-disk>
               ^peg { <> <last-peg> <> <source-peg> <target-peg> }
               ^last-disk1-peg <last-peg>
               ^last-disk-moved {<> 1 <ldm> }) 	 
    (<h> ^disk 1
         ^above { <> none <s-disk> }
         ^on <source-peg>)
    (<h2> ^disk <t-disk>
          ^on <target-peg>)
    -->
    (<h> ^on <target-peg> <source-peg> -
         ^above <t-disk> <s-disk> -)
    (<s> ^upper-disk <s-disk>
         ^upper-disk <t-disk> -
         ^last-disk1-peg <source-peg> <last-peg> -
         ^last-disk-moved 1 <ldm> -)}
sp {tower-of-hanoi*move-diskn*source-clear*target-clear
    (state <s> ^operator.name doit
               ^upper-disk <mdisk>
               ^holds <h> 
               ^clear <target-peg>
               ^last-disk-moved 1) 	 
    (<h> ^disk { <> 1 <mdisk> }
         ^above none
         ^on <source-peg>)
    -->
    (<h> ^on <target-peg> <source-peg> -)
    (<s> ^clear <source-peg> <target-peg> -
         ^last-disk-moved <mdisk> 1 -)}
sp {tower-of-hanoi*move-diskn*source-clear*target-not-clear
    (state <s> ^operator.name doit
               ^upper-disk <mdisk>
               ^holds <h> <h2>
               ^upper-disk <t-disk>
               ^last-disk-moved 1) 	 
    (<h> ^disk  { <> 1 <mdisk> }
         ^above none
         ^on <source-peg>)
    (<h2> ^disk { > <mdisk> <t-disk> }
          ^on <target-peg>)
    -->
    (<h> ^on <target-peg> <source-peg> -
         ^above <t-disk> none -)
    (<s> ^clear <source-peg>
         ^upper-disk <t-disk> -
         ^last-disk-moved <mdisk> 1 -)}
sp {tower-of-hanoi*move-diskn*source-not-clear*target-clear
    (state <s> ^operator.name doit
               ^upper-disk <mdisk>
               ^holds <h> 
               ^clear <target-peg>
               ^last-disk-moved 1) 	 
    (<h> ^disk  { <> 1 <mdisk> }
         ^above { <> none <t-disk> }
         ^on <source-peg>)
    -->
    (<h> ^on <target-peg> <source-peg> -
         ^above <t-disk> - none)
    (<s> ^clear <target-peg> -
         ^upper-disk <t-disk>
         ^last-disk-moved <mdisk> 1 -)}
sp {tower-of-hanoi*move-diskn*source-not-clear*target-not-clear
    (state <s> ^operator.name doit
               ^upper-disk <mdisk>
               ^upper-disk <t-disk>
               ^holds <h> <h2>
               ^last-disk-moved 1) 	 
    (<h> ^disk  { <> 1 <mdisk> }
         ^above { <> none <s-disk> }
         ^on <source-peg>)
    (<h2> ^disk { > <mdisk> <t-disk> }
          ^on { <> <source-peg> <target-peg> })
    -->
    (<h> ^on <target-peg> <source-peg> -
         ^above <t-disk> <s-disk> -)
    (<s> ^upper-disk <s-disk>
         ^upper-disk <t-disk> -
         ^last-disk-moved <mdisk> 1 -)}
sp {tower-of-hanoi*desired-of-disk*satisfied
    (state <s> ^holds <h1> <h2> <h3> <h4> <h5> <h6> <h7> <h8> <h9> <h10> <h11>)
    (<h1> ^disk 1 ^on c)     
    (<h2> ^disk 2 ^on c)
    (<h3> ^disk 3 ^on c)
    (<h4> ^disk 4 ^on c)
    (<h5> ^disk 5 ^on c)
    (<h6> ^disk 6 ^on c)
    (<h7> ^disk 7 ^on c)
    (<h8> ^disk 8 ^on c)
    (<h9> ^disk 9 ^on c)
    (<h10> ^disk 10 ^on c)
    (<h11> ^disk 11 ^on c)
    -->
    (write (crlf) |Success!|)
    (halt)}
sp {blocks-world*elaborate*state*clear
   (state <s> ^name blocks-world
              ^object <block>
             -^ontop.bottom-block <block>)
-->
   (<s> ^clear <block>)
}
sp {blocks-world*elaborate*state*clear-table
   (state <s> ^name blocks-world
              ^object <object>)
   (<object> ^type table)
-->
   (<s> ^clear <object>)
}
sp {elaborate*top-state*name
  (state <s> ^superstate nil)
-->
  (<s> ^name blocks-world)
}
sp {blocks-world*monitor*world-state
   (state <s> ^ontop <ontop>)
   (<ontop> ^top-block.name <top-name>
            ^bottom-block.name <bottom-name>)
-->
   (write (crlf)
          |  ontop(| <top-name>
          |,| <bottom-name> |)|)}
sp {blocks-world*monitor*operator-application*move-block
   (state <s> ^operator <o>)
   (<o> ^name move-block
        ^moving-block.name <mob-name>
        ^destination.name <dob-name>)
-->
   (write (crlf)
          |  APPLIED | <o>
          |: move-block(| <mob-name>
          |,| <dob-name>
          |)|)}
sp {blocks-world*elaborate*state*success
   (state <s> ^desired <ds>
              ^ontop <ontopa1>
                { <> <ontopa1> <ontopa2> }
                { <> <ontopa1> <> <ontopa2> <ontopa3> })
   (<ontopa1> ^top-block <blockA>
              ^bottom-block <blockB>)
   (<ontopa2> ^top-block <blockB>
              ^bottom-block <blockC>)
   (<ontopa3> ^top-block <blockC>
              ^bottom-block <table>)
   (<ds> ^ontop <ontop1>
                { <> <ontop1> <ontop2> }
                { <> <ontop1> <> <ontop2> <ontop3> })
   (<ontop1> ^top-block <blockA>
             ^bottom-block <blockB>)
   (<ontop2> ^top-block <blockB>
             ^bottom-block <blockC>)
   (<ontop3> ^top-block <blockC>
             ^bottom-block <table>)
-->
   (write (crlf) |Finished Stacking the Blocks.|)
   (halt)}
sp {blocks-world*reject*move-block*twice
   (state <s> ^name blocks-world
              ^operator <o> +
              ^last-moved-block <mb>)
   (<o> ^moving-block <mb>)
-->
   (<s> ^operator <o> < )}
sp {blocks-world*propose*initialize
   (state <s> ^name blocks-world
             -^object)
-->
   (<s> ^operator <o>)
   (<o> ^name initialize)
}
sp {blocks-world*apply*initialize
   (state <s> ^operator.name initialize)
-->
   (<s> ^ontop <ontop1> <ontop2> <ontop3>
        ^object <blockA> <blockB> <blockC> <table>
        ^desired <ds>)
   (<ontop1> ^top-block <blockA>
             ^bottom-block <blockB>)
   (<ontop2> ^top-block <blockB>
             ^bottom-block <table>)
   (<ontop3> ^top-block <blockC>
             ^bottom-block <table>)
   (<blockA> ^name A ^type block)
   (<blockB> ^name B ^type block)
   (<blockC> ^name C ^type block)
   (<table> ^name table ^type table)
   (write (crlf) |Simple Blocks World - just move blocks.|)
   (write (crlf) |Initial state has A on B, B on table, and C on the table.|)
   (<ds> ^ontop <dontop1> <dontop2> <dontop3>)
   (<dontop1> ^top-block <blockA>
              ^bottom-block <blockB>)
   (<dontop2> ^top-block <blockB>
              ^bottom-block <blockC>)
   (<dontop3> ^top-block <blockC>
              ^bottom-block <table>)
   (write (crlf) |The goal is to get A on B on C on the table.|)}
sp {blocks-world*propose*operator*move-clear-block-to-clear-object
   (state <s> ^name blocks-world)
   (<s> ^clear <blockA>
        ^clear { <> <blockA> <object> })
   (<blockA> ^type block)
  -{(<s> ^ontop <ontop>)
    (<ontop> ^top-block <blockA>
             ^bottom-block <object>)}
-->
   (<s> ^operator <o> + =)
   (<o> ^name move-block
        ^moving-block <blockA>
        ^destination <object>)}
sp {blocks-world*apply*operator*move-block*change-ontop
   (state <s> ^operator <o>
              ^ontop <ontop>)
   (<ontop> ^top-block <mblock>
            ^bottom-block { <> <tblock> <object> })
   (<o> ^moving-block <mblock>
        ^destination <tblock>)
-->
   (<ontop> ^bottom-block <tblock>
            ^bottom-block <object> -)}
sp {blocks-world*apply*operator*remember*moved-block
   (state <s1> ^operator <o1>
              -^last-moved-block <mb>)
   (<o1> ^name move-block
         ^moving-block <mb>)
-->
   (<s1> ^last-moved-block <mb>)
}
sp {blocks-world*apply*operator*forget*moved-block
   (state <s> ^operator <o>
              ^last-moved-block <mb>)
   (<o> ^name move-block
        ^moving-block <> <mb>)
-->
   (<s> ^last-moved-block <mb> -)}
sp {blocks-world*propose*initialize-blocks-world
   (state <s> ^superstate nil
             -^name)
-->
   (<s> ^operator <o>)
   (<o> ^name initialize-blocks-world)
}
sp {blocks-world*apply*initialize
   (state <s> ^operator.name initialize-blocks-world)
-->
   (<s> ^name blocks-world
        ^ontop <ontop1> <ontop2> <ontop3>
        ^object <blockA> <blockB> <blockC> <table>
        ^desired <ds>)
   (<ontop1> ^top-block <blockA>
             ^bottom-block <blockB>)
   (<ontop2> ^top-block <blockB>
             ^bottom-block <table>)
   (<ontop3> ^top-block <blockC>
             ^bottom-block <table>)
   (<blockA> ^name A ^type block)
   (<blockB> ^name B ^type block)
   (<blockC> ^name C ^type block)
   (<table> ^name table ^type table)
   (write (crlf) |Simple Blocks World - just move blocks.|)
   (write (crlf) |Initial state has A on B, B on table, and C on the table.|)
   (<ds> ^ontop <dontop1> <dontop2> <dontop3>)
   (<dontop1> ^top-block <blockA>
              ^bottom-block <blockB>)
   (<dontop2> ^top-block <blockB>
              ^bottom-block <blockC>)
   (<dontop3> ^top-block <blockC>
              ^bottom-block <table>)
   (write (crlf) |The goal is to get A on B on C on the table.|)}
multi-attributes ontop 3
multi-attributes clear 3
multi-attributes objects 4
learn --off
sp {blocks-world*elaborate*state*clear
   (state <s> ^name blocks-world
              ^object <block>
             -^ontop.bottom-block <block>)
-->
   (<s> ^clear <block>)
}
sp {blocks-world*elaborate*state*clear-table
   (state <s> ^name blocks-world
              ^object <object>)
   (<object> ^type table)
-->
   (<s> ^clear <object>)
}
sp {blocks-world*elaborate*name
   (state <s> ^superstate nil)
-->
   (<s> ^name blocks-world)
}
sp {blocks-world*monitor*world-state
   (state <s> ^ontop <ontop>)
   (<ontop> ^top-block.name <top-name>
            ^bottom-block.name <bottom-name>)
-->
   (write (crlf)
          |  ontop(| <top-name>
          |,| <bottom-name> |)|)}
sp {blocks-world*monitor*prefer*clear-block
   (state <s> ^operator <o> + 
              ^desired.clear <ub>
              ^ontop <ot>)
   (<ot> ^top-block <mb> 
         ^bottom-block <ub>)
   (<o> ^moving-block <mb>
        ^destination { <db> <> <ub> })
   (<mb> ^name <mb-name>)
   (<db> ^name <db-name>)
   (<ub> ^name <ub-name>)
   -->
   (write (crlf) |Prefer move | <mb-name> | --> | <db-name> | to clear | <ub-name>)}
sp {blocks-world*monitor*prefer*ontop
   (state <s> ^operator <o> + 
              ^desired.ontop <ot>)
   (<ot> ^top-block <mb> 
         ^bottom-block <db>)
   (<o> ^moving-block <mb>
        ^destination <db>)
   (<mb> ^name <mb-name>)
   (<db> ^name <db-name>)
   -->
   (write (crlf) |Prefer move | <mb-name> | to | <db-name>)}
sp {blocks-world*monitor*avoid*clobber*clear 
   (state <s> ^operator <o> + 
              ^desired.clear <db>)
   (<o> ^destination <db>
        ^moving-block <mb>)
   (<mb> ^name <mb-name>)
   (<db> ^name <db-name>)
   -->
   (write (crlf) |Avoid moving | <mb-name> | to | <db-name> | so don't clobber clear | <db-name> | goal.|)}
sp {blocks-world*elaborate*state*success
   (state <s> ^desired <ds>
              ^ontop <ontopa1>
                { <> <ontopa1> <ontopa2> }
                { <> <ontopa1> <> <ontopa2> <ontopa3> })
   (<ontopa1> ^top-block <blockA>
              ^bottom-block <blockB>)
   (<ontopa2> ^top-block <blockB>
              ^bottom-block <blockC>)
   (<ontopa3> ^top-block <blockC>
              ^bottom-block <table>)
   (<ds> ^ontop <ontop1>
                { <> <ontop1> <ontop2> }
                { <> <ontop1> <> <ontop2> <ontop3> })
   (<ontop1> ^top-block <blockA>
             ^bottom-block <blockB>)
   (<ontop2> ^top-block <blockB>
             ^bottom-block <blockC>)
   (<ontop3> ^top-block <blockC>
             ^bottom-block <table>)
-->
   (halt)
   (write (crlf) |Achieved Goal.|)
   }
sp {blocks-world*prefer*clear-block 
   (state <s> ^operator <o> + 
              ^desired.clear <ub>
              ^ontop <ot>)
   (<ot> ^top-block <mb> 
         ^bottom-block <ub>)
   (<o> ^moving-block <mb>
        ^destination <> <ub>)
   -->
   (<s> ^operator <o> >)}
sp {blocks-world*prefer*ontop 
   (state <s> ^operator <o> + 
              ^desired.ontop <ot>)
   (<ot> ^top-block <mb> 
         ^bottom-block <db>)
   (<o> ^moving-block <mb>
        ^destination <db>)
   -->
   (<s> ^operator <o> >)}
sp {blocks-world*avoid*clobbering*clear-block 
   (state <s> ^operator <o> + 
              ^desired.clear <ub>)
   (<o> ^destination <ub>)
   -->
   (<s> ^operator <o> <)}
sp {move-block*elaborate*operator-subgoal
   (state <s> ^impasse no-change 
              ^attribute operator 
      ^superstate.operator <so>)
   (<so> ^moving-block <mb>
         ^destination <des>)
   -->
   (<s> ^type operator-subgoal
        ^name blocks-world
        ^desired <d>)
   (<d> ^clear <mb> <des>)}
sp {move-block*elaborate*copy*superstate
   (state <s> ^type operator-subgoal 
              ^superstate <ss>)
   (<ss> ^ { <att> <> choices
                   <> impasse 
                   <> clear 
                   <> name 
                   <> quiescence
                   <> superstate 
                   <> attribute 
                   <> operator 
                   <> desired }
     <value>)
   -->
   (<s> ^<att> <value>)}
sp {blocks-world*propose*initialize
   (state <s> ^name blocks-world
             -^object)
-->
   (<s> ^operator <o>)
   (<o> ^name initialize)
}
sp {blocks-world*apply*initialize
   (state <s> ^operator.name initialize)
-->
   (<s> ^ontop <ontop1> <ontop2> <ontop3>
        ^object <blockA> <blockB> <blockC> <table>
        ^desired <ds>)
   (<ontop1> ^top-block <blockA>
             ^bottom-block <blockB>)
   (<ontop2> ^top-block <blockB>
             ^bottom-block <table>)
   (<ontop3> ^top-block <blockC>
             ^bottom-block <table>)
   (<blockA> ^name A ^type block)
   (<blockB> ^name B ^type block)
   (<blockC> ^name C ^type block)
   (<table> ^name table ^type table)
   (write (crlf) |Simple Blocks World - just move blocks.|)
   (write (crlf) |Initial state has A on B, B on table, and C on the table.|)
   (<ds> ^ontop <dontop1> <dontop2> <dontop3>)
   (<dontop1> ^top-block <blockA>
              ^bottom-block <blockB>)
   (<dontop2> ^top-block <blockB>
              ^bottom-block <blockC>)
   (<dontop3> ^top-block <blockC>
              ^bottom-block <table>)
   (write (crlf) |The goal is to get A on B on C on the table.|)}
sp {blocks-world*propose*operator
   (state <s> ^name blocks-world)
   (<s> ^object <blockA>
        ^object { <> <blockA> <object> })
   (<blockA> ^type block)
  -{(<s> ^ontop <ontop>)
    (<ontop> ^top-block <blockA>
             ^bottom-block <object>)}
-->
   (<s> ^operator <o> + =)
   (<o> ^name move-block
        ^moving-block <blockA>
        ^destination <object>)}
sp {blocks-world*apply*operator*move-block*change-ontop
   (state <s> ^operator <o>
              ^clear <mblock> <tblock>
              ^ontop <ontop>)
   (<ontop> ^top-block <mblock>
            ^bottom-block { <> <tblock> <object> })
   (<o> ^moving-block <mblock>
        ^destination <tblock>)
-->
   (<ontop> ^bottom-block <tblock>
            ^bottom-block <object> -)}
sp {blocks-world*propose*initialize-blocks-world-operator-subgoalin
   (state <s> ^superstate nil
             -^name)
-->
   (<s> ^operator <o>)
   (<o> ^name initialize-blocks-world-operator-subgoaling)
}
sp {blocks-world*apply*initialize-blocks-world-operator-subgoaling
   (state <s> ^operator.name initialize-blocks-world-operator-subgoaling)
-->
   (<s> ^name blocks-world
        ^ontop <ontop1> <ontop2> <ontop3>
        ^object <blockA> <blockB> <blockC> <table>
        ^desired <ds>)
   (<ontop1> ^top-block <blockA>
             ^bottom-block <blockB>)
   (<ontop2> ^top-block <blockB>
             ^bottom-block <table>)
   (<ontop3> ^top-block <blockC>
             ^bottom-block <table>)
   (<blockA> ^name A ^type block)
   (<blockB> ^name B ^type block)
   (<blockC> ^name C ^type block)
   (<table> ^name table ^type table)
   (write (crlf) |Simple Blocks World - just move blocks.|)
   (write (crlf) |Initial state has A on B, B on table, and C on the table.|)
   (<ds> ^ontop <dontop1> <dontop2> <dontop3>)
   (<dontop1> ^top-block <blockA>
              ^bottom-block <blockB>)
   (<dontop2> ^top-block <blockB>
              ^bottom-block <blockC>)
   (<dontop3> ^top-block <blockC>
              ^bottom-block <table>)
   (write (crlf) |The goal is to get A on B on C on the table.|)}
multi-attributes ontop 3
multi-attributes clear 3
multi-attributes objects 4
learn --off
max-elaborations 10
learn --off
sp {blocks-world*propose*initialize-blocks-world
   (state <s> ^superstate nil
             -^name)
-->
   (<s> ^operator <o>)
   (<o> ^name initialize-blocks-world)
}
sp {blocks-world*apply*initialize
   (state <s> ^operator.name initialize-blocks-world)
-->
   (<s> ^name blocks-world
        ^world-state <s>
        ^ontop <ontop1> <ontop2> <ontop3> 
        ^clear <blockA> <blockC> <table>
        ^object <blockA> <blockB> <blockC> <table>)
   (<ontop1> ^top-block <blockA> 
             ^bottom-block <blockB>)
   (<ontop2> ^top-block <blockB> 
             ^bottom-block <table>)
   (<ontop3> ^top-block <blockC> 
             ^bottom-block <table>)
   (<blockA> ^name A ^type block)
   (<blockB> ^name B ^type block)
   (<blockC> ^name C ^type block)
   (<table>  ^name table ^type table)
   (write (crlf) |Initial state has A on B and B and C on the table.|)}
sp {top-ps*propose*operator*build-tower
   (state <s> ^name blocks-world
              ^object <blockA> <blockB> <blockC> <table>)
   (<blockA> ^name A ^type block)
   (<blockB> ^name B ^type block)
   (<blockC> ^name C ^type block)
   (<table> ^name table ^type table)
 -{(<s> ^ontop <ontopa1> <ontopa2> <ontopa3>)
   (<ontopa1> ^top-block <blockA> 
              ^bottom-block <blockB>)
   (<ontopa2> ^top-block <blockB> 
              ^bottom-block <blockC>)
   (<ontopa3> ^top-block <blockC> 
              ^bottom-block <table>)}
   -->
   (<s> ^operator <o>)
   (<o> ^name build-tower 
        ^desired <ds>)
   (<ds> ^ontop <ontop1> <ontop2> <ontop3>)
   (<ontop1> ^top-block <blockA> 
             ^bottom-block <blockB>)
   (<ontop2> ^top-block <blockB> 
             ^bottom-block <blockC>)
   (<ontop3> ^top-block <blockC> 
             ^bottom-block <table>)
   (write (crlf) |The goal is to get A on B on C on the table.|)}
sp {blocks-world*propose*operator*move-block
   (state <s> ^name << move-block build-tower  >>
              ^world-state <ws>)
   (<ws> ^object <blockA> 
            { <> <blockA> <blockB> })
   (<blockA> ^type block)
 -{(<ws> ^ontop <ontop>)
   (<ontop> ^top-block <blockA>
            ^bottom-block <blockB>)}
   -->
   (<s> ^operator <o> + =)
   (<o> ^name move-block 
        ^moving-block <blockA>
        ^destination <blockB>)
    }
sp {blocks-world*copy*desired-tower
   :default
   (state <s> ^impasse no-change 
              ^attribute operator 
              ^superstate.operator.desired <d>)
   -->
   (<s> ^desired <d>)}
sp {blocks-world*copy*world-state
   :default
   (state <s> ^impasse no-change 
              ^attribute operator 
              ^superstate.world-state <ws>)
   -->
   (<s> ^world-state <ws>)}
sp {blocks-world*apply*operator*move-block*remove-ontop
   (state <s>  ^operator <o>
               ^world-state <ws>)
   (<ws> ^ontop <ontop>
         ^clear <mblock> <tblock>)
   (<ontop> ^top-block <mblock>
           -^bottom-block <tblock>)
   (<o> ^moving-block <mblock> 
        ^destination <tblock>)
   -->
   (<ws> ^ontop <ontop> -)}
sp {blocks-world*apply*operator*move-block*create-ontop
   (state <s> ^operator <o>
              ^world-state <ws>)
   (<ws> ^clear <mblock> <tblock>)
   (<o> ^moving-block <mblock>
        ^destination <tblock>)
-{(<ws> ^ontop <ontopx>)
   (<ontopx> ^top-block <mblock>
            ^bottom-block <tblock>)}
   -->
   (<ws> ^ontop <ontop>)
   (<ontop> ^top-block <mblock>
            ^bottom-block <tblock>)}
sp {blocks-world*apply*operator*move-block*remove-clear
   (state <s>  ^operator <o>
               ^world-state <ws>)
   (<ws> ^clear <mblock> <tblock>)
   (<o> ^moving-block <mblock>
        ^destination <tblock>)
   (<tblock> ^type block)
   -->
   (<ws> ^clear <tblock> -)}
sp {blocks-world*apply*operator*move-block*create-clear
   (state <s>  ^operator <o>
               ^world-state <ws>)
   (<ws> ^ontop <ontop> ^clear <mblock> <tblock>)
   (<ontop> ^top-block <mblock>
            ^bottom-block { <> <tblock> <bblock>})
   (<bblock> ^type block)
   (<o> ^moving-block <mblock>
        ^destination <tblock>)
   -->
   (<ws> ^clear <bblock>)}
sp {blocks-world*prefer*clear-block 
   (state <s> ^operator <o> + 
              ^desired.clear <ub>
              ^world-state.ontop <ot>)
   (<ot> ^top-block <mb> 
         ^bottom-block <ub>)
   (<o> ^moving-block <mb>
        ^destination <> <ub>)
   -->
   (<s> ^operator <o> >)}
sp {blocks-world*prefer*clear-block*monitor
   (state <s> ^operator <o> + 
              ^desired.clear <ub>
              ^world-state.ontop <ot>)
   (<ot> ^top-block <mb> 
         ^bottom-block <ub>)
   (<o> ^moving-block <mb>
        ^destination { <db> <> <ub> })
   (<mb> ^name <mb-name>)
   (<db> ^name <db-name>)
   (<ub> ^name <ub-name>)
   -->
   (write (crlf) |Prefer move | <mb-name> | --> | <db-name> | to clear | <ub-name>)}
sp {blocks-world*prefer*ontop 
   (state <s> ^operator <o> + 
              ^desired.ontop <ot>
              ^world-state <ws>)
   (<ot> ^top-block <mb> 
         ^bottom-block <db>)
   (<o> ^moving-block <mb>
        ^destination <db>)
   -->
   (<s> ^operator <o> >)}
sp {blocks-world*prefer*ontop*monitor 
   (state <s> ^operator <o> + 
              ^desired.ontop <ot>
              ^world-state <ws>)
   (<ot> ^top-block <mb> 
         ^bottom-block <db>)
   (<o> ^moving-block <mb>
        ^destination <db>)
   (<mb> ^name <mb-name>)
   (<db> ^name <db-name>)
   -->
   (write (crlf) |Prefer move | <mb-name> | to | <db-name>)}
sp {top-ps*monitor*goal
   (state <s> ^ontop <ontopa1> <ontopa2> <ontopa3>)
   (<blockA> ^name A ^type block)
   (<blockB> ^name B ^type block)
   (<blockC> ^name C ^type block)
   (<table> ^name table ^type table)
   (<ontopa1> ^top-block <blockA> 
              ^bottom-block <blockB>)
   (<ontopa2> ^top-block <blockB> 
              ^bottom-block <blockC>)
   (<ontopa3> ^top-block <blockC> 
              ^bottom-block <table>)
  -->
  (write (crlf) |*** ACHIEVED GOAL ***|)
  (<s> ^success *yes*)
  (halt)}
sp {blocks-world*monitor*world-state
   (state <s> ^world-state <s>
              ^ontop <ontop>)
   (<ontop> ^top-block.name <top-name>
            ^bottom-block.name <bottom-name>)
   -->
   (write (crlf)|  ontop(| <top-name> |,| <bottom-name> |)|)}
sp {blocks-world*monitor*operator-application*move-block
   (state <s> ^operator <o>)
   (<o> ^name move-block
        ^moving-block <mob>
   	  ^destination <dob>)
   (<mob> ^name <mob-name>)
   (<dob> ^name <dob-name>)
   -->
   (write (crlf) |SELECT | <o> |: move-block(| <mob-name> |,| <dob-name> |)|)}
sp {default*opsub*propose*space*name
   :default
   (state <s> ^impasse no-change 
              ^attribute operator 
	        ^superstate.operator <so>)
   (<so> ^moving-block <mb>
         ^destination <des>)
   -->
   (<s> ^problem-space <sp>
        ^name operator-subgoal
        ^desired <d>)
   (<d> ^clear <mb> <des>)}
sp {default*generic*opsub*copy*superstate
   :default
   (state <s> ^name operator-subgoal 
              ^superstate <ss>)
   (<ss> ^ { <att> <> problem-space 
                   <> choices
                   <> impasse 
                   <> object 
                   <> name 
                   <> quiescence
                   <> superstate 
                   <> attribute 
                   <> operator 
                   <> desired }
	   <value>)
   -->
   (<s> ^<att> <value>)}
sp {blocks-world*elaborate*state*clear
   (state <s> ^name blocks-world
              ^object <block>
             -^ontop.bottom-block <block>)
-->
   (<s> ^clear <block>)
}
sp {blocks-world*elaborate*state*clear-table
   (state <s> ^name blocks-world
              ^object <object>)
   (<object> ^type table)
-->
   (<s> ^clear <object>)
}
sp {blocks-world*elaborate*problem-space
   (state <s> ^name blocks-world)
-->
   (<s> ^problem-space <p>)
   (<p> ^name move-blocks
        ^default-state-copy yes
        ^two-level-attributes ontop
        ^one-level-attributes object)}
sp {blocks-world*monitor*world-state
   (state <s> ^ontop <ontop>)
   (<ontop> ^top-block.name <top-name>
            ^bottom-block.name <bottom-name>)
-->
   (write (crlf)
          |  ontop(| <top-name>
          |,| <bottom-name> |)|)}
sp {blocks-world*monitor*operator-application*move-block
   (state <s> ^operator <o>)
   (<o> ^name move-block
        ^moving-block.name <mob-name>
        ^destination.name <dob-name>)
-->
   (write (crlf)
          |  APPLIED | <o>
          |: move-block(| <mob-name>
          |,| <dob-name>
          |)|)}
sp {blocks-world*elaborate*state*success
   (state <s> ^desired <ds>
              ^ontop <ontopa1>
                { <> <ontopa1> <ontopa2> }
                { <> <ontopa1> <> <ontopa2> <ontopa3> })
   (<ontopa1> ^top-block <blockA>
              ^bottom-block <blockB>)
   (<ontopa2> ^top-block <blockB>
              ^bottom-block <blockC>)
   (<ontopa3> ^top-block <blockC>
              ^bottom-block <table>)
   (<ds> ^ontop <ontop1>
                { <> <ontop1> <ontop2> }
                { <> <ontop1> <> <ontop2> <ontop3> })
   (<ontop1> ^top-block <blockA>
             ^bottom-block <blockB>)
   (<ontop2> ^top-block <blockB>
             ^bottom-block <blockC>)
   (<ontop3> ^top-block <blockC>
             ^bottom-block <table>)
-->
   (<s> ^success <ds>)}
sp {blocks-world*reject*move-block*twice
   (state <s> ^name blocks-world
              ^operator <o> +
              ^last-moved-block <mb>)
   (<o> ^moving-block <mb>)
-->
   (<s> ^operator <o> -)}
sp {blocks-world*propose*initialize
   (state <s> ^name blocks-world
             -^object)
-->
   (<s> ^operator <o>)
   (<o> ^name initialize)
}
sp {blocks-world*apply*initialize
   (state <s> ^operator.name initialize)
-->
   (<s> ^ontop <ontop1> <ontop2> <ontop3>
        ^object <blockA> <blockB> <blockC> <table>
        ^desired <ds>)
   (<ontop1> ^top-block <blockA>
             ^bottom-block <blockB>)
   (<ontop2> ^top-block <blockB>
             ^bottom-block <table>)
   (<ontop3> ^top-block <blockC>
             ^bottom-block <table>)
   (<blockA> ^name A ^type block)
   (<blockB> ^name B ^type block)
   (<blockC> ^name C ^type block)
   (<table> ^name table ^type table)
   (write (crlf) |Simple Blocks World - just move blocks.|)
   (write (crlf) |Initial state has A on B, B on table, and C on the table.|)
   (<ds> ^ontop <dontop1> <dontop2> <dontop3>)
   (<dontop1> ^top-block <blockA>
              ^bottom-block <blockB>)
   (<dontop2> ^top-block <blockB>
              ^bottom-block <blockC>)
   (<dontop3> ^top-block <blockC>
              ^bottom-block <table>)
   (write (crlf) |The goal is to get A on B on C on the table.|)}
sp {blocks-world*propose*operator*move-clear-block-to-clear-object
   (state <s> ^name blocks-world)
   (<s> ^clear <blockA>
        ^clear { <> <blockA> <object> })
   (<blockA> ^type block)
  -{(<s> ^ontop <ontop>)
    (<ontop> ^top-block <blockA>
             ^bottom-block <object>)}
-->
   (<s> ^operator <o> +)
   (<o> ^name move-block
        ^moving-block <blockA>
        ^destination <object>)}
sp {blocks-world*apply*operator*move-block*change-ontop
   (state <s> ^operator <o>
              ^ontop <ontop>)
   (<ontop> ^top-block <mblock>
            ^bottom-block { <> <tblock> <object> })
   (<o> ^moving-block <mblock>
        ^destination <tblock>)
-->
   (<ontop> ^bottom-block <tblock>
            ^bottom-block <object> -)}
sp {blocks-world*apply*operator*remember*moved-block
   (state <s1> ^operator <o1>
              -^last-moved-block <mb>)
   (<o1> ^name move-block
         ^moving-block <mb>)
-->
   (<s1> ^last-moved-block <mb>)
}
sp {blocks-world*apply*operator*forget*moved-block
   (state <s> ^operator <o>
              ^last-moved-block <mb>)
   (<o> ^name move-block
        ^moving-block <> <mb>)
-->
   (<s> ^last-moved-block <mb> -)}
sp {blocks-world*propose*initialize-blocks-world-look-ahead
   (state <s> ^superstate nil
             -^name)
-->
   (<s> ^operator <o>)
   (<o> ^name initialize-blocks-world-look-ahead)}
sp {blocks-world*apply*initialize
   (state <s> ^operator.name initialize-blocks-world-look-ahead)
-->
   (<s> ^name blocks-world
        ^ontop <ontop1> <ontop2> <ontop3>
        ^object <blockA> <blockB> <blockC> <table>
        ^desired <ds>)
   (<ontop1> ^top-block <blockA>
             ^bottom-block <blockB>)
   (<ontop2> ^top-block <blockB>
             ^bottom-block <table>)
   (<ontop3> ^top-block <blockC>
             ^bottom-block <table>)
   (<blockA> ^name A ^type block)
   (<blockB> ^name B ^type block)
   (<blockC> ^name C ^type block)
   (<table> ^name table ^type table)
   (write (crlf) |Simple Blocks World - just move blocks.|)
   (write (crlf) |Initial state has A on B, B on table, and C on the table.|)
   (<ds> ^ontop <dontop1> <dontop2> <dontop3>)
   (<dontop1> ^top-block <blockA>
              ^bottom-block <blockB>)
   (<dontop2> ^top-block <blockB>
              ^bottom-block <blockC>)
   (<dontop3> ^top-block <blockC>
              ^bottom-block <table>)
   (write (crlf) |The goal is to get A on B on C on the table.|)}
multi-attributes ontop 3
multi-attributes clear 3
multi-attributes objects 4
learn --on
epmem --set trigger dc
epmem --set learning on
watch --epmem
sp {propose*init
   (state <s> ^superstate nil
             -^name)
-->
   (<s> ^operator <op> + =)
   (<op> ^name init)
}
sp {apply*init
   (state <s> ^operator <op>)
   (<op> ^name init)
-->
   (<s> ^name epmem
        ^feature2 value
        ^feature value3
        ^id <e2>
        ^id <e3>
        ^other-id <e4>)
   (<e2> ^sub-feature value2)
   (<e3> ^sub-id <e5>)
   (<e4> ^sub-id <e6>
         ^sub-feature value2)
}
sp {epmem*propose*cbr
   (state <s> ^name epmem
             -^epmem.command.<cmd>)
-->
   (<s> ^operator <op> + =)
   (<op> ^name cbr)
}
sp {epmem*apply*cbr-clean
   (state <s> ^operator <op>
              ^feature2 <f2>
              ^feature <f>
              ^id <e2>
              ^id <e3>
              ^other-id <e4>)
   (<e2> ^sub-feature value2)
   (<e3> ^sub-id)
   (<op> ^name cbr)
-->
   (<s> ^feature2 <f2> -
        ^feature <f> -
        ^id <e2> -
        ^id <e3> -
        ^other-id <e4> -)
}
sp {epmem*apply*cbr-query
   (state <s> ^operator <op>
              ^epmem.command <cmd>)
   (<op> ^name cbr)
-->
   (<cmd> ^query <n1>)
   (<n1> ^feature value
        ^id <n2>)
   (<n2> ^sub-feature value2
         ^sub-id <n3>)
}
sp {epmem*propose*next
   (state <s> ^name epmem
              ^epmem.command.query)
-->
   (<s> ^operator <op> + =)
   (<op> ^name next)
}
sp {epmem*apply*next
   (state <s> ^operator <op>
              ^epmem.command <cmd>)
   (<op> ^name next)
   (<cmd> ^query <q>)
-->
   (<cmd> ^query <q> -
          ^next <next>)
}
sp {epmem*done
   (state <s> ^name epmem
              ^epmem <epmem>)
   (<epmem> ^command.next <next>
            ^result.success <next>)
-->
   (halt)
}
sp {water-jug*elaborate*empty
   (state <s> ^name water-jug
              ^jug <j>)
   (<j> ^contents <c>
        ^volume <v>)
-->
   (<j> ^empty (- <v> <c>))}
sp {water-jug*monitor*state
   (state <s> ^name water-jug
              ^jug <j> <i>)
   (<j> ^volume 5 ^contents <jcon>)
   (<i> ^volume 3 ^contents <icon>)
-->
   (write (crlf) | 5:| <jcon> | 3:| <icon> )}
sp {water-jug*monitor*operator-application*empty
   (state <s> ^name water-jug
              ^operator <o>)
   (<o> ^name empty
        ^jug.volume <volume>)
-->
   (write (crlf) |  EMPTY(| <volume> |)|)}
sp {water-jug*monitor*operator-application*fill
   (state <s> ^name water-jug
              ^operator <o>)
   (<o> ^name fill
        ^jug.volume <volume>)
-->
   (write (crlf) |  FILL(| <volume> |)|)}
sp {water-jug*monitor*operator-application*pour
   (state <s> ^name water-jug
              ^operator <o>)
   (<o> ^name pour
        ^jug <i>
        ^into <j>)
   (<i> ^volume <ivol> ^contents <icon>)
   (<j> ^volume <jvol> ^contents <jcon>)
-->
   (write (crlf) |  POUR(| <ivol> |:| <icon> |,| <jvol> |:| <jcon> |)|)}
sp {water-jug*evaluate*state*success
   (state <s> ^desired <d>
              ^name water-jug
              ^jug <j>)
   (<d> ^jug <dj>)
   (<dj> ^volume <v> ^contents <c>)
   (<j> ^volume <v> ^contents <c>)
-->
   (<s> ^success <d>)}
sp {water-jug*elaborate*problem-space
   (state <s> ^name water-jug)
-->
   (<s> ^problem-space <p>)
   (<p> ^name water-jug
        ^default-state-copy yes
        ^two-level-attributes jug
        ^dont-copy empty)} 
sp {water-jug*propose*pour
   (state <s> ^name water-jug
              ^jug <i> { <> <i> <j> })
   (<i> ^contents > 0 )
   (<j> ^empty > 0)
-->
   (<s> ^operator <o> +)
   (<o> ^name pour
        ^jug <i>
        ^into <j>)}
sp {water-jug*apply*pour*not-empty-source
   (state <s> ^name water-jug
              ^operator <o>)
   (<o> ^name pour
        ^jug <i>
        ^into <j>)
   (<j> ^volume <jvol>
        ^contents <jcon>
        ^empty <jempty>)
   (<i> ^volume <ivol>
        ^contents { <icon> <= <jempty> })
-->
   (<i> ^contents 0 <icon> -)
   (<j> ^contents (+ <jcon> <icon>) <jcon> - )}
sp {water-jug*apply*pour*empty-source
   (state <s> ^name water-jug
              ^operator <o>)
   (<o> ^name pour
        ^jug <i>
        ^into <j>)
   (<i> ^volume <ivol>
        ^contents { <icon> > <jempty> })
   (<j> ^volume <jvol>
        ^contents <jcon>
        ^empty <jempty>)
-->
   (<i> ^contents (- <icon> <jempty>) <icon> - )
   (<j> ^contents <jvol> <jcon> -)}
sp {water-jug*propose*empty
   (state <s> ^name water-jug
              ^jug <j>)
   (<j> ^contents > 0)
-->
   (<s> ^operator <o> +)
   (<o> ^name empty
        ^jug <j>)}
sp {water-jug*apply*empty
   (state <s> ^name water-jug
              ^operator <o>
              ^jug <j>)
   (<o> ^name empty
        ^jug <j>)
   (<j> ^volume <volume>
        ^contents <contents>)
-->
   (<j> ^contents 0 <contents> - )}
sp {water-jug*propose*fill
   (state <s> ^name water-jug
              ^jug <j>)
   (<j> ^empty > 0)
-->
   (<s> ^operator <o> +)
   (<o> ^name fill
        ^jug <j>)}
sp {water-jug*apply*fill
   (state <s> ^name water-jug
              ^operator <o>
              ^jug <j>)
   (<o> ^name fill
        ^jug <j>)
   (<j> ^volume <volume>
        ^contents <contents>)
-->
   (<j> ^contents <volume>
                  <contents> -)}
sp {water-jug*propose*initialize-water-jug-look-ahead
   (state <s> ^superstate nil
             -^name)
-->
   (<s> ^operator <o> +)
   (<o> ^name initialize-water-jug-look-ahead)}
sp {water-jug*apply*initialize-water-jug-look-ahead
   (state <s> ^operator.name initialize-water-jug-look-ahead)
-->
   (<s> ^name water-jug
        ^jug <i> <j>
        ^desired.jug <k>)
   (<i> ^volume 3
        ^contents 0)
   (<j> ^volume 5
        ^contents 0)
   (<k> ^volume 3
        ^contents 1)}
sp {water-jug*monitor*tied-operator*empty
   (state <s> ^impasse tie
              ^attribute operator
              ^item <item>)
   (<item> ^name empty
           ^jug.volume <volume>)
-->
   (write (crlf) |  | <item> |: empty(| <volume> |)|)}
sp {water-jug*monitor*tied-operator*fill
   (state <s> ^impasse tie
              ^attribute operator
              ^item <item>)
   (<item> ^name fill
           ^jug.volume <volume>)
-->
   (write (crlf) |  | <item> |: fill(| <volume> |)|)}
sp {water-jug*monitor*tied-operator*pour
   (state <s> ^impasse tie
              ^attribute operator
              ^item <item>)
   (<item> ^name pour
           ^jug <i> ^into <j>)
   (<i> ^volume <ivol> ^contents <icon>)
   (<j> ^volume <jvol> ^contents <jcon>)
-->
   (write (crlf) |  | <item> |: pour(| <ivol> |:| <icon> |,| <jvol> |:| <jcon> |)|)}
sp {Impasse__Operator_Tie*elaborate*superstate-set
   (state <s> ^superstate <ss>)
-->
   (<s> ^superstate-set <ss>)
}
sp {Impasse__Operator_Tie*elaborate*superstate-set2
   (state <s> ^superstate.superstate-set <ss>)
-->
   (<s> ^superstate-set <ss>)
}
sp {water-jug*evaluate*state*failure*duplicate
   (state <s2> ^name water-jug
               ^superstate-set <s1>
               ^jug <i1>
               ^jug <i2>
               ^tried-tied-operator)
   (<i1> ^volume 5 ^contents <c1>)
   (<i2> ^volume 3 ^contents <c2>)
   (<s1> ^name water-jug
               ^desired <d>
               ^jug <j1>
               ^jug <j2>)
   (<j1> ^volume 5 ^contents <c1>)
   (<j2> ^volume 3 ^contents <c2>)
-->
   (<s2> ^failure <d>)}
multi-attributes jug 3
echo "learning is on"
learn --on
sp {water-jug*elaborate*empty
   (state <s> ^name water-jug
              ^jug <j>)
   (<j> ^contents <c>
        ^volume <v>)
-->
   (<j> ^empty (- <v> <c>))}
sp {water-jug*monitor*state 
   (state <s> ^name water-jug
              ^jug <j> <i>)
   (<j> ^volume 5 ^contents <jcon>)
   (<i> ^volume 3 ^contents <icon>)
   --> 
   (write (crlf) | 5:| <jcon> | 3:| <icon> )}
sp {water-jug*monitor*operator-application*empty
   (state <s> ^name water-jug
              ^operator <o>)
   (<o> ^name empty
        ^empty-jug.volume <volume>)
   -->
   (write (crlf) |  EMPTY(| <volume> |)|)}
sp {water-jug*monitor*operator-application*fill
   (state <s> ^name water-jug
              ^operator <o>)
   (<o> ^name fill 
        ^fill-jug.volume <volume>)
   -->
   (write (crlf) |  FILL(| <volume> |)|)}
sp {water-jug*monitor*operator-application*pour
   (state <s> ^name water-jug
              ^operator <o>)
   (<o> ^name pour 
        ^empty-jug <i>
        ^fill-jug <j>)
   (<i> ^volume <ivol> ^contents <icon>)
   (<j> ^volume <jvol> ^contents <jcon>)
   -->
   (write (crlf) |  POUR(| <ivol> |:| <icon> |,| <jvol> |:| <jcon> |)|)}
sp {water-jug*detect*goal*achieved
   (state <s> ^name water-jug
              ^jug <j>)
   (<j> ^volume 3 ^contents 1)
-->
   (write (crlf) |The problem has been solved.|)
   (halt)}
sp {water-jug*propose*pour
   (state <s> ^name water-jug
              ^jug <i> { <> <i> <j> })
   (<i> ^contents > 0 )
   (<j> ^empty > 0)
-->
   (<s> ^operator <o> + =)
   (<o> ^name pour
        ^empty-jug <i>
        ^fill-jug <j>)}
sp {water-jug*apply*pour*not-empty-source
   (state <s> ^name water-jug
              ^operator <o>)
   (<o> ^name pour
        ^empty-jug <i>
        ^fill-jug <j>)
   (<j> ^volume <jvol>
        ^contents <jcon>
        ^empty <jempty>)
   (<i> ^volume <ivol>
        ^contents { <icon> <= <jempty> })
-->
   (<i> ^contents 0 <icon> -)
   (<j> ^contents (+ <jcon> <icon>) <jcon> - )}
sp {water-jug*apply*pour*empty-source
   (state <s> ^name water-jug
              ^operator <o>)
   (<o> ^name pour
        ^empty-jug <i>
        ^fill-jug <j>)
   (<i> ^volume <ivol>
        ^contents { <icon> > <jempty> })
   (<j> ^volume <jvol>
        ^contents <jcon>
        ^empty <jempty>)
-->
   (<i> ^contents (- <icon> <jempty>) <icon> - )
   (<j> ^contents <jvol> <jcon> -)}
sp {water-jug*propose*empty
   (state <s> ^name water-jug
              ^jug <j>)
   (<j> ^contents > 0)
-->
   (<s> ^operator <o> + =)
   (<o> ^name empty
        ^empty-jug <j>)}
sp {water-jug*apply*empty
   (state <s> ^name water-jug
              ^operator <o>
              ^jug <j>)
   (<o> ^name empty
        ^empty-jug <j>)
   (<j> ^volume <volume>
        ^contents <contents>)
-->
   (<j> ^contents 0
        ^contents <contents> - )}
sp {water-jug*propose*fill
   (state <s> ^name water-jug
              ^jug <j>)
   (<j> ^empty > 0)
-->
   (<s> ^operator <o> + =)
   (<o> ^name fill
        ^fill-jug <j>)}
sp {water-jug*apply*fill
   (state <s> ^name water-jug
              ^operator <o>
              ^jug <j>)
   (<o> ^name fill
        ^fill-jug <j>)
   (<j> ^volume <volume>
        ^contents <contents>)
-->
   (<j> ^contents <volume>
                  <contents> -)}
sp {water-jug*propose*initialize-water-jug
   (state <s> ^superstate nil
             -^name)
-->
   (<s> ^operator <o> +)
   (<o> ^name initialize-water-jug)}
sp {water-jug*apply*initialize-water-jug
   (state <s> ^operator.name initialize-water-jug)
-->
   (<s> ^name water-jug
        ^jug <i> <j>)
   (<i> ^volume 3
        ^contents 0)
   (<j> ^volume 5
        ^contents 0)}
learn --off
multi-attributes jug 3
sp {water-jug*elaborate*empty
   (state <s> ^name water-jug
              ^jug <j>)
   (<j> ^contents <c>
        ^volume <v>)
-->
   (<j> ^empty (- <v> <c>))}
sp {water-jug*monitor*state 
   (state <s> ^name water-jug
              ^jug <j> <i>)
   (<j> ^volume 5 ^contents <jcon>)
   (<i> ^volume 3 ^contents <icon>)
   --> 
   (write (crlf) | 5:| <jcon> | 3:| <icon> )}
sp {water-jug*monitor*operator-application*empty
   (state <s> ^name water-jug
              ^operator <o>)
   (<o> ^name empty
        ^empty-jug.volume <volume>)
   -->
   (write (crlf) |  EMPTY(| <volume> |)|)}
sp {water-jug*monitor*operator-application*fill
   (state <s> ^name water-jug
              ^operator <o>)
   (<o> ^name fill 
        ^fill-jug.volume <volume>)
   -->
   (write (crlf) |  FILL(| <volume> |)|)}
sp {water-jug*monitor*operator-application*pour
   (state <s> ^name water-jug
              ^operator <o>)
   (<o> ^name pour 
        ^empty-jug <i>
        ^fill-jug <j>)
   (<i> ^volume <ivol> ^contents <icon>)
   (<j> ^volume <jvol> ^contents <jcon>)
   -->
   (write (crlf) |  POUR(| <ivol> |:| <icon> |,| <jvol> |:| <jcon> |)|)}
sp {water-jug*detect*goal*achieved
   (state <s> ^name water-jug
              ^reward-link <rl>
              ^jug <j>)
   (<j> ^volume 3 ^contents 1)
-->
   (write (crlf) |The problem has been solved.|)
   (<rl> ^reward.value 10
         ^final-update true)
   (halt)}
sp {water-jug*propose*pour
   (state <s> ^name water-jug
              ^jug <i> { <> <i> <j> })
   (<i> ^contents > 0 )
   (<j> ^empty > 0)
-->
   (<s> ^operator <o> +)
   (<o> ^name pour
        ^empty-jug <i>
        ^fill-jug <j>)}
gp {rl*water-jug*pour
   (state <s> ^name water-jug 
              ^operator <op> +
              ^jug <j1> <j2>)
   (<op> ^name pour 
         ^empty-jug.volume [3 5])
   (<j1> ^volume 3 
         ^contents [0 1 2 3])
   (<j2> ^volume 5 
         ^contents [0 1 2 3 4 5])
-->
   (<s> ^operator <op> = 0)
}
sp {water-jug*apply*pour*not-empty-source
   (state <s> ^name water-jug
              ^operator <o>)
   (<o> ^name pour
        ^empty-jug <i>
        ^fill-jug <j>)
   (<j> ^volume <jvol>
        ^contents <jcon>
        ^empty <jempty>)
   (<i> ^volume <ivol>
        ^contents { <icon> <= <jempty> })
-->
   (<i> ^contents 0 <icon> -)
   (<j> ^contents (+ <jcon> <icon>) <jcon> - )}
sp {water-jug*apply*pour*empty-source
   (state <s> ^name water-jug
              ^operator <o>)
   (<o> ^name pour
        ^empty-jug <i>
        ^fill-jug <j>)
   (<i> ^volume <ivol>
        ^contents { <icon> > <jempty> })
   (<j> ^volume <jvol>
        ^contents <jcon>
        ^empty <jempty>)
-->
   (<i> ^contents (- <icon> <jempty>) <icon> - )
   (<j> ^contents <jvol> <jcon> -)}
sp {water-jug*propose*empty
   (state <s> ^name water-jug
              ^jug <j>)
   (<j> ^contents > 0)
-->
   (<s> ^operator <o> +)
   (<o> ^name empty
        ^empty-jug <j>)}
gp {rl*water-jug*empty
   (state <s> ^name water-jug 
              ^operator <op> +
              ^jug <j1> <j2>)
   (<op> ^name empty 
         ^empty-jug.volume [3 5])
   (<j1> ^volume 3 
         ^contents [0 1 2 3])
   (<j2> ^volume 5 
         ^contents [0 1 2 3 4 5])
-->
   (<s> ^operator <op> = 0)
}
sp {water-jug*apply*empty
   (state <s> ^name water-jug
              ^operator <o>
              ^jug <j>)
   (<o> ^name empty
        ^empty-jug <j>)
   (<j> ^volume <volume>
        ^contents <contents>)
-->
   (<j> ^contents 0
        ^contents <contents> - )}
sp {water-jug*propose*fill
   (state <s> ^name water-jug
              ^jug <j>)
   (<j> ^empty > 0)
-->
   (<s> ^operator <o> +)
   (<o> ^name fill
        ^fill-jug <j>)}
gp {rl*water-jug*fill
   (state <s> ^name water-jug 
              ^operator <op> +
              ^jug <j1> <j2>)
   (<op> ^name fill 
         ^fill-jug.volume [3 5])
   (<j1> ^volume 3 
         ^contents [0 1 2 3])
   (<j2> ^volume 5 
         ^contents [0 1 2 3 4 5])
-->
   (<s> ^operator <op> = 0)
}
sp {water-jug*apply*fill
   (state <s> ^name water-jug
              ^operator <o>
              ^jug <j>)
   (<o> ^name fill
        ^fill-jug <j>)
   (<j> ^volume <volume>
        ^contents <contents>)
-->
   (<j> ^contents <volume>
                  <contents> -)}
sp {water-jug*propose*initialize-water-jug
   (state <s> ^superstate nil
             -^name)
-->
   (<s> ^operator <o> +)
   (<o> ^name initialize-water-jug)}
sp {water-jug*apply*initialize-water-jug
   (state <s> ^operator.name initialize-water-jug)
-->
   (<s> ^name water-jug
        ^jug <i> <j>)
   (<i> ^volume 3
        ^contents 0)
   (<j> ^volume 5
        ^contents 0)}
learn --off
multi-attributes jug 3
rl --set learning on
sp {water-jug*elaborate*empty
   (state <s> ^name water-jug
              ^jug <j>)
   (<j> ^contents <c>
        ^volume <v>)
-->
   (<j> ^empty (- <v> <c>))}
sp {water-jug*monitor*state 
   (state <s> ^name water-jug
              ^jug <j> <i>)
   (<j> ^volume 5 ^contents <jcon>)
   (<i> ^volume 3 ^contents <icon>)
   --> 
   (write (crlf) | 5:| <jcon> | 3:| <icon> )}
sp {water-jug*monitor*operator-application*empty
   (state <s> ^name water-jug
              ^operator <o>)
   (<o> ^name empty
        ^empty-jug.volume <volume>)
   -->
   (write (crlf) |  EMPTY(| <volume> |)|)}
sp {water-jug*monitor*operator-application*fill
   (state <s> ^name water-jug
              ^operator <o>)
   (<o> ^name fill 
        ^fill-jug.volume <volume>)
   -->
   (write (crlf) |  FILL(| <volume> |)|)}
sp {water-jug*monitor*operator-application*pour
   (state <s> ^name water-jug
              ^operator <o>)
   (<o> ^name pour 
        ^empty-jug <i>
        ^fill-jug <j>)
   (<i> ^volume <ivol> ^contents <icon>)
   (<j> ^volume <jvol> ^contents <jcon>)
   -->
   (write (crlf) |  POUR(| <ivol> |:| <icon> |,| <jvol> |:| <jcon> |)|)}
sp {water-jug*detect*goal*achieved
   (state <s> ^name water-jug
              ^jug <j>)
   (<j> ^volume 3 ^contents 1)
-->
   (write (crlf) |The problem has been solved.|)
   (halt)}
sp {water-jug*propose*pour
   (state <s> ^name water-jug
              ^jug <i> { <> <i> <j> })
   (<i> ^contents > 0 )
   (<j> ^empty > 0)
-->
   (<s> ^operator <o> + =)
   (<o> ^name pour
        ^empty-jug <i>
        ^fill-jug <j>)}
sp {water-jug*apply*pour*not-empty-source
   (state <s> ^name water-jug
              ^operator <o>)
   (<o> ^name pour
        ^empty-jug <i>
        ^fill-jug <j>)
   (<j> ^volume <jvol>
        ^contents <jcon>
        ^empty <jempty>)
   (<i> ^volume <ivol>
        ^contents { <icon> <= <jempty> })
-->
   (<i> ^contents 0 <icon> -)
   (<j> ^contents (+ <jcon> <icon>) <jcon> - )}
sp {water-jug*apply*pour*empty-source
   (state <s> ^name water-jug
              ^operator <o>)
   (<o> ^name pour
        ^empty-jug <i>
        ^fill-jug <j>)
   (<i> ^volume <ivol>
        ^contents { <icon> > <jempty> })
   (<j> ^volume <jvol>
        ^contents <jcon>
        ^empty <jempty>)
-->
   (<i> ^contents (- <icon> <jempty>) <icon> - )
   (<j> ^contents <jvol> <jcon> -)}
sp {water-jug*propose*empty
   (state <s> ^name water-jug
              ^jug <j>)
   (<j> ^contents > 0)
-->
   (<s> ^operator <o> + =)
   (<o> ^name empty
        ^empty-jug <j>)}
sp {water-jug*apply*empty
   (state <s> ^name water-jug
              ^operator <o>
              ^jug <j>)
   (<o> ^name empty
        ^empty-jug <j>)
   (<j> ^volume <volume>
        ^contents <contents>)
-->
   (<j> ^contents 0
        ^contents <contents> - )}
sp {water-jug*propose*fill
   (state <s> ^name water-jug
              ^jug <j>)
   (<j> ^empty > 0)
-->
   (<s> ^operator <o> + =)
   (<o> ^name fill
        ^fill-jug <j>)}
sp {water-jug*propose*initialize-water-jug
   (state <s> ^superstate nil
             -^name)
-->
   (<s> ^operator <o> +)
   (<o> ^name initialize-water-jug)}
sp {water-jug*apply*initialize-water-jug
   (state <s> ^operator.name initialize-water-jug)
-->
   (<s> ^name water-jug
        ^jug <i> <j>)
   (<i> ^volume 3
        ^contents 0)
   (<j> ^volume 5
        ^contents 0)}
sp {fill*propose*fill-jug
   (state <s> ^name fill
              ^jug <j>)
   (<j> ^picked-up yes
       -^filled-jug yes)
-->
   (<s> ^operator <op> + =)
   (<op> ^name fill-jug)
}
sp {apply*fill-jug
   (state <s> ^operator <op>
              ^jug <j1>)
   (<op> ^name fill-jug)
-->
   (<j1> ^filled-jug yes)
}
sp {elaborate*state*name
   (state <s> ^superstate.operator.name <name>)
-->
   (<s> ^name <name>)}
sp {fill*elaborate*jug
   (state <s> ^superstate.operator.fill-jug <j>)
-->
   (<s> ^jug <j>)}
sp {fill*propose*put-down
   (state <s> ^name fill
              ^jug <j>)
   (<j> ^picked-up yes
        ^filled-jug yes)
-->
   (<s> ^operator <op> + =)
   (<op> ^name put-down)
}
sp {apply*put-down
   (state <s> ^operator <op>
              ^jug <j>)
   (<op> ^name put-down)
   (<j> ^volume <volume>
        ^contents <contents>)
-->
   (<j> ^picked-up yes -
        ^filled-jug yes -
        ^contents <volume>
                  <contents> -)}
sp {fill*propose*pick-up
   (state <s> ^name fill
              ^jug <j>)
   (<j> -^picked-up yes)
-->
   (<s> ^operator <op> + =)
   (<op> ^name pick-up)
}
sp {apply*pick-up
   (state <s> ^operator <op>
              ^jug <j1>)
   (<op> ^name pick-up)
-->
   (<j1> ^picked-up yes)
}
learn --off
multi-attributes jug 3
sp {water-jug*elaborate*empty
   (state <s> ^name water-jug
              ^jug <j>)
   (<j> ^contents <c>
        ^volume <v>)
-->
   (<j> ^empty (- <v> <c>))}
sp {water-jug*monitor*state 
   (state <s> ^name water-jug
              ^jug <j> <i>)
   (<j> ^volume 5 ^contents <jcon>)
   (<i> ^volume 3 ^contents <icon>)
   --> 
   (write (crlf) | 5:| <jcon> | 3:| <icon> )}
sp {water-jug*monitor*operator-application*empty
   (state <s> ^name water-jug
              ^operator <o>)
   (<o> ^name empty
        ^empty-jug.volume <volume>)
   -->
   (write (crlf) |  EMPTY(| <volume> |)|)}
sp {water-jug*monitor*operator-application*fill
   (state <s> ^name water-jug
              ^operator <o>)
   (<o> ^name fill 
        ^fill-jug.volume <volume>)
   -->
   (write (crlf) |  FILL(| <volume> |)|)}
sp {water-jug*monitor*operator-application*pour
   (state <s> ^name water-jug
              ^operator <o>)
   (<o> ^name pour 
        ^empty-jug <i>
        ^fill-jug <j>)
   (<i> ^volume <ivol> ^contents <icon>)
   (<j> ^volume <jvol> ^contents <jcon>)
   -->
   (write (crlf) |  POUR(| <ivol> |:| <icon> |,| <jvol> |:| <jcon> |)|)}
sp {water-jug*detect*goal*achieved
   (state <s> ^name water-jug
              ^jug <j>)
   (<j> ^volume 3 ^contents 1)
-->
   (write (crlf) |The problem has been solved.|)
   (halt)}
sp {water-jug*propose*pour
   (state <s> ^name water-jug
              ^jug <i> { <> <i> <j> })
   (<i> ^contents > 0 )
   (<j> ^empty > 0)
-->
   (<s> ^operator <o> +)
   (<o> ^name pour
        ^empty-jug <i>
        ^fill-jug <j>)}
sp {water-jug*apply*pour*not-empty-source
   (state <s> ^name water-jug
              ^operator <o>)
   (<o> ^name pour
        ^empty-jug <i>
        ^fill-jug <j>)
   (<j> ^volume <jvol>
        ^contents <jcon>
        ^empty <jempty>)
   (<i> ^volume <ivol>
        ^contents { <icon> <= <jempty> })
-->
   (<i> ^contents 0 <icon> -)
   (<j> ^contents (+ <jcon> <icon>) <jcon> - )}
sp {water-jug*apply*pour*empty-source
   (state <s> ^name water-jug
              ^operator <o>)
   (<o> ^name pour
        ^empty-jug <i>
        ^fill-jug <j>)
   (<i> ^volume <ivol>
        ^contents { <icon> > <jempty> })
   (<j> ^volume <jvol>
        ^contents <jcon>
        ^empty <jempty>)
-->
   (<i> ^contents (- <icon> <jempty>) <icon> - )
   (<j> ^contents <jvol> <jcon> -)}
sp {water-jug*propose*empty
   (state <s> ^name water-jug
              ^jug <j>)
   (<j> ^contents > 0)
-->
   (<s> ^operator <o> +)
   (<o> ^name empty
        ^empty-jug <j>)}
sp {water-jug*apply*empty
   (state <s> ^name water-jug
              ^operator <o>
              ^jug <j>)
   (<o> ^name empty
        ^empty-jug <j>)
   (<j> ^volume <volume>
        ^contents <contents>)
-->
   (<j> ^contents 0
        ^contents <contents> - )}
sp {water-jug*propose*fill
   (state <s> ^name water-jug
              ^jug <j>)
   (<j> ^empty > 0)
-->
   (<s> ^operator <o> +)
   (<o> ^name fill
        ^fill-jug <j>)}
sp {water-jug*apply*fill
   (state <s> ^name water-jug
              ^operator <o>
              ^jug <j>)
   (<o> ^name fill
        ^fill-jug <j>)
   (<j> ^volume <volume>
        ^contents <contents>)
-->
   (<j> ^contents <volume>
                  <contents> -)}
sp {water-jug*propose*initialize-water-jug
   (state <s> ^superstate nil
             -^name)
-->
   (<s> ^operator <o> +)
   (<o> ^name initialize-water-jug)}
sp {water-jug*apply*initialize-water-jug
   (state <s> ^operator.name initialize-water-jug)
-->
   (<s> ^name water-jug
        ^jug <i> <j>
        ^last-operator none)
   (<i> ^volume 3
        ^contents 0)
   (<j> ^volume 5
        ^contents 0)}
sp {Impasse__Operator_Tie*propose*evaluate-operator
   (state <s> ^name Impasse__Operator_Tie
              ^evaluation <x>)
  -(<x> ^value)
-->
   (<s> ^operator <op> + =)
   (<op> ^name evaluate-operator
         ^evaluation <x>)
}
sp {apply*evaluate-operator*none
   (state <s> ^operator <op>
              ^evaluation <x>
              ^last-operator none)
   (<op> ^name evaluate-operator
         ^evaluation <x>)
-->
   (<x> ^value equal)
}
sp {apply*evaluate-operator*pour*after-fill-empty
   (state <s> ^operator <op>
              ^evaluation <x>
              ^last-operator << empty fill >>)
   (<op> ^name evaluate-operator
         ^evaluation <x>)
   (<x> ^super-operator.name pour)
-->
   (<x> ^value best)
}
sp {apply*evaluate-operator*pour*after-pour
   (state <s> ^operator <op>
              ^evaluation <x>
              ^last-operator pour)
   (<op> ^name evaluate-operator
         ^evaluation <x>)
   (<x> ^super-operator.name pour)
-->
   (<x> ^value worst)
}
sp {apply*evaluate-operator*fill-empty*after-empty-fill
   (state <s> ^operator <op>
              ^evaluation <x>
              ^last-operator << empty fill >>)
   (<op> ^name evaluate-operator
         ^evaluation <x>)
   (<x> ^super-operator.name << fill empty >>)
-->
   (<x> ^value worst)
}
sp {apply*evaluate-operator*fill-empty*after-pour
   (state <s> ^operator <op>
              ^evaluation <x>
              ^last-operator pour)
   (<op> ^name evaluate-operator
         ^evaluation <x>)
   (<x> ^super-operator.name << fill empty >>)
-->
   (<x> ^value equal)
}
sp {Impasse__Operator_Tie*elaborate*state
   (state <s> ^impasse tie)
-->
   (<s> ^name Impasse__Operator_Tie)
}
sp {Impasse__Operator_Tie*elaborate*state*evaluations
   (state <s> ^name Impasse__Operator_Tie
              ^item <x>)
-->
   (<s> ^evaluation.super-operator <x>)
}
sp {Impasse__Operator_Tie*elaborate*state*last-operator
   (state <s> ^name Impasse__Operator_Tie
              ^superstate.last-operator <o>)
-->
   (<s> ^last-operator <o>)
}
sp {Impasse__Operator_Tie*propose*create-preferences
   (state <s> ^name Impasse__Operator_Tie)
   # Negated conjunction that tests that there is no evaluation that does not have a value - all have values
  -{(<s> ^evaluation <x>)
   -(<x> ^value)}
-->
   (<s> ^operator <op> + =, >)
   (<op> ^name create-preferences)
}
sp {apply*create-preferences*best
   (state <s> ^operator <op>
              ^evaluation <x>
              ^superstate <ss>)
   (<op> ^name create-preferences)
   (<x> ^super-operator <so>
        ^value best)
-->
   (<ss> ^operator <so> >, =)
}
sp {apply*create-preferences*worst
   (state <s> ^operator <op>
              ^evaluation <x>
              ^superstate <ss>)
   (<op> ^name create-preferences)
   (<x> ^super-operator <so>
        ^value worst)
-->
   (<ss> ^operator <so> <, =)
}
sp {apply*create-preferences*equal
   (state <s> ^operator <op>
              ^evaluation <x>
              ^superstate <ss>)
   (<op> ^name create-preferences)
   (<x> ^super-operator <so>
        ^value equal)
-->
   (<ss> ^operator <so> =)
}
sp {water-jug*record*operator
   (state <s> ^name water-jug
              ^operator.name <name>)
-->
   (<s> ^last-operator <name>)}
sp {water-jug*remove*last-operator
   (state <s> ^name water-jug
              ^last-operator <name>
              ^operator.name <> <name>)
-->
   (<s> ^last-operator <name> -)}
learn --off
multi-attributes jug 3
sp {default*generic*opsub*propose*space*generic
   :default
   (state <s> ^impasse no-change ^attribute operator 
	      ^superstate <ss>)
   (state <ss> ^problem-space <p2>)
   -->
   (<s> ^problem-space <p2>)}
sp {default*generic*opsub*elaborate*state*name*operator-subgoal
   :default
   (state <s> ^problem-space <p> 
	      ^impasse no-change ^attribute operator ^superstate <ss>)
   (state <ss> ^problem-space <p>)
   -->
   (<s> ^name operator-subgoal)}
sp {default*generic*opsub*elaborate*state*desired
   :default
   (state <s> ^problem-space <p> ^name operator-subgoal ^superstate <ss>)
   (state <ss> ^operator <o>)
   -->
   (<s> ^desired <o>)}
sp {default*generic*opsub*copy*superstate
   :default
   (state <s> ^name operator-subgoal ^superstate <ss>)
   (<ss> ^ { <att> <> problem-space <> impasse <> object <> name
                   <> superstate <> attribute <> operator <> desired }
	   <value>)
   -->
   (<s> ^<att> <value>)}
sp {default*generic*select*reject-desired
   :default
   (state <s> ^name operator-subgoal ^problem-space <p> ^desired <o>)
   -->
   (<s> ^operator <o> -)}
sp {default*generic*opsub*detect*state*success
   :default
   (state <g-eval> ^problem-space <p> ^desired <o> ^applied <o>)
   (<o> ^achieved <ss>)
   -->
   (<ss> ^success <o>)}
sp {opsub*select-operator*subgoaling
   :default
   (state <s1> ^name implement-evaluate-object ^problem-space <p>
	       ^operator <> <o> ^desired <o>)
   (<o> ^name)
   -->
   (<s1> ^operator <o> !)}
sp {default*generic*opsub*failure*no-operator
   :default
   (state <s> ^superstate <ss> ^impasse no-change ^attribute state ^quiescence t)
   (<ss> ^name operator-subgoal ^desired <d>)
   -->
   (<ss> ^failure <d>)}
sp {default*generic*evaluation*failure*no-operator
   :default
   (state <s> ^superstate <ss> ^impasse no-change ^name operator-subgoal
	      ^attribute operator ^desired <d> ^quiescence t
	      ^failure <d>)
   (<ss> ^operator <so> ^desired <sd>)
   -->
   (<ss> ^failure <sd>)}
sp {default*generic*opsub*avoid*duplicate-operator
   :default
   (state <s> ^impasse no-change ^name operator-subgoal
	      ^attribute operator ^operator <o> + ^super-desired <sd>)
   (<o> ^name <name>)
   (<sd> ^name <name>)
   -->
   (<s> ^operator <o> -)}
sp {default*generic*opsub*subgoal-on-all-desired-super-desireds
   :default
   (state <s> ^problem-space <p>
	      ^impasse no-change ^attribute operator ^superstate <ss>)
   (<ss> ^problem-space <p> ^desired <o>)
   -->
   (<s> ^super-desired <o>)}
sp {default*generic*opsub*subgoal-on-all-super-desireds
   :default
   (state <s> ^problem-space <p>
	      ^impasse no-change ^attribute operator ^superstate <ss>)
   (<ss> ^problem-space <p> ^super-desired <o>)
   -->
   (<s> ^super-desired <o>)}
sp {default*apply*evaluate*augment*evaluation-operator-super-desired
   :default
   (state <s> ^operator <o> ^superstate <ss>)
   (<ss> ^super-desired <d>)
   (<o> ^evaluation <e> ^type evaluation)
   -->
   (<o> ^super-desired <d>)}
sp {default*elaborate*state*eval*super-desired
   :default
   (state <s> ^impasse no-change ^attribute operator ^superstate <ss>)
   (<ss> ^operator <so>)
   (<so> ^type evaluation ^super-desired <d>)
   -->
   (<s> ^super-desired <d>)}
sp {top-goal*halt*success
   :default
   (state <s> ^name <name>
              ^desired <eb>
              ^superstate nil
              ^<< required-success success >> <eb>)
-->
   (write (crlf)   <name>  | achieved |)
   (halt)}
sp {top-goal*halt*failure
   :default
   (state <s> ^superstate nil
              ^desired <eb>
              ^name <name>
              ^ << prohibit-failure failure >> <eb>)
-->
   (write (crlf)  <name>  | failed|)
   (halt)}
sp {evaluate-operator*propose*look-ahead
   :default
   (state <s> ^look-ahead-operator <o>
              ^untried-tied-operator <o>)
   -->
   (<s> ^operator <o> +)}
sp {evaluate-operator*propose*look-ahead*reject-all-others
   :default
   (state <s> ^look-ahead-operator <o>
              ^untried-tied-operator <o>
              ^operator { <> <o> <o1> } +)
   -->
   (<s> ^operator <o1> -)}
sp {evaluate-operator*elaborate*state*tried-tied-operator
   :default
   (state <s> ^operator <o> 
              ^look-ahead-operator <o>)
   -->
   (<s> ^tried-tied-operator <o>)}
sp {evaluate-operator*elaborate*state*remove*untried-tied-operator
   :default
   (state <s> ^look-ahead-operator <o> 
              ^operator <o>
              ^untried-tied-operator <o>)
-->
   (<s> ^untried-tied-operator <o> -)
}
sp {selection*pass-back-success    
   :default
   (state <s> ^superstate.superstate.operator <sso>
              ^evaluation.symbolic-value << required-success >>) # partial-success success >>)
   (<sso> ^name evaluate-operator 
          ^evaluation <e2> 
          ^superoperator.name)
   -->
   (<e2> ^symbolic-value partial-success)}
sp {selection*elaborate*evaluate-operator*all-operators-novalue
   :default
   (state <s> ^superstate.superstate <sss>
              ^operator <o>
             -^not-all-operators-evaluated
             -^found-value
              ^quiescence t
              ^choices multiple)
   (<sss> ^name selection
                ^operator <sso>)
   (<sso> ^name evaluate-operator
          ^evaluation <e>)
   -->
   (<e> ^numeric-value novalue)}
sp {evaluate-operator*elaborate*evaluation*failure*constraint-failure
   :default
   (state <rej-state-imp> ^superstate <eval-g>
                          ^attribute operator
                          ^impasse constraint-failure)
   (<eval-g> ^superstate <select-g>)
   (<select-g> ^operator <o2>)
   (<select-g> ^evaluation <e2>)
   (<o2> ^name evaluate-operator
         ^evaluation <e2>)
-->
   (<e2> ^symbolic-value failure)}
sp {evaluate-operator*elaborate*state*desired
   :default
   (state <s> ^impasse no-change
              ^attribute operator
             -^problem-space.no-local-negations <nln>
              ^superstate.operator <so>)
   (<so>  -^default-desired-copy yes
          ^name evaluate-operator
          ^evaluation.desired <d>)
-->
   (<s> ^desired <d>)}
sp {evaluate-operator*elaborate*state*desired*nln
   :default
   (state <s> ^impasse no-change
              ^attribute operator
              ^problem-space.no-local-negations <nln>
              ^superstate.operator <so>)
   (<so>   ^name evaluate-operator # ddc is assumed no with nln
          ^evaluation.desired <d>)
-->
   (<s> ^desired <d>)}
sp {evaluate-operator*elaborate*state*name
   :default
   (state <s> ^impasse no-change
              ^attribute operator
              ^superstate.operator <so>)
   (<so> ^name evaluate-operator
         ^superstate.name {<> evaluate-operator <name> })
-->
   (<s> ^name <name>)}
sp {evaluate-operator*elaborate*state*duplicate-of
   :default
   (state <s> ^superstate <ss>
              ^default-state-copy yes)
   (<ss> ^operator <so>)
   (<so> ^name evaluate-operator
         ^superstate <sss>)
-->
   (<s> ^duplicate-of <sss>)}
sp {evaluate-operator*elaborate*state*look-ahead-operator*copy
   :default
   (state <s> ^problem-space.name <n>
              ^default-operator-copy yes
              ^superstate.operator <so>)
   (<so> ^name evaluate-operator
         ^superoperator <o>
         ^superproblem-space.name <n>)
-->
   (<s> ^look-ahead-operator <copy-o>)
   (<s> ^untried-tied-operator <copy-o>) # SBW 5/7/07-- -^tried-tied-operator -> ^untried-tied-operator
   (<copy-o> ^duplicate-of <o>)}
sp {evaluate-operator*elaborate*state*look-ahead-operator*no-copy
   :default
   (state <s> ^problem-space.name <p>
              ^default-operator-copy no
              ^superstate.operator <so>)
   (<so> ^name evaluate-operator
         ^superoperator <o>
         ^superproblem-space.name <p>)
-->
   (<s> ^look-ahead-operator <o>)
   (<s> ^untried-tied-operator <o>)}
sp {evaluate-operator*elaborate*symbolic-evaluation*from-subgoal
   :default
   (state <ss> ^superstate <s>
               ^ { << required-success success partial-success
                   indifferent partial-failure failure prohibit-failure
                   >> <svalue> } <eb>)
   (<s> ^operator <so>
        ^evaluation <e>)
   (<so> ^name evaluate-operator
         ^evaluation <e>
         ^evaluation.desired <eb>)
-->
   (<e> ^symbolic-value <svalue>)}
sp {evaluate-operator*elaborate*evaluation*from-subgoal*duplicate-desired
   :default
   (state <s> ^superstate <ss>
              ^ { << required-success success partial-success
                  indifferent partial-failure failure prohibit-failure
                  >> <svalue> } <deb>)
   (<ss> ^operator <so>
         ^evaluation <e>)
   (<so> ^name evaluate-operator
         ^evaluation <e>
         ^evaluation.desired <eb>)
   (<deb> ^duplicate-of <eb>)
-->
   (<e> ^symbolic-value <svalue>)}
sp {evaluate-operator*elaborate*numeric-evaluation*from-subgoal
   :default
   (state <ss> ^superstate <s>
               ^desired <eb>
               ^numeric-value <v>)
   (<s> ^operator <so>
        ^evaluation <e>)
   (<so> ^name evaluate-operator
         ^evaluation <e>
         ^evaluation.desired <eb>)
-->
   (<e> ^numeric-value <v>)}
sp {evaluate-operator*elaborate*default-for-default-state-copy-is-yes
   :default
   (state <s> ^superstate.operator.name evaluate-operator
              ^problem-space <p>)
  -(<p> ^default-state-copy no)
-->
   (<s> ^default-state-copy yes)}
sp {evaluate-operator*elaborate*default-state-copy-from-problem-space
   :default
   (state <s> ^superstate.operator.name evaluate-operator
              ^problem-space.default-state-copy <yes-or-no>)
-->
   (<s> ^default-state-copy <yes-or-no>)}
sp {evaluate-operator*elaborate*state*default-copy-is-all-attributes-at-level-one
   :default
   (state <s> ^impasse no-change
              ^attribute operator
              ^superstate.operator.name evaluate-operator
              ^problem-space <p>)
   (<p> -^all-attributes-at-level two
        -^one-level-attributes
        -^two-level-attributes
        -^dont-copy
        -^dont-copy-anything)
-->
   (<s> ^all-attributes-at-level one)}
sp {evaluate-operator*elaborate*state*default-copy-is-all-attributes-at-level-one*no-problem-space
   :default
   (state <s> ^impasse no-change
             -^problem-space
              ^attribute operator
              ^superstate.operator <so>)
   (<so> ^name evaluate-operator
        -^superproblem-space <p>)
-->
   (<s> ^all-attributes-at-level one)}
sp {evaluate-operator*elaborate*state*copy-all-attributes-at-level-one-from-problem-space
   :default
   (state <s> ^problem-space.all-attributes-at-level one
              ^default-state-copy yes)
-->
   (<s> ^all-attributes-at-level one)}
sp {evaluate-operator*elaborate*state*create-duplicates-table
   :default
   (state <s> ^impasse no-change
              ^attribute operator
              ^default-state-copy yes
              ^superstate.operator.name evaluate-operator)
-->
   (<s> ^duplicates <d>)}
sp {evaluate-operator*elaborate*state*add-one-level-attributes
   :default
   (state <s> ^problem-space.one-level-attributes <att>
              ^duplicate-of.<att> <val>
              ^default-state-copy yes)
-->
   (<s> ^<att> <val>)}
sp {evaluate-operator*elaborate*state*add-all-attributes-at-level-one
   :default
   (state <s> ^problem-space <p>
                             ^default-state-copy yes
                             ^all-attributes-at-level one
                             ^duplicate-of <ss>)
   (<p> -^dont-copy-anything
        -^dont-copy <att>)
   (<ss> ^{ <> duplicate-of <> tried-tied-operator <> problem-space
            <> impasse <> attribute <> choices <> quiescence
            <> operator <> superstate <> type <> name <> look-ahead-operator
            <att> } <val>)
-->
   (<s> ^<att> <val>)}
sp {evaluate-operator*elaborate*state*change-one-level-attribute-to-duplicate
   :default
   (state <s> ^problem-space.one-level-attributes <att>
              ^duplicates.<id> <new-id>
              ^default-state-copy yes
              ^duplicate-of.<att> <id>)
-->
   (<s> ^<att> <id> -
        ^<att> <new-id>)}
sp {evaluate-operator*elaborate*state*change-all-attributes-at-level-one-to-duplicate
   :default
   (state <s> -^problem-space.dont-copy <att>
        ^default-state-copy yes
        ^all-attributes-at-level one
        ^duplicates.<id> <new-id>
        ^duplicate-of.{ <> tried-tied-operator <att> } <id>)
-->
   (<s> ^<att> <id> -
        ^<att> <new-id>)}
sp {evaluate-operator*elaborate*state*duplicate-id-for-attribute
   :default
   (state <s> ^problem-space.two-level-attributes <att>
              ^duplicates <d>
              ^default-state-copy yes
              ^duplicate-of.<att> <id>)
-->
   (<d> ^<id> <new-id>)}
sp {evaluate-operator*elaborate*state*duplicate-id-for-all-attributes
   :default
   (state <s> ^problem-space <p>
              ^duplicates <d>
              ^default-state-copy yes
              ^duplicate-of <ss>)
   (<p> -^dont-copy-anything
        -^dont-copy <att>
              ^all-attributes-at-level two
             -^one-level-attributes <att>)
   (<ss> ^{ <> duplicate-of <> tried-tied-operator <> problem-space
            <> impasse <> attribute <> choices <> quiescence
            <> operator <> superstate
            <att> } <id>)
-->
   (<d> ^<id> <new-id>)}
              warnings --off
sp {evaluate-operator*elaborate*add-attribute-to-duplicate
   :default
   (state <s> ^duplicates <d>
             -^problem-space.no-local-negations <nln>
             -^problem-space.dont-copy <sub-att>
              ^default-state-copy yes)
   (<d> ^<id> <new-id>
             - ^<sub-val>)
   (<id> ^ { <> tried-tied-operator <sub-att> } <sub-val>)
-->
   (<new-id> ^<sub-att> <sub-val>)}
                        warnings --on
              warnings --off
sp {evaluate-operator*elaborate*add-attribute-to-duplicate*nln
   :default
   (state <s> ^duplicates <d>
              ^problem-space.no-local-negations <nln>
              ^default-state-copy yes)
   (<d> ^<id> <new-id>)
   (<id> ^ { <> tried-tied-operator <sub-att> } <sub-val>)
-->
   (<new-id> ^<sub-att> <sub-val>)}
                        warnings --on
                        warnings --off
sp {evaluate-operator*elaborate*add-duplicated-attribute-to-duplicate
   :default
   (state <s> ^duplicates <d>
              ^default-state-copy yes)
   (<d> ^<id> <new-id>
        ^<sub-val> <new-val>)
   (<id> ^ { <> tried-tied-operator <sub-att> } <sub-val>)
-->
   (<new-id> ^<sub-att> <new-val>)}
                        warnings --on
sp {evaluate-operator*elaborate*state*add-duplicate-to-state
   :default
   (state <s> ^problem-space.two-level-attributes <att>
              ^duplicates.<id> <new-id>
              ^default-state-copy yes
              ^duplicate-of.<att> <id>)
-->
   (<s> ^<att> <new-id>)}
sp {evaluate-operator*elaborate*state*add-duplicates-for-all-attributes
   :default
   (state <s> ^problem-space <p>
              ^duplicates.<id> <new-id>
              ^default-state-copy yes
              ^duplicate-of.{ <> tried-tied-operator <att> } <id>)
   (<p> ^all-attributes-at-level two
     - ^dont-copy-anything
     - ^dont-copy <att>
     - ^one-level-attributes <att>)
-->
   (<s> ^<att> <new-id>)}
sp {evaluate-operator*elaborate*state*eval*desired
   :default
   (state <s> ^superstate <ss>)
   (<ss> ^operator <so>)
   (<so> ^name evaluate-operator
         ^evaluation.desired <d>
         ^default-desired-copy yes)
-->
   (<s> ^desired <d-copy>)
   (<d-copy> ^duplicate-of <d>)}
sp {duplicate-desired*copy-old-value
   :default
   (state <s> ^superstate.operator <so>
              ^problem-space <p>
              ^duplicates <d>
              ^desired <o-copy>)
   (<so> ^name evaluate-operator
         ^evaluation.desired <o>)
   (<o-copy> ^duplicate-of <o>)
   (<o> ^{ <> duplicate-of <att> } <val>)
 - (<p> ^dont-copy <att>)
 - (<d> ^<val>)
-->
   (<o-copy> ^<att> <val>)}
sp {duplicate-desired*replace-old-value
   :default
   (state <s> ^duplicates.<id> <copy-id>
              ^problem-space <p> 
              ^desired <o-copy>)
   (<o-copy> ^duplicate-of <o>)
   (<o> ^ { <> duplicate-of <att> } <id>)
   (<p> - ^dont-copy <att>)
-->
   (<o-copy> ^<att> <copy-id>)}
sp {evaluate-operator*elaborate*operator*default-operator-copy-is-yes
   :default
   (state <s> ^superstate.operator.name evaluate-operator
              ^problem-space <ps>)
   (<ps> -^default-operator-copy no)
-->
   (<s> ^default-operator-copy yes)}
sp {evaluate-operator*elaborate*operator*copy-default-operator-copy-from-problem-space
   :default
   (state <s> ^superstate.operator.name evaluate-operator
              ^problem-space.default-operator-copy <yes-or-no>)
-->
   (<s> ^default-operator-copy <yes-or-no>)}
sp {evaluate-operator*elaborate*state*create-duplicates-table-for-operator-only
   :default
   (state <s> ^impasse no-change
              ^attribute operator
              ^default-operator-copy yes
                                    - ^default-state-copy yes)
-->
   (<s> ^duplicates <d>)}
sp {evaluate-operator*elaborate*operator*add-attribute-to-duplicate-operator
   :default
   (state <s> ^duplicates <d>
          ^problem-space <p>
        ^look-ahead-operator <o-copy>)
   (<o-copy> ^duplicate-of <o>)
   (<o> ^ { <> duplicate-of <att> } <val>)
   (<p> -^dont-copy <att>
        -^no-local-negations <nln>)
   (<d> - ^<val>)
-->
   (<o-copy> ^<att> <val>)}
sp {evaluate-operator*elaborate*operator*add-duplicated-attribute-to-duplicate-operator
   :default
   (state <s> ^duplicates <d>
          ^problem-space <p>
              ^look-ahead-operator <o-copy>)
   (<o-copy> ^duplicate-of <o>)
   (<o> ^ { <> duplicate-of <att> } <id>)
  (<p> -^dont-copy <att>
       -^no-local-negations <nln>)
   (<d> ^<id> <copy-id>)
-->
   (<o-copy> ^<att> <copy-id>)}
sp {evaluate-operator*elaborate*operator*add-attribute-to-duplicate-operator*nln
   :default
   (state <s> ^problem-space <p>
              ^look-ahead-operator <o-copy>)
   (<o-copy> ^duplicate-of <o>)
   (<o> ^ { <> duplicate-of <att> } <val>)
   (<p> ^no-local-negations <nln>)
-->
   (<o-copy> ^<att> <val>)}
sp {monitor*goal*success
   :default
   (state <s> ^top-state <ts>
              ^name <gname>
              ^desired <d>
              ^<< partial-success required-success success >> <d>)
   (<ts> ^superstate nil
        -^verbose false)
-->
   (write (crlf) |  Goal | <gname> | succeeded. |)}
sp {monitor*goal*failure
   :default
   (state <s> ^top-state <ts>
              ^name <gname>
              ^desired <d>
              ^<< partial-failure failure prohibit-failure >> <d>)
   (<ts> ^superstate nil
        -^verbose false)
-->
   (write (crlf) |  Goal | <gname> | failed. |)}
sp {evaluate-operator*elaborate*evaluation*failure*no-operators
   :default
   (state <goal-nc> ^superstate <state-nc>
                    ^attribute state
                    ^impasse no-change
                    ^quiescence t)
   (<state-nc> ^superstate <eval-g>
               ^attribute state
               ^impasse no-change
               ^quiescence t)
   (<eval-g> ^superstate <select-g>
             ^quiescence t)
   (<select-g> ^operator <o2>
               ^evaluation <e2>)
   (<o2> ^name evaluate-operator
         ^evaluation <e2>)
-->
   (<e2> ^symbolic-value failure)}
sp {selection*propose*evaluate-operator
   :default
   (state <s> ^name selection
              ^item <i>)
  -{(state <s> ^evaluation <e>)
    (<e> ^superoperator <i>
         ^value true)}
-->
   (<s> ^operator <o> +)
   (<o> ^name evaluate-operator
        ^superoperator <i>)}
sp {selection*select*evaluate-operator*indifferent
   :default
   (state <s> ^name selection
             -^operator-selection not-indifferent
              ^operator <o> +)
   (<o> ^name evaluate-operator)
-->
   (<s> ^operator <o> =)}
sp {selection*apply*state*evaluation
   :default
   (state <s> ^name selection
              ^operator <o>)
   (<o> ^name evaluate-operator
        ^superoperator <ob>)
-->
   (<s> ^evaluation <e>)
   (<e> ^superoperator <ob>)}
sp {selection*elaborate*evaluate-operator*evaluation
   :default
   (state <s> ^name selection
              ^operator <o>
              ^evaluation <e>)
   (<o> ^name evaluate-operator
        ^superoperator <ob>)
   (<e> ^superoperator <ob>)
-->
   (<o> ^evaluation <e>)}
sp {selection*elaborate*evaluate-operator*superproblem-space
   :default
   (state <s> ^name selection
              ^operator <o>
              ^superstate.problem-space <p2>)
   (<o> ^name evaluate-operator)
-->
   (<o> ^superproblem-space <p2>)}
sp {selection*elaborate*evaluate-operator*superstate
   :default
   (state <s> ^name selection
              ^operator <o>
              ^superstate <ss>)
   (<o> ^name evaluate-operator)
-->
   (<o> ^superstate <ss>)}
sp {selection*elaborate*name*selection
   :default
   (state <s> ^choices multiple)
-->
   (<s> ^name selection)}
sp {selection*elaborate*evaluation*value
   :default
   (state <s> ^evaluation <e>)
   (<e> ^ << numeric-value symbolic-value >>)
-->
   (<e> ^value true)}
sp {selection*elaborate*evaluation*desired
   :default
   (state <s> ^superstate.desired <d>
              ^evaluation <e>)
-->
   (<e> ^desired <d>)}
sp {selection*compare*equal-evaluation-indifferent
   :default
   (state <s> ^name selection
              ^superstate <ss>
              ^evaluation <e1>  { <> <e1> <e2> })
   (<ss> ^desired <d>)
   (<e1> ^superoperator <x>
         ^numeric-value <v>
         ^desired <d>)
   (<e2> ^superoperator <y>
         ^numeric-value <v>
         ^desired <d>)
  - (<d> ^equal not-indifferent)
-->
   (<ss> ^operator <x> = <y>)}
sp {selection*compare*higher-evaluation-better
   :default
   (state <s> ^name selection
              ^superstate <ss>
              ^evaluation <e1>
              ^evaluation { <> <e1> <e2> })
   (<ss> ^problem-space <p2>
         ^desired <d>)
   (<e1> ^superoperator <o1>
         ^numeric-value <v>
         ^desired <d>)
   (<e2> ^superoperator <o2>
         ^numeric-value < <v>
         ^desired <d>)
   (<d> ^better higher)
-->
   (<ss> ^operator <o2> < <o1>)}
sp {selection*compare*prefer-lower-evaluation
   :default
   (state <s> ^name selection
              ^superstate <ss>
              ^evaluation <e1>
              ^evaluation { <> <e1> <e2> })
   (<ss> ^problem-space <p2>
         ^desired <d>)
   (<e1> ^superoperator <o1>
         ^numeric-value <v>
         ^desired <d>)
   (<e2> ^superoperator <o2>
         ^numeric-value > <v>
         ^desired <d>)
   (<d> ^better lower)
-->
   (<ss> ^operator <o2> < <o1>)}
sp {selection*compare*same-symbolic-evaluations-are-indifferent
   :default
   (state <s> ^name selection
              ^superstate <ss>
              ^evaluation <e1>  { <> <e1> <e2> })
   (<ss> ^desired <d>)
   (<e1> ^superoperator <x>
         ^symbolic-value <v>
         ^desired <d>)
   (<e2> ^superoperator <y>
         ^symbolic-value <v>
         ^desired <d>)
-->
   (<ss> ^operator <x> = <y>)}
sp {selection*compare*success-evaluation-better-than-partial-success
   :default
   (state <s> ^name selection
              ^superstate <ss>
              ^evaluation <e1> { <> <e1> <e2> })
   (<ss> ^desired <d>)
   (<e1> ^superoperator <x>
         ^symbolic-value success
         ^desired <d>)
   (<e2> ^superoperator { <> <x> <y> }
         ^symbolic-value partial-success
         ^desired <d>)
-->
   (<ss> ^operator <x> > <y>)}
sp {selection*compare*partial-failure-evaluation-better-than-failure
   :default
   (state <s> ^name selection
              ^superstate <ss>
              ^evaluation <e1>  { <> <e1> <e2> })
   (<ss> ^desired <d>)
   (<e1> ^superoperator <x>
         ^symbolic-value partial-failure
         ^desired <d>)
   (<e2> ^superoperator { <> <x> <y> }
         ^symbolic-value failure
         ^desired <d>)
-->
   (<ss> ^operator <x> > <y>)}
sp {selection*select*required-success-evaluation-becomes-required-preference
   :default
   (state <s> ^name selection
              ^superstate <ss>
              ^evaluation <e1>)
   (<ss> ^desired <eb>)
   (<e1> ^symbolic-value required-success
         ^desired <eb>
         ^superoperator <o1>)
-->
   (<ss> ^operator <o1> !)}
sp {selection*select*success-evaluation-becomes-best-preference
   :default
   (state <s> ^name selection
              ^superstate <ss>
              ^evaluation <e1>)
   (<ss> ^desired <eb>)
   (<e1> ^symbolic-value << partial-success success >>
         ^desired <eb>
         ^superoperator <o1>)
-->
   (<ss> ^operator <o1> >)}
sp {selection*select*failure-evaluation-becomes-reject-preference
   :default
   (state <s> ^name selection
              ^superstate <ss>
              ^evaluation <e1>)
   (<ss> ^desired <e>)
   (<e1> ^symbolic-value << lose failure >>
         ^desired <e>
         ^superoperator <o1>)
-->
   (<ss> ^operator <o1> -)}
sp {selection*select*prohibit-failure-evaluation-becomes-prohibit-preference
   :default
   (state <s> ^name selection
              ^superstate <ss>
              ^evaluation <e1>)
   (<ss> ^desired <e>)
   (<e1> ^symbolic-value prohibit-failure
         ^desired <e>
         ^superoperator <o1>)
-->
   (<ss> ^operator <o1> ~)}
sp {selection*select*indifferent-evaluation-becomes-indifferent-preference
   :default
   (state <s> ^name selection
              ^superstate <ss>
              ^evaluation <e1>)
   (<ss> ^desired <eb>)
   (<e1> ^symbolic-value indifferent
         ^desired <eb> 
         ^superoperator <o1>)
   -->
   (<ss> ^operator <o1> =)}
sp {selection*select*partial-failure-evaluation-becomes-worst-preference
   :default
   (state <s> ^name selection
              ^superstate <ss>
              ^evaluation <e1>)
   (<ss> ^desired <e>)
   (<e1> ^symbolic-value partial-failure
         ^desired <e>
         ^superoperator <o1>)
   -->
   (<ss> ^operator <o1> <)}
sp {selection*elaborate*state*all-objects-evaluated
   :default
   (state <s> ^name selection
              ^operator <o> +)
- {(<o> ^name evaluate-operator
        ^evaluation.value true)}
   -->
   (<s> ^not-all-operators-evaluated true)}
sp {selection*elaborate*state*found-value-true
   :default
   (state <s> ^name selection
              ^evaluation <e>)
   (<e> ^ << numeric-value symbolic-value >> <> novalue)
   -->
   (<s> ^found-value true)}
sp {selection*compare*novalue-evaluation-always-worse
   :default
   (state <s> ^name selection 
              ^superstate <ss>
              ^evaluation <e1>
              ^evaluation { <> <e1> <e2> })
   (<ss> ^desired <d>)
   (<e1> ^superoperator <o1>
         ^numeric-value novalue
         ^desired <d>)
   (<e2> ^superoperator <o2>
         ^numeric-value <> novalue
         ^desired <d>)
   -->
   (<ss> ^operator <o2> > <o1>)} 
sp {monitor*operator*evaluation
   :default
   (state <s> ^top-state <ts>
              ^operator <o>)
   (<o> ^name evaluate-operator
        ^superoperator <obj>
        ^evaluation. << numeric-value symbolic-value >> <n>)
   (<obj> ^name <name>)
   (<ts> ^superstate nil
        -^verbose false)
-->
   (write (crlf) |  Evaluation of | <obj> | (|
   <name> |) is | <n>)}
sp {selection*propose*achieved-max-depth
   (state <s> ^name selection
              ^max-evaluation-depth <med>
              ^current-evaluation-depth <med>)
-->
   (<s> ^operator <op> + =)
   (<op> ^name achieved-max-depth)
}
sp {apply*achieved-max-depth
   (state <s> ^operator <op>
              ^item <o>
              ^superstate <ss>)
   (<op> ^name achieved-max-depth)
-->
   (<ss> ^operator <o> =)
}
sp {evaluate-operator*apply*decrement-current-evaluation-depth
   (state <s> ^operator <o>
              ^current-evaluation-depth <ced>)
   (<o> ^name { <> achieved-max-depth 
                <> decrement-remaining-operators 
                <> no-more-evaluations 
                <> exceed-depth 
                <> evaluate-operator 
                <> increment-current-evaluation-depth 
                <> init-current-evaluation-depth 
                <> init-remaining-operators })
-->
   (<s> ^current-evaluation-depth (- <ced> 1) <ced> -)}
sp {selection*propose*no-more-evaluations
   (state <s> ^name selection
              ^top-selection false
              ^remaining-operators 0)
-->
   (<s> ^operator <op> + =)
   (<op> ^name no-more-evaluations)
}
sp {apply*increment-no-more-evaluations
   (state <s> ^operator <op>
              ^superstate.superstate <ss>
              ^superstate.superstate.operator <o>)
   (<ss> ^unevaluated-operator <u>)
   (<o> ^name evaluate-operator
        ^evaluation <e>
        ^superoperator <u>)
   (<op> ^name no-more-evaluations)
-->
   (<e> ^symbolic-value depth-exceeded)
   (<ss> ^unevaluated-operator <u> -)
}
sp {selection*pass-back-success*iterative
   :default
   (state <s> ^superstate.superstate.operator <sso>
              ^evaluation.symbolic-value << required-success success >>)
   (<sso> ^name evaluate-operator
          ^evaluation <e2>
          ^superoperator.name)
-->
   (write (crlf) |Success | <e2> )
   (<e2> ^symbolic-value success)}
sp {selection*propose*init-current-evaluation-depth*middle-selection
   (state <s> ^name selection
              ^top-selection false
              ^superstate.current-evaluation-depth <ced>)
-->
   (<s> ^current-evaluation-depth <ced>)
}
sp {evaluate-operator*elaborate*state
   (state <s> ^superstate.operator <o>)
   (<o> ^name evaluate-operator
        ^evaluation.current-evaluation-depth <ced>)
-->
   (<s> ^current-evaluation-depth <ced>)
}
sp {evaluate-operator*elaborate*symbolic-evaluation*from-subgoal*depth-exceeded
   :default
   (state <ss> ^superstate <s>
               ^depth-exceeded <eb>)
   (<s> ^operator <so>
        ^evaluation <e>
        ^unevaluated-operator <u>
        ^allow-one-evaluation <a>)
   (<so> ^name evaluate-operator
         ^evaluation <e>
         ^superoperator <u>
         ^evaluation.desired <eb>)
-->
   (<e> ^symbolic-value depth-exceeded)
   (<s> ^unevaluated-operator <u> -
        ^allow-one-evaluation <a> -)}
sp {evaluate-operator*elaborate*symbolic-evaluation*from-subgoal
   :default
   (state <ss> ^superstate <s>
               ^ { << required-success success partial-success
                   indifferent partial-failure failure prohibit-failure
                   >> <svalue> } <eb>)
   (<s> ^operator <so>
        ^evaluation <e>
        ^unevaluated-operator <u>
        ^allow-one-evaluation <a>)
   (<so> ^name evaluate-operator
         ^evaluation <e>
         ^superoperator <u>
         ^evaluation.desired <eb>)
-->
   (<e> ^symbolic-value <svalue>)
   (<s> ^unevaluated-operator <u> -
        ^allow-one-evaluation <a> -)}
sp {evaluate-operator*propose*exceed-depth
   (state <s> ^current-evaluation-depth <= 0
          #    ^quiescence t
              ^look-ahead-operator <o>
          #    ^depth-valid <dv>
              ^tried-tied-operator <o>)
-->
   (<s> ^operator <op> + =, >)
   (<op> ^name exceed-depth)
}
sp {evaluate-operator*compare*exceed-depth
   (state <s> ^name evaluate-operator
              ^look-ahead-operator <op2>
              ^operator <op1> +
                        <op2> +)
   (<op1> ^name exceed-depth)
-->
   (<s> ^operator <op1> < <op2>)
}
sp {apply*exceed-depth
   (state <s> ^operator <op>
              ^desired <d>)
   (<op> ^name exceed-depth)
-->
   (<s> ^depth-exceeded <d>)
}
sp {selection*mark-item-unevaluated
   (state <s> ^name selection
              ^item <i>
              ^current-evaluation-depth <ced>)
-->
   (<s> ^unevaluated-operator <i>)
}
sp {selection*mark-remaining-operators-unused
   (state <s> ^name selection
              ^remaining-operators <ro>)
-->
   (<s> ^allow-one-evaluation <a>)
}
sp {selection*propose*evaluate-operator
   :default
   (state <s> ^name selection
              ^item <i>
              ^current-evaluation-depth <ced>
              ^remaining-operators <ro>
              ^allow-one-evaluation <al>
              ^unevaluated-operator <i>)
-->
   (<s> ^operator <o> +)
   (<o> ^name evaluate-operator
        ^superoperator <i>
        ^current-evaluation-depth <ced>
        ^remaining-operators <ro>)}
sp {apply*evaluate-operator*clean-up-evaluations
   (state <s> ^operator <op>
              ^evaluation <e2>)
   (<op> ^name evaluate-operator
         ^current-evaluation-depth <ced>
         ^remaining-operators <ro>)
   (<e2> ^value true)
  -(<e2> ^current-evaluation-depth <ced>)
-->
   (<s> ^evaluation <e2> -)
}
sp {selection*elaborate*evaluate-operator*remaining-operators*current-evaluation-depth
   :default
   (state <s> ^name selection
              ^current-evaluation-depth <ced>
              ^remaining-operators <ro>
              ^operator <o>
              ^evaluation <e>)
   (<o> ^name evaluate-operator
        ^evaluation <e>)
-->
   (<e> ^remaining-operators <ro>
        ^current-evaluation-depth <ced>)}
sp {selection*elaboration*top-selection
   (state <s> ^name selection
             -^superstate.superstate.name selection)
-->
   (<s> ^top-selection true)
}
sp {selection*elaboration*not-top-selection
   (state <s> ^name selection
              ^superstate.superstate.name selection)
-->
   (<s> ^top-selection false)
}
sp {selection*compare*same-symbolic-evaluations-are-indifferent
   :default
   (state <s> ^name selection 
              ^superstate <ss>
              ^evaluation <e1>  { <> <e1> <e2> })
   (<ss> ^desired <d>)
   (<e1> ^superoperator <x> 
         ^symbolic-value { <> partial-success <> depth-exceeded <v> }
         ^desired <d>)
   (<e2> ^superoperator <y> 
         ^symbolic-value <v>
         ^desired <d>)
   -->
   (<ss> ^operator <x> = <y>)}  
sp {selection*monitor*depth
   (state <s> ^name selection
              ^current-evaluation-depth <ced>
              ^remaining-operators <ro>)
-->
   (write (crlf) |Depth: | <ced> |, | <ro>)
}
sp {selection*propose*init-current-evaluation-depth*top-selection
   (state <s> ^name selection
              ^top-selection true
             -^current-evaluation-depth
             -^superstate.start-depth)
-->
   (<s> ^operator <op> + =, >)
   (<op> ^name init-current-evaluation-depth
         ^value 1)
}
sp {selection*propose*init-current-evaluation-depth*top-selection*start-depth
   (state <s> ^name selection
              ^top-selection true
             -^current-evaluation-depth
              ^superstate.start-depth <sd>)
-->
   (<s> ^operator <op> + =, >)
   (<op> ^name init-current-evaluation-depth
         ^value <sd>)
}
sp {apply*init-current-evaluation-depth
   (state <s> ^operator <op>)
   (<op> ^name init-current-evaluation-depth
         ^value <v>)
-->
   (<s> ^current-evaluation-depth <v>)
}
sp {apply*init-current-evaluation-depth*max
   (state <s> ^top-selection true
              ^operator <op>)
   (<op> ^name init-current-evaluation-depth)
-->
   (<s> ^max-evaluation-depth 50)
}
sp {selection*propose*increment-current-evaluation-depth
   (state <s> ^name selection
              ^top-selection true
              ^remaining-operators 0
              ^current-evaluation-depth <ced>
              ^item-count <toc>)
-->
   (<s> ^operator <op> + =, >)
   (<op> ^name increment-current-evaluation-depth
              ^current-evaluation-depth <ced>)
}
sp {apply*increment-current-evaluation-depth
   (state <s> ^operator <op>
              ^item-count <toc>
              ^remaining-operators 0
              ^current-evaluation-depth <ced>)
   (<op> ^name increment-current-evaluation-depth)
-->
   (<s> ^remaining-operators <toc> 0 -
        ^current-evaluation-depth (+ 1 <ced>) <ced> -)
}
sp {apply*increment-current-evalaution*clean-up-evaluations
   (state <s> ^operator <op>
              ^evaluation <e2>)
   (<op> ^name increment-current-evaluation-depth
         ^current-evaluation-depth <ced>)
   (<e2> ^value true)
-->
   (<s> ^evaluation <e2> -)
}
sp {selection*elaborate*no-remaining-operators
   (state <s> ^name selection)
-->
   (<s> ^no-remaining-operators <n>)
}
sp {selection*propose*init-remaining-operators
   (state <s> ^name selection
              ^no-remaining-operators <n>
              ^item-count <toc>)
-->
   (<s> ^operator <op> + =, >)
   (<op> ^name init-remaining-operators
         ^value <toc>)
}
sp {apply*init-remaining-operators
   (state <s> ^operator <op>
              ^no-remaining-operators <n>)
   (<op> ^name init-remaining-operators
         ^value <toc>)
-->
   (<s> ^remaining-operators <toc>)
   (<s> ^no-remaining-operators <n> -)
}
sp {selection*propose*decrement-remaining-operators
   (state <s> ^name selection
              ^current-evaluation-depth <ced>
              ^remaining-operators <ro>
              ^evaluation <e>)
   (<e> ^current-evaluation-depth <ced>
        ^remaining-operators <ro>
        ^value true)
-->
   (<s> ^operator <op> + =, >)
   (<op> ^name decrement-remaining-operators)
}
sp {apply*decrement-remaining-operators
   (state <s> ^operator <op>
              ^remaining-operators <ro>)
   (<op> ^name decrement-remaining-operators)
-->
   (<s> ^remaining-operators (- <ro> 1)
                             <ro> -)
}
sp {default*elaborate*state*io
   "Elaborate each substate with io pointer."
   :default
   (state <s> ^impasse no-change
              ^superstate.io <io>)
   -->
   (<s> ^io <io>)}
sp {elaborate*state*operator*name
   "Elaborate substates with name of operator."
   :default
   (state <s> ^superstate.operator.name <name>)
-->
   (<s> ^name <name>)}
sp {top-ps*propose*wait
   "Propose wait if there is a state no-change."
   :default
   (state <s> ^attribute state
              ^choices none
             -^operator.name wait)
-->
   (<s> ^operator <o> + <)
   (<o> ^name wait)}
sp {top-ps*apply*wait*random
   "Fake production just to avoid extra operator no-change."
   :default
   (state <s> ^operator <o>)
   (<o> ^name wait)
-->
   (<o> ^random elaboration)}
sp {default*top-goal*halt*operator*failure
   "Halt if no operator can be selected for the top goal."
   :default
   (state <s> ^superstate nil)
   (state <ss> ^impasse constraint-failure ^superstate <s>)
   -->
   (write (crlf) |No operator can be selected for top goal.| )
   (write (crlf) |Soar must halt.| )
   (halt)}
sp {default*select*indifferent-and-worst*tied
   "Indifferent an object if it leads to a tie that can not be resolved."
   :default
   (state <s1> ^operator <o> +)
   (state <s2> ^superstate <s1>
	         ^item <o>
	         ^quiescence t)
   (state <s3> ^attribute state
	         ^choices none
	         ^superstate <s2>
	         ^quiescence t)
   -->
   (<s1> ^operator <o> =, < )}
sp {default*select*reject*conflict
   "Reject an object if it leads to a conflict that can not be resolved."
   :default
   (state <s1> ^operator <o> +)
   (state <s2> ^impasse conflict
	         ^attribute operator
	         ^superstate <s1>
	         ^item <o>
	         ^quiescence t)
   (state <s3> ^attribute state
	         ^choices none
	         ^superstate <s2>
	         ^quiescence t)
   -->
   (<s1> ^operator <o> -)}
sp {elaborate*top-state*top-state
   (state <s> ^superstate nil)
-->
   (<s> ^top-state <s>)
}
sp {elaborate*state*name
   (state <s> ^superstate.operator.name <name>)
-->
   (<s> ^name <name>)
}
sp {elaborate*state*top-state
   (state <s> ^superstate.top-state <ts>)
-->
   (<s> ^top-state <ts>)
}
sp {elaborations*elaborate*state*digit-cue
   (state <s> ^digit <d>)
   (<d> ^word <word>
        ^number <number>)
-->
   (<d> ^cue <c>)
   (<c> ^word <word>
        ^number <number>)
}
sp {elaborations*elaborate*state*bad-retrieval*gm
   (state <s> ^epmem.result.graph-match 0)
-->
   (write |BAD RETRIEVAL!!!|)
   (halt)
}
sp {testing*propose*testing-convert
   (state <s> ^name testing
              ^superstate <ss>)
   (<ss> ^episode <ep>
         ^size.number <size>)
-->
   (<s> ^operator <op> + =)
   (<op> ^name testing-convert
         ^type convert
         ^number <ep>
         ^places <size>)
}
sp {apply*testing-convert
   (state <s> ^operator <op>
              ^convert-result <r>
              ^superstate <ss>)
   (<op> ^name testing-convert)
-->
   (<ss> ^convert-result <r>)
}
sp {count-epmem*propose*storing
   (state <s> ^name count-epmem
              ^mode storing)
-->
   (<s> ^operator <op> + =)
   (<op> ^name storing)
}
sp {count-epmem*elaborate*storing
   (state <s> ^name count-epmem
              ^mode storing
              ^digit <d>
              ^smem.command <cmd>)
-->
   (<cmd> ^store <d>)
}
sp {apply*storing*done
   (state <s> ^operator <op>
              ^mode storing)
   (<op> ^name storing)
-->
   (<s> ^mode storing - recording
        ^lti t)
}
sp {convert*propose*convert-done
   (state <s> ^name convert
              ^current <p>
              ^places <p>)
-->
   (<s> ^operator <op> + =)
   (<op> ^name convert-done)
}
sp {apply*convert-done
   (state <s> ^operator <op>
              ^superstate <ss>
              ^result <r>)
   (<op> ^name convert-done)
-->
   (<ss> ^convert-result <r>)
}
sp {convert*elaborate*substate
   (state <s> ^superstate.operator <so>)
   (<so> ^type convert
         ^number <n>
         ^places <p>)
-->
   (<s> ^name convert
        ^number <n>
        ^places <p>)
}
sp {convert*propose*convert-init
   (state <s> ^name convert
             -^current)
-->
   (<s> ^operator <op> + =)
   (<op> ^name convert-init)
}
sp {apply*convert-init
   (state <s> ^operator <op>)
   (<op> ^name convert-init)
-->
   (<s> ^result <r>
        ^current 0
        ^pow-ten 10)
}
sp {convert*propose*convert-digit
   (state <s> ^name convert
              ^current <c>
              ^places {<> <c>})
-->
   (<s> ^operator <op> + =)
   (<op> ^name convert-digit)
}
sp {apply*convert-digit*intermediate
   (state <s> ^operator <op>
              ^pow-ten <pow-ten>
              ^number <n>)
   (<op> ^name convert-digit)
-->
   (<s> ^intermediate (int (mod (int (* (/ <n> <pow-ten>) 10)) 10)))
}
sp {apply*convert-digit
   (state <s> ^operator <op>
              ^current <c>
              ^intermediate <i>
              ^pow-ten <pow-ten>
              ^result <r>
              ^top-state.digit <digit-c> <digit-i>)
   (<op> ^name convert-digit)
   (<digit-c> ^previous.number <c>
              ^word <word-current>)
   (<digit-i> ^number <i>)
-->
   (<s> ^current <c> - (+ <c> 1)
        ^pow-ten <pow-ten> - (* <pow-ten> 10)
        ^intermediate <i> -)
   (<r> ^<word-current> <digit-i>)
}
sp {power*elaborate*substate
   (state <s> ^superstate.operator <so>)
   (<so> ^type power
         ^x <x>
         ^y <y>)
-->
   (<s> ^name power
        ^x <x>
        ^y <y>)
}
sp {power*propose*power-init
   (state <s> ^name power
             -^result)
-->
   (<s> ^operator <op> + =)
   (<op> ^name power-init)
}
sp {apply*power-init
   (state <s> ^operator <op>)
   (<op> ^name power-init)
-->
   (<s> ^result 1
        ^current 0)
}
sp {power*propose*power-done
   (state <s> ^name power
              ^current <y>
              ^y <y>)
-->
   (<s> ^operator <op> + =)
   (<op> ^name power-done)
}
sp {apply*power-done
   (state <s> ^operator <op>
              ^superstate.operator <ss-op>
              ^result <r>)
   (<op> ^name power-done)
-->
   (<ss-op> ^result <r>)
}
sp {power*propose*power-next
   (state <s> ^name power
              ^current <c>
              ^y {<> <c>})
-->
   (<s> ^operator <op> + =)
   (<op> ^name power-next)
}
sp {apply*power-next
   (state <s> ^operator <op>
              ^current <c>
              ^x <x>
              ^result <r>)
   (<op> ^name power-next)
-->
   (<s> ^result <r> -
        ^result (* <r> <x>)
        ^current <c> -
        ^current (+ <c> 1))
}
sp {count-epmem*propose*recording
   (state <s> ^name count-epmem
              ^mode recording
              ^episode <ep>
              ^max {<> <ep>})
-->
   (<s> ^operator <op> + =)
   (<op> ^name recording)
}
sp {apply*recording*clean-old
   (state <s> ^operator <op>
              ^io.output-link <out>
              ^episode <ep>
              ^symbolic <sym>)
   (<op> ^name recording)
   (<out> ^record {<> <ep> <ep-old>})
   (<sym> ^episode <ep-old>)
-->
   (<out> ^record <ep-old> -)
   (<s> ^symbolic <sym> -)
}
sp {apply*recording*copy-symbolic
   (state <s> ^operator <op>
              ^episode <ep>
              ^convert-result <r>)
   (<op> ^name recording)
-->
   (<s> ^symbolic.converted <c>)
}
sp {apply*recording*copy-result
   (state <s> ^operator <op>
              ^convert-result.<digit-name> <digit>
              ^symbolic.converted <c>)
   (<op> ^name recording)
-->
   (<c> ^<digit-name> <digit>)
}
sp {apply*recording*sym-episode
   (state <s> ^operator <op>
              ^symbolic <sym>
              ^episode <ep>
              ^convert-result <r>)
   (<op> ^name recording)
   (<sym> ^converted <c>)
  -{(<r> ^<attr> <val>)
   -(<c> ^<attr> <val>)}
-->
   (<sym> ^episode <ep>)
}
sp {apply*recording*done
   (state <s> ^operator <op>
              ^episode <ep>
              ^symbolic.episode <ep>
              ^io.output-link <out>
              ^convert-result <r>)
   (<op> ^name recording)
-->
   (<s> ^episode <ep> - (+ <ep> 1)
        ^convert-result <r> -)
   (<out> ^record <ep>)
}
sp {count-epmem*propose*done
   (state <s> ^name count-epmem
              ^mode testing
              ^counter <ct>
              ^max <ct>)
-->
   (<s> ^operator <op> + =)
   (<op> ^name done)
}
sp {apply*done
   (state <s> ^operator <op>)
   (<op> ^name done)
-->
   (write |COUNTING TEST SUCCEEDED!|)
   (halt)
}
sp {count-epmem*propose*switch
   (state <s> ^name count-epmem
              ^mode recording
              ^episode <max>
              ^max <max>)
-->
   (<s> ^operator <op> + =)
   (<op> ^name switch)
}
sp {apply*switch*ep*increment
   (state <s> ^operator <op>
              ^mode recording
              ^episode <max>
              ^test-mode increment)
   (<op> ^name switch)
-->
   (<s> ^episode <max> - 1)
}
sp {apply*switch*ep*single
   (state <s> ^operator <op>
              ^mode recording
              ^episode <max>
              ^test-mode single
              ^test-ep <test-ep>)
   (<op> ^name switch)
-->
   (<s> ^episode <max> - <test-ep>)
}
sp {apply*switch*ready
   (state <s> ^operator <op>
              ^symbolic <sym>
              ^io.output-link <out>
              ^mode recording
              ^episode <max>)
   (<op> ^name switch)
   (<out> ^record <old>)
   (<sym> ^episode <old>)
-->
   (<s> ^symbolic <sym> -
        ^mode recording - testing
        ^counter 1)
   (<out> ^record <old> -)
   (write |STORAGE DONE (| <max> | episodes) - READY TO BEGIN QUERY|)
   (interrupt)
}
sp {propose*initialize-count-epmem
   (state <s> ^superstate nil
             -^name)
-->
   (<s> ^operator <o> +)
   (<o> ^name initialize-count-epmem)
}
sp {apply*initialize-count-epmem
   (state <s> ^operator <op>)
   (<op> ^name initialize-count-epmem)
-->
   (<s> ^name count-epmem
        ^digit <d0> <d1> <d2> <d3> <d4> <d5> <d6> <d7> <d8> <d9>        
        ^episode 1
        ^mode storing           # << storing recording >> set to storing to convert all digits to long-term identifiers before recording episodes
        ^size <d2>              # set to a digit identifier to determine number of stored episodes/test queries (max = 10^(size.number)-1)
        ^test-mode increment    # << increment single >>
        ^test-ep 1)             # if single, the episode to test
   (<d0> ^word zero
         ^number 0
         ^next <d1>
         ^previous nil)
   (<d1> ^word one
         ^number 1
         ^next <d2>
         ^previous <d0>)
   (<d2> ^word two
         ^number 2
         ^next <d3>
         ^previous <d1>)
   (<d3> ^word three
         ^number 3
         ^next <d4>
         ^previous <d2>)
   (<d4> ^word four
         ^number 4
         ^next <d5>
         ^previous <d3>)
   (<d5> ^word five
         ^number 5
         ^next <d6>
         ^previous <d4>)
   (<d6> ^word six
         ^number 6
         ^next <d7>
         ^previous <d5>)
   (<d7> ^word seven
         ^number 7
         ^next <d8>
         ^previous <d6>)
   (<d8> ^word eight
         ^number 8
         ^next <d9>
         ^previous <d7>)
   (<d9> ^word nine
         ^number 9
         ^next nil
         ^previous <d8>)
}
sp {recording*propose*recording-convert
   (state <s> ^name recording
              ^superstate <ss>)
   (<ss> ^episode <ep>
         ^size.number <size>)
-->
   (<s> ^operator <op> + =)
   (<op> ^name recording-convert
         ^type convert
         ^number <ep>
         ^places <size>)
}
sp {apply*recording-convert
   (state <s> ^operator <op>
              ^convert-result <r>
              ^superstate <ss>)
   (<op> ^name recording-convert)
-->
   (<ss> ^convert-result <r>)
}
sp {count-epmem*propose*testing
   (state <s> ^name count-epmem
              ^mode testing
              ^counter <ct>
              ^max {<> <ct>})
-->
   (<s> ^operator <op> + =)
   (<op> ^name testing)
}
sp {apply*testing*copy-symbolic
   (state <s> ^operator <op>
              ^episode <ep>
              ^convert-result <r>
              ^epmem.command <cmd>)
   (<op> ^name testing)
-->
   (<cmd> ^query <q>)
   (<q> ^symbolic <sym>)
   (<sym> ^episode <ep>
          ^converted <c>)
}
sp {apply*testing*copy-result*cue
   (state <s> ^operator <op>
              ^convert-result.<digit-name> <digit>
              ^epmem.command.query.symbolic.converted <c>
             -^lti t)
   (<op> ^name testing)
   (<digit> ^cue <digit-cue>)
-->
   (<c> ^<digit-name> <digit-cue>)
}
sp {apply*testing*copy-result*lti
   (state <s> ^operator <op>
              ^convert-result.<digit-name> <digit>
              ^epmem.command.query.symbolic.converted <c>
              ^lti t)
   (<op> ^name testing)
-->
   (<c> ^<digit-name> <digit>)
}
sp {apply*testing*next
   (state <s> ^operator <op>
              ^epmem <epmem>
              ^convert-result <r>
              ^counter <ct>)
   (<op> ^name testing)
   (<epmem> ^command <cmd>
            ^result.graph-match 1)   
   (<cmd> ^query <q>)
-->
   (<s> ^convert-result <r> -
        ^counter <ct> - (+ <ct> 1))
   (<cmd> ^query <q> -)
}
sp {apply*testing*next*increment
   (state <s> ^operator <op>
              ^epmem.result.graph-match 1
              ^test-mode increment
              ^episode <ep>)
   (<op> ^name testing)
-->
   (<s> ^episode <ep> - (+ <ep> 1))
}
sp {count-epmem*propose*max
   (state <s> ^name count-epmem
              ^size.number <size>
             -^max)
-->
   (<s> ^operator <op> + =)
   (<op> ^name max
         ^type power
         ^x 10
         ^y <size>)
}
sp {apply*max
   (state <s> ^operator <op>)
   (<op> ^name max
         ^result <r>)
-->
   (<s> ^max <r>)
}
smem --set timers off
smem --set learning on
epmem --set trigger output
epmem --set phase output
epmem --set graph-match on
epmem --set timers off
epmem --set learning on
watch 0
timers --off
learn --on
sp {top-state*elaborate*missionaries-and-cannibals
	(state <s> ^superstate nil)
	-->
	(<s> ^name mac)}
sp {mac*elaborate*problem-space
	(state <s> ^name mac)
	-->
	(<s> ^problem-space <p>)
	(<p> ^name missionaries-and-cannibals
		  ^default-state-copy yes
		  ^two-level-attributes right-bank left-bank)}
sp {mac*elaborate*initial-state
	(state <s> ^superstate nil
				  ^name mac)
	-->
	(<s> ^right-bank <r> 
		  ^left-bank <l>
		  ^desired <d>)
	(<r> ^missionaries 0
		  ^cannibals 0
		  ^boat 0
		  ^other-bank <l>)
	(<l> ^missionaries 3
		  ^cannibals 3
		  ^boat 1
  		  ^other-bank <r>)
   (<d> ^right-bank <dl>)
   (<dl> ^missionaries 3
         ^cannibals 3
         ^boat 1)
	}
sp {mac*propose*operator*move-mac-boat1
	"Moves either a single missionary or a cannibal."
   (state <s> ^name mac
              ^<< right-bank left-bank >> <bank>)
   (<bank> ^{ << cannibals missionaries >> <type> } > 0
           ^boat 1)
   -->
   (<s> ^operator <o>)
   (<o> ^name move-mac-boat
        ^bank <bank>
        ^<type> 1
        ^boat 1
        ^types 1)}
sp {mac*propose*operator*move-mac-boat2
	"Moves two missionaries or two cannibals."
   (state <s> ^name mac
              ^ << right-bank left-bank >> <bank>)
   (<bank> ^{ << cannibals missionaries >> <type> } > 1
           ^boat 1)
   -->
   (<s> ^operator <o>)
   (<o> ^name move-mac-boat
        ^bank <bank>
        ^<type> 2
        ^boat 1
        ^types 1)}
sp {mac*propose*operator*move-mac-boat11
   (state <s> ^name mac
              ^ << right-bank left-bank >> <bank>)
   (<bank> ^missionaries > 0
           ^cannibals > 0
           ^boat 1)
   -->
   (<s> ^operator <o>)
   (<o> ^name move-mac-boat
        ^bank <bank>
        ^missionaries 1
        ^cannibals 1
        ^boat 1
        ^types 2)}
sp {apply*move-mac-boat
   (state <s> ^operator <o>)
   (<o> ^name move-mac-boat
        ^{ << missionaries cannibals boat >> <type> } <num>
        ^bank <bank>
		  ^types <types>)
   (<bank> ^<type> <bank-num> 
           ^other-bank <obank>)
   (<obank> ^<type> <obank-num>)
   -->
   (<bank> ^<type> <bank-num> -
                   (- <bank-num> <num>))
   (<obank> ^<type> <obank-num> -
                    (+ <obank-num> <num>))}
sp {monitor*move-mac-boat
   (state <s> ^operator <o>)
   (<o> ^name move-mac-boat
        ^{ << cannibals missionaries >>  <type> } <number>)
   -->
   (write (crlf) | Move | <number> | | <type>)}
sp {monitor*state*left
   (state <s> ^name mac
              ^left-bank <l>
              ^right-bank <r>)
   (<l> ^missionaries <ml>
        ^cannibals <cl>
        ^boat 1)
   (<r> ^missionaries <mr>
        ^cannibals <cr>
        ^boat 0)
   -->
   (write (crlf) | M: | <ml> |, C: | <cl> | B ~~~   | 
                 | M: | <mr> |, C: | <cr> |  |)}
sp {monitor*state*right
   (state <s> ^name mac
              ^left-bank <l>
              ^right-bank <r>)
   (<l> ^missionaries <ml>
        ^cannibals <cl>
        ^boat 0)
   (<r> ^missionaries <mr>
        ^cannibals <cr>
        ^boat 1)
   -->
   (write (crlf) | M: | <ml> |, C: | <cl> |   ~~~ B | 
                 | M: | <mr> |, C: | <cr> |  |)}
sp {mac*detect*state*success
   (state <s> ^desired <d>
              ^<bank> <ls>)
   (<ls> ^missionaries <m>
         ^cannibals <c>)
   (<d> ^{ << right-bank left-bank >> <bank> } <dls>)
   (<dls> ^missionaries <m>
          ^cannibals <c>)
   -->
   (<s> ^success <d>)
   (write (crlf) |Success!|)}
sp {mac*evaluate*state*failure*more*cannibals
   (state <s> ^desired <d>
              ^<< right-bank left-bank >> <bank>)
   (<bank> ^missionaries { <n> > 0 }
           ^cannibals > <n>)
   -->
	(write (crlf) |Failure!|)
   (<s> ^failure <d>)}
sp {mac*evaluate*state*failure*state-no-change
    (state <s> ^desired <d>
               ^problem-space.name missionaries-and-cannibals)
    (state <ss> ^superstate <s>
                ^attribute state
                ^quiescence t
                ^impasse no-change)
-->
	(write (crlf) |######## STATE NO-CHANGE Failure! #########|)
    (<s> ^failure <d>)}
sp {mac*evaluate*state*failure*duplicate
	(state <s1> ^desired <d>
					^right-bank <rb>
					^left-bank <lb>)
	(<rb> ^missionaries <rbm> ^cannibals <rbc> ^boat <rbb>)
	(<lb> ^missionaries <lbm> ^cannibals <lbc> ^boat <lbb>)
	(state { <> <s1> <s2> } 
			 ^right-bank <rb2>
			 ^left-bank <lb2>
			 ^tried-tied-operator)
	(<rb2> ^missionaries <rbm> ^cannibals <rbc> ^boat <rbb>)
	(<lb2> ^missionaries <lbm> ^cannibals <lbc> ^boat <lbb>)
  -(state <s3> ^superstate <s2>)
	-->
   (write (crlf) |Duplicate State Detected.|)
	(<s2> ^failure <d>)}
sp {monitor*move-mac-boat*evaluation
   (state <s> ^operator <o>)
	(<o> ^name evaluate-operator
		  ^operator <to>)
   (<to> ^name move-mac-boat
        ^{ << cannibals missionaries >>  <type> } <number>)
   -->
   (write (crlf) | Evaluate move | <number> | | <type>)}
sp {elaborate*top-state*name
  (state <s> ^superstate nil)
-->
  (<s> ^name mac)
}
sp {monitor*move-boat
   (state <s> ^operator <o>)
   (<o> ^name move-boat
        ^{ << cannibals missionaries >>  <type> } <number>)
   -->
   (write (crlf) | Move | <number> | | <type>)}
sp {monitor*state*left
   (state <s> ^name mac
              ^left-bank <l>
              ^right-bank <r>)
   (<l> ^missionaries <ml>
        ^cannibals <cl>
        ^boat 1)
   (<r> ^missionaries <mr>
        ^cannibals <cr>
        ^boat 0)
   -->
   (write (crlf) | M: | <ml> |, C: | <cl> | B ~~~   | 
                 | M: | <mr> |, C: | <cr> |  |)}
sp {monitor*state*right
   (state <s> ^name mac
              ^left-bank <l>
              ^right-bank <r>)
   (<l> ^missionaries <ml>
        ^cannibals <cl>
        ^boat 0)
   (<r> ^missionaries <mr>
        ^cannibals <cr>
        ^boat 1)
   -->
   (write (crlf) | M: | <ml> |, C: | <cl> |   ~~~ B | 
                 | M: | <mr> |, C: | <cr> |  |)}
sp {mac*detect*state*success
   (state <s> ^desired <d>
              ^<bank> <ls>)
   (<ls> ^missionaries <m>
         ^cannibals <c>)
   (<d> ^{ << right-bank left-bank >> <bank> } <dls>)
   (<dls> ^missionaries <m>
          ^cannibals <c>)
   -->
   (<s> ^success <d>)
   (write (crlf) |Success!|)}
sp {mac*evaluate*state*failure*more*cannibals
   (state <s> ^desired <d>
              ^<< right-bank left-bank >> <bank>)
   (<bank> ^missionaries { <n> > 0 }
           ^cannibals > <n>)
   -->
   (write (crlf) |Failure!|)
   (<s> ^failure <d>)}
sp {mac*elaborate*problem-space
   (state <s> ^name mac)
-->
   (<s> ^problem-space <p>)
   (<p> ^name missionaries-and-cannibals
        ^default-state-copy yes
        ^two-level-attributes right-bank left-bank)}
sp {mac*propose*initialize
   (state <s> ^superstate nil
             -^name)
-->
   (<s> ^operator <o> + =)
   (<o> ^name initialize-mac-planning)
}
sp {mac*apply*initialize
   (state <s> ^operator.name initialize-mac-planning)
-->
   (<s> ^name mac
        ^left-bank <l>
        ^right-bank <r>
        ^desired <d>)
   (<l> ^missionaries 3
        ^cannibals 3
        ^boat 1
        ^other-bank <r>)
   (<r> ^missionaries 0
        ^cannibals 0
        ^boat 0
        ^other-bank <l>)
   (<d> ^right-bank <dl>)
   (<dl> ^missionaries 3
         ^cannibals 3
         ^boat 1)
}
sp {mac*propose*initialize
   (state <s> ^name mac
             -^left-bank)
-->
   (<s> ^operator <o> + =)
   (<o> ^name initialize)
}
sp {mac*apply*initialize
   (state <s> ^operator.name initialize)
-->
   (<s> ^name mac
        ^left-bank <l>
        ^right-bank <r>
        ^desired <d>)
   (<l> ^missionaries 3
        ^cannibals 3
        ^boat 1
        ^other-bank <r>)
   (<r> ^missionaries 0
        ^cannibals 0
        ^boat 0
        ^other-bank <l>)
   (<d> ^right-bank <dl>)
   (<dl> ^missionaries 3
         ^cannibals 3
         ^boat 1)
}
warnings --off
sp {mac*evaluate*state*failure*duplicate
   (state <s1> ^desired <d>
               ^right-bank <rb>
               ^left-bank <lb>)
   (<rb> ^missionaries <rbm> ^cannibals <rbc> ^boat <rbb>)
   (<lb> ^missionaries <lbm> ^cannibals <lbc> ^boat <lbb>)
   ( { <> <s1> <s2> } 
          ^right-bank <rb2>
          ^left-bank <lb2>
          ^tried-tied-operator)
   (<rb2> ^missionaries <rbm> ^cannibals <rbc> ^boat <rbb>)
   (<lb2> ^missionaries <lbm> ^cannibals <lbc> ^boat <lbb>)
  -(state <s3> ^superstate <s2>)
   -->
   (write (crlf) |Duplicate State Detected.|)
   (<s2> ^failure <d>)}
warnings --on
sp {mac*evaluate*state*failure*state-no-change
    (state <s> ^desired <d>
               ^problem-space.name missionaries-and-cannibals)
    (state <ss> ^superstate <s>
                ^attribute state
                ^quiescence t
                ^impasse no-change)
-->
  (write (crlf) |######## STATE NO-CHANGE Failure! #########|)
    (<s> ^failure <d>)}
sp {monitor*move-mac-boat*evaluation
   (state <s> ^operator <o>)
   (<o> ^name evaluate-operator
        ^operator <to>)
   (<to> ^name move-boat
        ^{ << cannibals missionaries >>  <type> } <number>)
   -->
   (write (crlf) | Evaluate move | <number> | | <type>)}
sp {mac*propose*operator*move-boat1
   "Moves either a single missionary or a cannibal."
   (state <s> ^name mac
              ^<< right-bank left-bank >> <bank>)
   (<bank> ^{ << cannibals missionaries >> <type> } > 0
           ^boat 1)
-->
   (<s> ^operator <o> +)
   (<o> ^name move-boat
        ^bank <bank>
        ^<type> 1
        ^boat 1
        ^types 1)}
sp {mac*propose*operator*move-boat2
   "Moves two missionaries or two cannibals."
   (state <s> ^name mac
              ^ << right-bank left-bank >> <bank>)
   (<bank> ^{ << cannibals missionaries >> <type> } > 1
           ^boat 1)
-->
   (<s> ^operator <o> +)
   (<o> ^name move-boat
        ^bank <bank>
        ^<type> 2
        ^boat 1
        ^types 1)}
sp {mac*propose*operator*move-boat11
   (state <s> ^name mac
              ^ << right-bank left-bank >> <bank>)
   (<bank> ^missionaries > 0
           ^cannibals > 0
           ^boat 1)
-->
   (<s> ^operator <o> +)
   (<o> ^name move-boat
        ^bank <bank>
        ^missionaries 1
        ^cannibals 1
        ^boat 1
        ^types 2)}
sp {apply*move-boat
   (state <s> ^operator <o>)
   (<o> ^name move-boat
        ^{ << missionaries cannibals boat >> <type> } <num>
        ^bank <bank>
        ^types <types>)
   (<bank> ^<type> <bank-num>
           ^other-bank <obank>)
   (<obank> ^<type> <obank-num>)
-->
   (<bank> ^<type> <bank-num> -
                   (- <bank-num> <num>))
   (<obank> ^<type> <obank-num> -
                    (+ <obank-num> <num>))}
learn --on
multi-attributes holds 3
learn --off
sp {mac*propose*initialize
   (state <s> ^superstate nil
             -^name)
-->
   (<s> ^operator <o> + =)
   (<o> ^name initialize-mac)
}
sp {mac*apply*initialize
   (state <s> ^operator.name initialize-mac)
-->
   (<s> ^name mac
        ^holds <h1> <h2> <h3> <h4> 
		  ^boat <leftbank>
		  ^desired <d>)
	(<h1> ^type missionaries 
			^number 3
			^opposite <h3>
			^side <leftbank>)
	(<h2> ^type cannibals 
			^number 3
			^opposite <h4>
			^side <leftbank>)
	(<h3> ^type missionaries
			^number 0
			^opposite <h1>
			^side <rightbank>)
	(<h4> ^type cannibals 
			^number 0
			^opposite <h2>
			^side <rightbank>)
	(<leftbank> ^name leftbank
					^opposite-of <rightbank>)
	(<rightbank> ^name rightbank
					 ^opposite-of <leftbank>)
	}
sp {mac*elaborate*problem-space
	(state <s> ^name mac)
	-->
	(<s> ^problem-space <p>)
	(<p> ^name missionaries-and-cannibals
		  ^default-state-copy yes
		  ^one-level-attributes boat
		  ^two-level-attributes holds)}
sp {mac*propose*operator*move1
	"Moves either a single missionary or a cannibal."
	(state <s> ^problem-space.name missionaries-and-cannibals
				  ^holds <h1> 
				  ^boat <f>)
	(<h1> ^number { <n> <> 0 }
			^side <f>)
	-->
	(<s> ^operator <o>)
	(<o> ^name move1
		  ^holds <h1>)}
sp {mac*propose*operator*move2
	"Moves either a single missionary or a cannibal."
	(state <s> ^problem-space.name missionaries-and-cannibals
				  ^holds <h1> 
				  ^boat <f>)
	(<h1> ^number > 1
			^side <f>)
	-->
	(<s> ^operator <o>)
	(<o> ^name move2
		  ^holds <h1>)}
sp {mac*propose*operator*move11
    "Moves either a single missionary or a cannibal."
    (state <s> ^problem-space.name missionaries-and-cannibals
               ^holds <h1> <h2>
               ^boat <f>)
    (<h1> ^type cannibals
          ^number { <n1> <> 0}
          ^side <f>)
    (<h2> ^type missionaries
          ^number { <n2> <> 0 }
          ^side <f>)
    -->
    (<s> ^operator <o>)
    (<o> ^name move11
         ^holds <h1> <h2>)}
sp {apply*move1
	(state <s> ^operator <o>)
	(<o> ^name << move1 move11 >>
		  ^holds <h1>)
	(<h1> ^number <r1> 
			^opposite <il>)
	(<il> ^number <l1>)
	-->
	(<h1> ^number <r1> -
			(- <r1> 1))
	(<il> ^number <l1> -
			(+ <l1> 1))}
sp {apply*move2
	(state <s> ^operator <o>)
	(<o> ^name move2
		  ^holds <h1>)
	(<h1> ^number <r1> 
			^opposite <h2>)
	(<h2> ^number <l1>)
	-->
	(<h1> ^number <r1> -
			(- <r1> 2))
	(<h2> ^number <l1> -
			(+ <l1> 2))}
sp {apply*move-boat
	(state <s> ^operator <o>
				  ^boat <x>)
	(<o> ^name << move1 move2 move11 >>
		  ^holds.side <x>)
	(<x> ^opposite-of <y>)
	-->
	(<s> ^boat <y> <x> -)}
sp {monitor*move1
	(state <s> ^operator <o>)
	(<o> ^name << move1 move11 >>
		  ^holds.type <m>)
	-->
	(write (crlf) | Move one | <m>)}
sp {monitor*move2
	(state <s> ^operator <o>)
	(<o> ^name move2
		  ^holds.type <m>)
	-->
	(write (crlf) | Move two | <m>)}
sp {monitor*move-side
	(state <s> ^operator <o>)
	(<o> ^name << move1 move2 move11 >>
		  ^holds.side <x>)
	(<x> ^opposite-of.name <side2> 
		  ^name <side1>)
	-->
	(write (crlf) | From | <side1> | to | <side2>)}
sp {mac*evaluate*state*failure*more*cannibals
	(state <s> ^desired <d>
				  ^holds <h1> <h2>)
	(<h1> ^type missionaries
			^number { <n> > 0 }
			^side <loc>)
	(<h2> ^type cannibals
			^number > <n>
			^side <loc>)
	-->
	(<s> ^failure <d>)
      (write (crlf) |Failure - too many cannibals on side:| <loc>)}
sp {mac*evaluate*state*failure*state-no-change
	(state <s> ^desired <d>
				  ^problem-space.name missionaries-and-cannibals)
	(state <ss> ^superstate <s>
					^attribute state
					^quiescence t
					^impasse no-change)
	-->
	(<s> ^failure <d>)
      (write (crlf) |Failure - no operators can apply.|)}
sp {mac*evaluate*state*failure*detect-state-duplicate
	(state <s> ^holds <a1> <a2>
				  ^desired <d>)
	(<a1> ^type missionaries 
			^number 0
			^side <side>)
	(<a2> ^type cannibals
			^number 0
			^side <side>)
	(state { <> <s> <ss> } ^desired <d>
			^holds <b1> <b2>
			^tried-tied-operator)
	(<b1> ^type missionaries
			^number 0
			^side <side>)
	(<b2> ^type cannibals
			^number 0
			^side <side>)
  -(state <sss> ^superstate <ss>)
	-->
	(<ss> ^failure <d>)
      (write (crlf) |Failure - Duplicate State.|)}
 ## This also defines implicitly the desired state
 ## of the problem.
  #
sp {mac*detect*state*success
	(state <s> ^desired <d>
				  ^holds <h1> <h2>)
	(<h1> ^type missionaries 
			^number 3
			^side <loc>)
	(<h2> ^type cannibals 
			^number 3
			^side <loc>)
	(<loc> ^name rightbank)
	-->
	(<s> ^success <d>)
      (write (crlf) |Success.|)}
sp {monitor*move-mac-boat
   (state <s> ^operator <o>)
   (<o> ^name move-mac-boat
        ^{ << cannibals missionaries >>  <type> } <number>)
   -->
   (write (crlf) | Move | <number> | | <type>)}
sp {monitor*state*left
   (state <s> ^name mac
              ^left-bank <l>
              ^right-bank <r>)
   (<l> ^missionaries <ml>
        ^cannibals <cl>
        ^boat 1)
   (<r> ^missionaries <mr>
        ^cannibals <cr>
        ^boat 0)
   -->
   (write (crlf) | M: | <ml> |, C: | <cl> | B ~~~   | 
                 | M: | <mr> |, C: | <cr> |  |)}
sp {monitor*state*right
   (state <s> ^name mac
              ^left-bank <l>
              ^right-bank <r>)
   (<l> ^missionaries <ml>
        ^cannibals <cl>
        ^boat 0)
   (<r> ^missionaries <mr>
        ^cannibals <cr>
        ^boat 1)
   -->
   (write (crlf) | M: | <ml> |, C: | <cl> |   ~~~ B | 
                 | M: | <mr> |, C: | <cr> |  |)}
learn --off
sp {mac*elaborate*initial*desired-state
   (state <s> ^superstate nil)
   -->
   (<s> ^name mac
        ^left-bank <l>
        ^right-bank <r> 
        ^desired <d>)
   (<l> ^missionaries 3
        ^cannibals 3
        ^boat 1
        ^other-bank <r>)
   (<r> ^missionaries 0
        ^cannibals 0
		  ^boat 0
        ^other-bank <l>)
   (<d> ^right-bank <dl>)
   (<dl> ^missionaries 3
         ^cannibals 3
         ^boat 1)
   }
sp {mac*propose*operator*move-mac-boat1
	"Moves either a single missionary or a cannibal."
   (state <s> ^name mac
              ^<< right-bank left-bank >> <bank>)
   (<bank> ^{ << cannibals missionaries >> <type> } > 0
           ^boat 1)
   -->
   (<s> ^operator <o> + =)
   (<o> ^name move-mac-boat
        ^bank <bank>
        ^<type> 1
        ^boat 1
        ^types 1)}
sp {mac*propose*operator*move-mac-boat2
	"Moves two missionaries or two cannibals."
   (state <s> ^name mac
              ^ << right-bank left-bank >> <bank>)
   (<bank> ^{ << cannibals missionaries >> <type> } > 1
           ^boat 1)
   -->
   (<s> ^operator <o> + =)
   (<o> ^name move-mac-boat
        ^bank <bank>
        ^<type> 2
        ^boat 1
        ^types 1)}
sp {mac*propose*operator*move-mac-boat11
   (state <s> ^name mac
              ^ << right-bank left-bank >> <bank>)
   (<bank> ^missionaries > 0
           ^cannibals > 0
           ^boat 1)
   -->
   (<s> ^operator <o> + =)
   (<o> ^name move-mac-boat
        ^bank <bank>
        ^missionaries 1
        ^cannibals 1
        ^boat 1
        ^types 2)}
sp {apply*move-mac-boat
   (state <s> ^operator <o>)
   (<o> ^name move-mac-boat
        ^{ << missionaries cannibals boat >> <type> } <num>
        ^bank <bank>)
   (<bank> ^<type> <bank-num> 
           ^other-bank <obank>)
   (<obank> ^<type> <obank-num>)
   -->
   (<bank> ^<type> <bank-num> -
                   (- <bank-num> <num>))
   (<obank> ^<type> <obank-num> -
                    (+ <obank-num> <num>))}
sp {monitor*move-mac-boat
   (state <s> ^operator <o>)
   (<o> ^name move-mac-boat
        ^{ << cannibals missionaries >>  <type> } <number>)
   -->
   (write (crlf) | Move | <number> | | <type>)}
sp {monitor*state*left
   (state <s> ^name mac
              ^left-bank <l>
              ^right-bank <r>)
   (<l> ^missionaries <ml>
        ^cannibals <cl>
        ^boat 1)
   (<r> ^missionaries <mr>
        ^cannibals <cr>
        ^boat 0)
   -->
   (write (crlf) | M: | <ml> |, C: | <cl> | B ~~~   | 
                 | M: | <mr> |, C: | <cr> |  |)}
sp {monitor*state*right
   (state <s> ^name mac
              ^left-bank <l>
              ^right-bank <r>)
   (<l> ^missionaries <ml>
        ^cannibals <cl>
        ^boat 0)
   (<r> ^missionaries <mr>
        ^cannibals <cr>
        ^boat 1)
   -->
   (write (crlf) | M: | <ml> |, C: | <cl> |   ~~~ B | 
                 | M: | <mr> |, C: | <cr> |  |)}
sp {mac*detect*state*success
   (state <s> ^desired <d>
              ^<side> <ls>)
   (<ls> ^missionaries <m>
         ^cannibals <c>)
   (<d> ^{ << right-bank left-bank >> <side> } <dls>)
   (<dls> ^missionaries <m>
          ^cannibals <c>)
   -->
   (write (crlf) |The problem has been solved.|)
   (halt)}
sp {mac*evaluate*state*failure*more*cannibals
   (state <s> ^desired <d>
              ^<< right-bank left-bank >> <bank>)
   (<bank> ^missionaries { <n> > 0 }
           ^cannibals > <n>)
   -->
	(write (crlf) |Failure State.|)
   (<s> ^failure <d>)}
sp {mac*apply*move-mac-boat*record*last-operator*types*1
   (state <s> ^name mac
              ^operator <o>)
   (<o> ^name move-mac-boat
        ^bank <bank>
        ^{ << missionaries cannibals >> <type> } <n>
        ^types 1)
   -->
   (<s> ^last-operator <o1>)
   (<o1> ^types 1
         ^bank <bank>
         ^type <type>
         ^number <n>)}
sp {mac*apply*move-mac-boat*record*last-operator*types*2
   (state <s> ^name mac
              ^operator <o>)
   (<o> ^name move-mac-boat
        ^boat <bank>
        ^types 2)
   -->
   (<s> ^last-operator <o1>)
   (<o1> ^types 2
         ^bank <bank>)}
sp {mac*apply*move-mac-boat*remove*old*last-operator
   (state <s> ^name mac
              ^operator <o>
              ^<lr-bank>.other-bank <o-bank>
              ^last-operator <lo>)
   (<lo> ^bank <obank>)
   -->
   (<s> ^last-operator <lo> -)}
sp {mac*select*operator*prefer*inverse*failure*types*1
   (state <s> ^name mac
              ^operator <o> +
              ^failure <d>
              ^last-operator <lo>)
   (<o> ^name move-mac-boat
        ^<type> <number>
        ^types 1)  
   (<lo> ^types 1
         ^type <type>
         ^number <number>)
   -->
   (<s> ^operator <o> >)}
sp {mac*select*operator*prefer*inverse*failure*types*2
   (state <s> ^name mac
              ^operator <o> +
              ^failure <d>
              ^last-operator.types 2)
   (<o> ^types 2)
   -->
   (<s> ^operator <o> >)}
sp {mac*select*operator*avoid*inverse*not*failure*1
   (state <s> ^name mac
              ^operator <o> +
             -^failure <d>
              ^last-operator <lo>)
   (<o> ^types 1
        ^<type> <number>)
   (<lo> ^types 1
         ^type <type>
         ^number <number>)
   -->
   (<s> ^operator <o> < )}
sp {mac*select*operator*avoid*inverse*not*failure*2
   (state <s> ^name mac
              ^operator <o> +
             -^failure <d>
              ^last-operator.types 2)
   (<o> ^types 2)
   -->
	(<s> ^operator <o> < )}
sp {mac*select*operator*prefer*inverse*failure*types*1
   (state <s> ^name mac
              ^operator <o> +
              ^failure <d>
              ^last-operator <lo>)
   (<o> ^name move-boat
        ^<type> <number>
        ^types 1)
   (<lo> ^types 1
         ^type <type>
         ^number <number>)
-->
   (<s> ^operator <o> >)}
sp {mac*select*operator*prefer*inverse*failure*types*2
   (state <s> ^name mac
              ^operator <o> +
              ^failure <d>
              ^last-operator.types 2)
   (<o> ^types 2)
-->
   (<s> ^operator <o> >)}
sp {mac*select*operator*avoid*inverse*not*failure*1
   (state <s> ^name mac
              ^operator <o> +
             -^failure <d>
              ^last-operator <lo>)
   (<o> ^types 1
        ^<type> <number>)
   (<lo> ^types 1
         ^type <type>
         ^number <number>)
-->
   (<s> ^operator <o> < )}
sp {mac*select*operator*avoid*inverse*not*failure*2
   (state <s> ^name mac
              ^operator <o> +
             -^failure <d>
              ^last-operator.types 2)
   (<o> ^types 2)
-->
   (<s> ^operator <o> < )}
sp {monitor*move-boat
   (state <s> ^operator <o>)
   (<o> ^name move-boat
        ^{ << cannibals missionaries >>  <type> } <number>)
   -->
   (write (crlf) | Move | <number> | | <type>)}
sp {monitor*state*left
   (state <s> ^name mac
              ^left-bank <l>
              ^right-bank <r>)
   (<l> ^missionaries <ml>
        ^cannibals <cl>
        ^boat 1)
   (<r> ^missionaries <mr>
        ^cannibals <cr>
        ^boat 0)
   -->
   (write (crlf) | M: | <ml> |, C: | <cl> | B ~~~   | 
                 | M: | <mr> |, C: | <cr> |  |)}
sp {monitor*state*right
   (state <s> ^name mac
              ^left-bank <l>
              ^right-bank <r>)
   (<l> ^missionaries <ml>
        ^cannibals <cl>
        ^boat 0)
   (<r> ^missionaries <mr>
        ^cannibals <cr>
        ^boat 1)
   -->
   (write (crlf) | M: | <ml> |, C: | <cl> |   ~~~ B | 
                 | M: | <mr> |, C: | <cr> |  |)}
sp {mac*detect*state*success
   (state <s> ^desired <d>
              ^<side> <ls>)
   (<ls> ^missionaries <m>
         ^cannibals <c>)
   (<d> ^{ << right-bank left-bank >> <side> } <dls>)
   (<dls> ^missionaries <m>
          ^cannibals <c>)
-->
   (write (crlf) |The problem has been solved.|)
   (halt)}
sp {mac*evaluate*state*failure*more*cannibals
   (state <s> ^desired <d>
              ^<< right-bank left-bank >> <bank>)
   (<bank> ^missionaries { <n> > 0 }
           ^cannibals > <n>)
-->
   (write (crlf) |Failure State.|)
   (<s> ^failure <d>)}
sp {mac*propose*initialize
   (state <s> ^superstate nil
             -^name)
-->
   (<s> ^operator <o> + =)
   (<o> ^name initialize-mac)
}
sp {mac*apply*initialize
   (state <s> ^operator.name initialize-mac)
-->
   (<s> ^name mac
        ^left-bank <l>
        ^right-bank <r>
        ^desired <d>)
   (<l> ^missionaries 3
        ^cannibals 3
        ^boat 1
        ^other-bank <r>)
   (<r> ^missionaries 0
        ^cannibals 0
        ^boat 0
        ^other-bank <l>)
   (<d> ^right-bank <dl>)
   (<dl> ^missionaries 3
         ^cannibals 3
         ^boat 1)
}
sp {mac*propose*initialize
   (state <s> ^name mac
             -^left-bank)
-->
   (<s> ^operator <o> + =)
   (<o> ^name initialize)
}
sp {mac*apply*initialize
   (state <s> ^operator.name initialize)
-->
   (<s> ^name mac
        ^left-bank <l>
        ^right-bank <r>
        ^desired <d>)
   (<l> ^missionaries 3
        ^cannibals 3
        ^boat 1
        ^other-bank <r>)
   (<r> ^missionaries 0
        ^cannibals 0
        ^boat 0
        ^other-bank <l>)
   (<d> ^right-bank <dl>)
   (<dl> ^missionaries 3
         ^cannibals 3
         ^boat 1)
}
sp {mac*propose*operator*move-boat1
   "Moves either a single missionary or a cannibal."
   (state <s> ^name mac
              ^<< right-bank left-bank >> <bank>)
   (<bank> ^{ << cannibals missionaries >> <type> } > 0
           ^boat 1)
-->
   (<s> ^operator <o> + =)
   (<o> ^name move-boat
        ^bank <bank>
        ^<type> 1
        ^boat 1
        ^types 1)}
sp {mac*propose*operator*move-boat2
   "Moves two missionaries or two cannibals."
   (state <s> ^name mac
              ^ << right-bank left-bank >> <bank>)
   (<bank> ^{ << cannibals missionaries >> <type> } > 1
           ^boat 1)
-->
   (<s> ^operator <o> + =)
   (<o> ^name move-boat
        ^bank <bank>
        ^<type> 2
        ^boat 1
        ^types 1)}
sp {mac*propose*operator*move-boat11
   (state <s> ^name mac
              ^ << right-bank left-bank >> <bank>)
   (<bank> ^missionaries > 0
           ^cannibals > 0
           ^boat 1)
-->
   (<s> ^operator <o> + =)
   (<o> ^name move-boat
        ^bank <bank>
        ^missionaries 1
        ^cannibals 1
        ^boat 1
        ^types 2)}
sp {apply*move-boat
   (state <s> ^operator <o>)
   (<o> ^name move-boat
        ^{ << missionaries cannibals boat >> <type> } <num>
        ^bank <bank>)
   (<bank> ^<type> <bank-num>
           ^other-bank <obank>)
   (<obank> ^<type> <obank-num>)
-->
   (<bank> ^<type> <bank-num> -
                   (- <bank-num> <num>))
   (<obank> ^<type> <obank-num> -
                    (+ <obank-num> <num>))}
sp {mac*apply*move-boat*record*last-operator*types*1
   (state <s> ^name mac
              ^operator <o>)
   (<o> ^name move-boat
        ^bank <bank>
        ^{ << missionaries cannibals >> <type> } <n>
        ^types 1)
   -->
   (<s> ^last-operator <o1>)
   (<o1> ^types 1
         ^bank <bank>
         ^type <type>
         ^number <n>)}
sp {mac*apply*move-boat*record*last-operator*types*2
   (state <s> ^name mac
              ^operator <o>)
   (<o> ^name move-boat
        ^boat <bank>
        ^types 2)
   -->
   (<s> ^last-operator <o1>)
   (<o1> ^types 2
         ^bank <bank>)}
sp {mac*apply*move-boat*remove*old*last-operator
   (state <s> ^name mac
              ^operator <o>
              ^<lr-bank>.other-bank <o-bank>
              ^last-operator <lo>)
   (<lo> ^bank <obank>)
   -->
   (<s> ^last-operator <lo> -)}
learn --off
learn --on
sp {top-state*elaborate*missionaries-and-cannibals
	(state <s> ^superstate nil)
	-->
	(<s> ^name mac)}
sp {mac*elaborate*problem-space
	(state <s> ^name mac)
	-->
	(<s> ^problem-space <p>)
	(<p> ^name missionaries-and-cannibals
		  ^default-state-copy yes
		  ^two-level-attributes right-bank left-bank)}
sp {mac*elaborate*initial-state
   (state <s> ^superstate nil)
   -->
   (<s> ^right-bank <r> 
        ^left-bank <l>
        ^desired <d>)
   (<r> ^missionaries 0
        ^cannibals 0
        ^boat 0
        ^other-bank <l>)
   (<l> ^missionaries 3
        ^cannibals 3
        ^boat 1
        ^other-bank <r>)
   (<d> ^right-bank <dl>
        ^better higher)
   (<dl> ^missionaries 3
         ^cannibals 3
         ^boat 1)
   }
sp {mac*propose*operator*move-mac-boat1
   "Moves either a single missionary or a cannibal."
   (state <s> ^name mac
              ^<< right-bank left-bank >> <bank>)
   (<bank> ^{ << cannibals missionaries >> <type> } > 0
           ^boat 1)
   -->
   (<s> ^operator <o>)
   (<o> ^name move-mac-boat
        ^bank <bank>
        ^<type> 1
        ^boat 1
        ^types 1)}
sp {mac*propose*operator*move-mac-boat2
   "Moves two missionaries or two cannibals."
   (state <s> ^name mac
              ^ << right-bank left-bank >> <bank>)
   (<bank> ^{ << cannibals missionaries >> <type> } > 1
           ^boat 1)
   -->
   (<s> ^operator <o>)
   (<o> ^name move-mac-boat
        ^bank <bank>
        ^<type> 2
        ^boat 1
        ^types 1)}
sp {mac*propose*operator*move-mac-boat11
   (state <s> ^name mac
              ^ << right-bank left-bank >> <bank>)
   (<bank> ^missionaries > 0
           ^cannibals > 0
           ^boat 1)
   -->
   (<s> ^operator <o>)
   (<o> ^name move-mac-boat
        ^bank <bank>
        ^missionaries 1
        ^cannibals 1
        ^boat 1
        ^types 2)}
sp {apply*move-mac-boat
   (state <s> ^operator <o>)
   (<o> ^name move-mac-boat
        ^{ << missionaries cannibals boat >> <type> } <num>
        ^bank <bank>
        ^types <types>)
   (<bank> ^<type> <bank-num> 
           ^other-bank <obank>)
   (<obank> ^<type> <obank-num>)
   -->
   (<bank> ^<type> <bank-num> -
                   (- <bank-num> <num>))
   (<obank> ^<type> <obank-num> -
                    (+ <obank-num> <num>))}
sp {monitor*move-mac-boat
   (state <s> ^operator <o>)
   (<o> ^name move-mac-boat
        ^{ << cannibals missionaries >>  <type> } <number>)
   -->
   (write (crlf) | Move | <number> | | <type>)}
sp {monitor*state*left
   (state <s> ^name mac
              ^left-bank <l>
              ^right-bank <r>)
   (<l> ^missionaries <ml>
        ^cannibals <cl>
        ^boat 1)
   (<r> ^missionaries <mr>
        ^cannibals <cr>
        ^boat 0)
   -->
   (write (crlf) | M: | <ml> |, C: | <cl> | B ~~~   | 
                 | M: | <mr> |, C: | <cr> |  |)}
sp {monitor*state*right
   (state <s> ^name mac
              ^left-bank <l>
              ^right-bank <r>)
   (<l> ^missionaries <ml>
        ^cannibals <cl>
        ^boat 0)
   (<r> ^missionaries <mr>
        ^cannibals <cr>
        ^boat 1)
   -->
   (write (crlf) | M: | <ml> |, C: | <cl> |   ~~~ B | 
                 | M: | <mr> |, C: | <cr> |  |)}
sp {mac*detect*state*success
   (state <s> ^desired <d>
              ^<bank> <ls>)
   (<ls> ^missionaries <m>
         ^cannibals <c>)
   (<d> ^{ << right-bank left-bank >> <bank> } <dls>)
   (<dls> ^missionaries <m>
          ^cannibals <c>)
   -->
   (<s> ^success <d>)
   (write (crlf) |Success!|)}
sp {mac*evaluate*state*failure*more*cannibals
   (state <s> ^desired <d>
              ^<< right-bank left-bank >> <bank>)
   (<bank> ^missionaries { <n> > 0 }
           ^cannibals > <n>)
   -->
   (write (crlf) |Failure!|)
   (<s> ^failure <d>)}
sp {mac*evaluate*state*failure*duplicate
   (state <s1> ^desired <d>
               ^right-bank <rb>
               ^left-bank <lb>)
   (<rb> ^missionaries <rbm> ^cannibals <rbc> ^boat <rbb>)
   (<lb> ^missionaries <lbm> ^cannibals <lbc> ^boat <lbb>)
   (state { <> <s1> <s2> } 
          ^right-bank <rb2>
          ^left-bank <lb2>
          ^tried-tied-operator)
   (<rb2> ^missionaries <rbm> ^cannibals <rbc> ^boat <rbb>)
   (<lb2> ^missionaries <lbm> ^cannibals <lbc> ^boat <lbb>)
  -(state <s3> ^superstate <s2>)
   -->
   (write (crlf) |Duplicate State Detected.|)
   (<s2> ^failure <d>)}
sp {mac*evaluate*state*number
   (state <s> ^desired <d>
              ^tried-tied-operator
              ^<bank> <ls>)
   (<ls> ^missionaries <m>
         ^cannibals <c>)
   (<d> ^{ << right-bank left-bank >> <bank> } <dls>)
   -->
   (<s> ^numeric-value (+ <m> <c>))
   (write (crlf) |Evaluation: | (+ <m> <c>))}
sp {monitor*move-mac-boat*evaluation
   (state <s> ^operator <o>)
   (<o> ^name evaluate-operator
        ^operator <to>)
   (<to> ^name move-mac-boat
        ^{ << cannibals missionaries >>  <type> } <number>)
   -->
   (write (crlf) | Evaluate move | <number> | | <type>)}
learn --off
sp {mac*elaborate*state*name
   (state <s> ^superstate nil)
   -->
   (<s> ^name mac)}
sp {mac*elaborate*initial-state
   (state <s> ^name mac)
   -->
   (<s> ^missionaries <m>
        ^cannibals <c>
        ^boat <b>)
   (<b> ^left 1
        ^right 0) 
   (<m> ^left 3
        ^right 0)
   (<c> ^left 3
        ^right 0)
   }
sp {mac*propose*move-mac-boat*1
   "Moves either a single missionary or a cannibal."
   (state <s> ^name mac
              ^{ << cannibals missionaries >> <type> }.<bank> > 0
              ^boat.<bank> 1)
   -->
   (<s> ^operator <o> + =)
   (<o> ^name move-mac-boat
        ^types 1
        ^boat 1
        ^<type> 1)}
sp {mac*propose*move-mac-boat*2
   "Moves either a two missionaries or two cannibals."
   (state <s> ^name mac
              ^{ << cannibals missionaries >> <type> }.<bank> > 1
              ^boat.<bank> 1)
   -->
   (<s> ^operator <o> + =)
   (<o> ^name move-mac-boat
        ^types 1
        ^boat 1
        ^<type> 2)}
sp {mac*propose*move-mac-boat*11
   (state <s> ^name mac
              ^cannibals.<bank> > 0
              ^missionaries.<bank> > 0
              ^boat.<bank> 1)
   -->   
   (<s> ^operator <o> + =)
   (<o> ^name move-mac-boat
        ^types 2
        ^boat 1
        ^missionaries 1
        ^cannibals 1)}
sp {apply*move-mac-boat
   (state <s> ^operator <o>
              ^<type> <type-id>
              ^boat <b>)
   (<b> ^{ << left right >> <bank>  } 1
        ^{ << left right >> <obank> } 0)
   (<o> ^name move-mac-boat
        ^{ << boat missionaries cannibals >> <type> } <number>)
   (<type-id> ^<bank> <bank-num>
              ^<obank> <obank-num>)
   -->
   (<type-id> ^<bank> <bank-num> -
              (- <bank-num> <number>)
              ^<obank> <obank-num> -
              (+ <obank-num> <number>))}
sp {mac*apply*move-mac-boat*record*last-operator*types*1
   (state <s> ^name mac
              ^operator <o>
              ^boat.<bank> 1)
   (<o> ^name move-mac-boat
        ^{ << missionaries cannibals >> <type> } <n>
        ^types 1)
   -->
   (<s> ^last-operator <o1>)
   (<o1> ^boat <bank>
         ^types 1
         ^type <type>
         ^number <n>)}
sp {mac*apply*move-mac-boat*record*last-operator*types*2
   (state <s> ^name mac
              ^operator <o>
              ^boat.<bank> 1)
   (<o> ^name move-mac-boat
        ^types 2)
   -->
   (<s> ^last-operator <o1>)
   (<o1> ^types 2
         ^boat <bank>)}
sp {mac*apply*move-mac-boat*remove*old*last-operator
   (state <s> ^name mac
              ^operator.name move-mac-boat
              ^boat.<bank> 0
              ^last-operator <lo>)
   (<lo> ^boat <bank>)
   -->
   (<s> ^last-operator <lo> -)}
sp {mac*select*operator*inverse*failure*types*1
   (state <s> ^name mac
              ^operator <o> +
              ^failure true
              ^last-operator <lo>)
   (<o> ^name move-mac-boat
        ^<type> <number>
        ^types 1)  
   (<lo> ^types 1
         ^type <type>
         ^number <number>)
   -->
                                        # (write (crlf) |Undo last move.|)
   (<s> ^operator <o> > )}
sp {mac*select*operator*inverse*types*2
   (state <s> ^name mac
              ^operator <o> +
              ^failure true
              ^last-operator <lo>)
   (<o> ^types 2)
   (<lo> ^types 2)
   -->
   (<s> ^operator <o> > )}
sp {mac*select*operator*inverse*not*failure*types*1
   (state <s> ^name mac
              ^operator <o> +
             -^failure true
              ^last-operator <lo>)
   (<o> ^types 1
        ^<type> <number>)
   (<lo> ^types 1
         ^type <type>
         ^number <number>)
   -->
   (<s> ^operator <o> < )}
sp {mac*select*operator*inverse*not*failure*types*2
   (state <s> ^name mac
              ^operator <o> +
             -^failure true
              ^last-operator <lo>)
   (<o> ^types 2)
   (<lo> ^types 2)
   -->
   (<s> ^operator <o> < )}
sp {mac*evaluate*state*failure*more*cannibals
   (state <s> ^name mac
              ^missionaries <m>
              ^cannibals <c>)
   (<m> ^<bank> { <n> > 0 })
   (<c> ^<bank> > <n>)
   -->
   (write (crlf) |Failure State.|)
   (<s> ^failure true)}
 ## This implicitly defines the desired state of the problem.
  #
sp {mac*detect*state*success
   (state <s> ^name mac
              ^missionaries.right 3
              ^cannibals.right 3)
   -->
   (write (crlf) |Success!|)
   (halt)}
sp {monitor*move
   (state <s> ^name mac
              ^operator <o>)
   (<o> ^{ << missionaries cannibals >> <type> } <number>)
   -->
   (write | Move | <number> | | <type>)}
sp {monitor*state*left
   (state <s> ^name mac
              ^boat.left 1
              ^missionaries.left <ml>
              ^missionaries.right <mr>
              ^cannibals.left <cl>
              ^cannibals.right <cr>)
   -->
   (write (crlf) | M: | <ml> |, C: | <cl> | B ~~~   | 
                 | M: | <mr> |, C: | <cr> |  |)}
sp {monitor*state*right
   (state <s> ^name mac
              ^boat.right 1
              ^missionaries.left <ml>
              ^missionaries.right <mr>
              ^cannibals.left <cl>
              ^cannibals.right <cr>)
   -->
   (write (crlf) | M: | <ml> |, C: | <cl> |   ~~~ B | 
                 | M: | <mr> |, C: | <cr> |  |)}
sp {propose*hello-world
   (state <s> ^type state)
-->
   (<s> ^operator <o> +)
   (<o> ^name hello-world)
}
sp {apply*hello-world
   (state <s> ^operator <o>)
   (<o> ^name hello-world)
-->
   (write |Hello World|)
   (halt)
}
sp {eight*elaborate*problem-space
   (state <s> ^name fifteen-puzzle)
-->
   (<s> ^problem-space <p>)
   (<p> ^name fifteen-puzzle
        ^default-state-copy yes
        ^default-operator-copy no
        ^one-level-attributes blank-cell
        ^two-level-attributes binding)}
sp {eight*operator*move-tile*inverse*reject
   "Reject the operator that was applied to create this state."
   (state <s> ^problem-space.name fifteen-puzzle
              ^operator <o> +
              ^tile-cell <tc>)
   (<o> ^tile-cell <tc>)
-->
   (<s> ^operator <o> - )}
sp {eight*monitor*state
   (state <s> ^binding <x11> <x12> <x13> <x14>
                       <x21> <x22> <x23> <x24>
                       <x31> <x32> <x33> <x34>
                       <x41> <x42> <x43> <x44>)
   (<x11> ^cell.name c11 ^tile <o11>)
   (<o11> ^name <v11>)
   (<x12> ^cell.name c12 ^tile <o12>)
   (<o12> ^name <v12>)
   (<x13> ^cell.name c13 ^tile <o13>)
   (<o13> ^name <v13>)
   (<x14> ^cell.name c14 ^tile <o14>)
   (<o14> ^name <v14>)
   (<x21> ^cell.name c21 ^tile <o21>)
   (<o21> ^name <v21>)
   (<x22> ^cell.name c22 ^tile <o22>)
   (<o22> ^name <v22>)
   (<x23> ^cell.name c23 ^tile <o23>)
   (<o23> ^name <v23>)
   (<x24> ^cell.name c24 ^tile <o24>)
   (<o24> ^name <v24>)
   (<x31> ^cell.name c31 ^tile <o31>)
   (<o31> ^name <v31>)
   (<x32> ^cell.name c32 ^tile <o32>)
   (<o32> ^name <v32>)
   (<x33> ^cell.name c33 ^tile <o33>)
   (<o33> ^name <v33>)
   (<x34> ^cell.name c34 ^tile <o34>)
   (<o34> ^name <v34>)
   (<x41> ^cell.name c41 ^tile <o41>)
   (<o41> ^name <v41>)
   (<x42> ^cell.name c42 ^tile <o42>)
   (<o42> ^name <v42>)
   (<x43> ^cell.name c43 ^tile <o43>)
   (<o43> ^name <v43>)
   (<x44> ^cell.name c44 ^tile <o44>)
   (<o44> ^name <v44>)
-->
   (write (crlf)  |      ---------------------|  | | (crlf) | | )
   (write |     \||  | | <v11>  | | |\||  | | <v21>  | | |\||  | | <v31>  | | |\||  | | <v41>  | | |\||  | | (crlf) | | )
   (write |     \|----\|----\|----\|----\||  | | (crlf) | | )
   (write |     \||  | | <v12>  | | |\||  | | <v22>  | | |\||  | | <v32>  | | |\||  | | <v42>  | | |\||  | | (crlf) | | )
   (write |     \|----\|----\|----\|----\||  | | (crlf) | | )
   (write |     \||  | | <v13>  | | |\||  | | <v23>  | | |\||  | | <v33>  | | |\||  | | <v43>  | | |\||  | | (crlf) | | )
   (write |     \|----\|----\|----\|----\||  | | (crlf) | | )
   (write |     \||  | | <v14>  | | |\||  | | <v24>  | | |\||  | | <v34>  | | |\||  | | <v44>  | | |\||  | | (crlf) | | )
   (write |     ---------------------|  | | (crlf) | | )}
sp {eight*detect*state*success
   (state <s> ^problem-space.name fifteen-puzzle
              ^desired <d>
              ^binding <x11> <x12> <x13> <x14>
                       <x21> <x22> <x23> <x24>
                       <x31> <x32> <x33> <x34>
                       <x41> <x42> <x43> <x44>)
   (<x11> ^cell.name c11 ^tile <o11>)
   (<x12> ^cell.name c12 ^tile <o12>)
   (<x13> ^cell.name c13 ^tile <o13>)
   (<x14> ^cell.name c14 ^tile <o14>)
   (<x21> ^cell.name c21 ^tile <o21>)
   (<x22> ^cell.name c22 ^tile <o22>)
   (<x23> ^cell.name c23 ^tile <o23>)
   (<x24> ^cell.name c24 ^tile <o24>)
   (<x31> ^cell.name c31 ^tile <o31>)
   (<x32> ^cell.name c32 ^tile <o32>)
   (<x33> ^cell.name c33 ^tile <o33>)
   (<x34> ^cell.name c34 ^tile <o34>)
   (<x41> ^cell.name c41 ^tile <o41>)
   (<x42> ^cell.name c42 ^tile <o42>)
   (<x43> ^cell.name c43 ^tile <o43>)
   (<x44> ^cell.name c44 ^tile <o44>)
   (<d> ^binding <d11> <d12> <d13> <d14>
                 <d21> <d22> <d23> <d24>
                 <d31> <d32> <d33> <d34>
                 <d41> <d42> <d43> <d44>)
   (<d11> ^cell.name c11 ^tile <o11>)
   (<d12> ^cell.name c12 ^tile <o12>)
   (<d13> ^cell.name c13 ^tile <o13>)
   (<d14> ^cell.name c14 ^tile <o14>)
   (<d21> ^cell.name c21 ^tile <o21>)
   (<d22> ^cell.name c22 ^tile <o22>)
   (<d23> ^cell.name c23 ^tile <o23>)
   (<d24> ^cell.name c24 ^tile <o24>)
   (<d31> ^cell.name c31 ^tile <o31>)
   (<d32> ^cell.name c32 ^tile <o32>)
   (<d33> ^cell.name c33 ^tile <o33>)
   (<d34> ^cell.name c34 ^tile <o34>)
   (<d41> ^cell.name c41 ^tile <o41>)
   (<d42> ^cell.name c42 ^tile <o42>)
   (<d43> ^cell.name c43 ^tile <o43>)
   (<d44> ^cell.name c44 ^tile <o44>)
-->
   (<s> ^success <d>)}
 ## Define the initial state and the desired state:
 ## each state is a set of bindings#
 ## each binding points to a cell and a tile#
 ## each cell points to its neighboring cells.
sp {fifteen-puzzle*propose*initialize
   (state <s> ^name fifteen-puzzle
             -^blank-cell)
-->
   (<s> ^operator <o> +)
   (<o> ^name initialize)}
sp {eight*create*state*initial-and-desired-states
   (state <s> ^operator.name initialize
              ^desired <d>)
-->
   (<s> ^blank-cell <c44> ^tile-cell nil
        ^binding <bb0> <bb1> <bb2> <bb3> <bb4>
                 <bb5> <bb6> <bb7> <bb8> <bb9> <bb10> <bb11> <bb12> <bb13> <bb14> <bb15>)
   (<bb0>  ^cell  <c11> ^tile  <t2>)
   (<bb1>  ^cell  <c12> ^tile  <t1>)
   (<bb2>  ^cell  <c13> ^tile  <t7>)
   (<bb3>  ^cell  <c14> ^tile  <t8>)
   (<bb4>  ^cell  <c21> ^tile  <t6>)
   (<bb5>  ^cell  <c22> ^tile  <t15>)
   (<bb6>  ^cell  <c23> ^tile  <t3>)
   (<bb7>  ^cell  <c24> ^tile  <t4>)
   (<bb8>  ^cell  <c31> ^tile  <t5>)
   (<bb9>  ^cell  <c32> ^tile  <t9>)
   (<bb10> ^cell  <c33> ^tile <t10>)
   (<bb11> ^cell  <c34> ^tile <t11>)
   (<bb12> ^cell  <c41> ^tile <t12>)
   (<bb13> ^cell  <c42> ^tile <t13>)
   (<bb14> ^cell  <c43> ^tile <t14>)
   (<bb15> ^cell  <c44> ^tile <t0>)
   (<c11> ^name c11 ^cell <c12> ^cell <c21>)
   (<c12> ^name c12 ^cell <c11> ^cell <c13> ^cell <c22>)
   (<c13> ^name c13 ^cell <c12> ^cell <c23> ^cell <c14>)
   (<c14> ^name c14 ^cell <c13> ^cell <c24>)
   (<c21> ^name c21 ^cell <c11> ^cell <c31> ^cell <c22>)
   (<c22> ^name c22 ^cell <c21> ^cell <c12> ^cell <c23> ^cell <c32>)
   (<c23> ^name c23 ^cell <c22> ^cell <c33> ^cell <c13> ^cell <c24>)
   (<c24> ^name c24 ^cell <c14> ^cell <c23> ^cell <c34>)
   (<c31> ^name c31 ^cell <c32> ^cell <c21> ^cell <c41>)
   (<c32> ^name c32 ^cell <c31> ^cell <c22> ^cell <c33> ^cell <c42>)
   (<c33> ^name c33 ^cell <c32> ^cell <c23> ^cell <c43>)
   (<c34> ^name c34 ^cell <c33> ^cell <c24> ^cell <c44>)
   (<c41> ^name c41 ^cell <c31> ^cell <c42>)
   (<c42> ^name c42 ^cell <c41> ^cell <c32> ^cell <c43>)
   (<c43> ^name c43 ^cell <c42> ^cell <c33> ^cell <c44>)
   (<c44> ^name c44 ^cell <c43> ^cell <c34>)
   (<t0> ^name |0 |)
   (<t1> ^name |1 |)
   (<t2> ^name |2 |)
   (<t3> ^name |3 |)
   (<t4> ^name |4 |)
   (<t5> ^name |5 |)
   (<t6> ^name |6 |)
   (<t7> ^name |7 |)
   (<t8> ^name |8 |)
   (<t9> ^name |9 |)
   (<t10> ^name |10|)
   (<t11> ^name |11|)
   (<t12> ^name |12|)
   (<t13> ^name |13|)
   (<t14> ^name |14|)
   (<t15> ^name |15|)
   (<d> ^better higher
        ^binding <d16> <d1> <d2> <d3> <d4> <d5>
                 <d6> <d7> <d8> <d9> <d10> <d11>
                 <d12> <d13> <d14> <d15>)
   (<d1> ^cell <c11> ^tile <t1>)
   (<d2> ^cell <c12> ^tile <t2>)
   (<d3> ^cell <c13> ^tile <t3>)
   (<d4> ^cell <c14> ^tile <t4>)
   (<d5> ^cell <c21> ^tile <t5>)
   (<d6> ^cell <c22> ^tile <t6>)
   (<d7> ^cell <c23> ^tile <t7>)
   (<d8> ^cell <c24> ^tile <t8>)
   (<d9> ^cell <c31> ^tile <t9>)
   (<d10> ^cell <c32> ^tile <t10>)
   (<d11> ^cell <c33> ^tile <t11>)
   (<d12> ^cell <c34> ^tile <t12>)
   (<d13> ^cell <c41> ^tile <t13>)
   (<d14> ^cell <c42> ^tile <t14>)
   (<d15> ^cell <c43> ^tile <t15>)
   (<d16> ^cell <c44> ^tile <t0>)}
 ## A numeric evaluation function,
 ## based on changes by operators, is used
 ## to evaluate state.
sp {eight*elaborate*state*evaluation*positive*one
   (state <s> ^desired.binding <b2>
              ^tried-tied-operator
              ^tile-cell <c1>
              ^binding <b1>)
   (<b1> ^cell <c1> ^tile <v1>)
   (<b2> ^cell <c1> ^tile <v1>)
-->
   (<s> ^numeric-value 1)}
 ## 0 points for not moving tile in or out of its desired cell
  #
sp {eight*elaborate*state*evaluation*neutral*zero
   (state <s> ^desired <d>
              ^tried-tied-operator
              ^tile-cell <c1>
              ^blank-cell <c0>
              ^binding <b1> { <> <b1> <b2> } { <> <b1> <> <b2> <b3> })
   (<d> ^binding <b4> { <> <b4> <b5> })
   (<b1> ^cell <c1> ^tile <v1>)
   (<b2> ^tile <v2>)
   (<b3> ^tile <v3>)
   (<b4> ^cell <c1> ^tile { <> <v1> <v2> })
   (<b5> ^cell <c0> ^tile { <> <v1> <v3> })
-->
   (<s> ^numeric-value 0)}
 ## -1 points for moving tile out of its desired cell
  #
sp {eight*elaborate*state*evaluation*negative*one
   (state <s> ^desired.binding <b2>
              ^tried-tied-operator
              ^tile-cell <c1>
              ^binding <b1>
              ^blank-cell <c0>)
   (<b1> ^cell <c1> ^tile <v1>)
   (<b2> ^cell <c0> ^tile <v1>)
-->
   (<s> ^numeric-value -1)}
 ## Each state contains nine bindings.
 ## The bindings connect together a cell, one of the nine positions on 
 ## the board and a tile, one of the movable pieces. 
 ## The cells have pointers, ^cell, to each of their adjacent cells. 
 ## The state also has a pointer to the blank-cell and the cell
 ## that the last moved tile is in -- this improves efficiency and
 ## simplify computations that depend on the previous operator.
 ## Each operator contains a pointer to the cell with the blank
 ## and the cell with the tile to be moved.
 ## Define the initial state and the desired state:
 ## each state is a set of bindings#
 ## each binding points to a cell and a tile#
 ## each cell points to its neighboring cells.
sp {fifteen-puzzle*propose*initialize
   (state <s> ^superstate nil
             -^name)
-->
   (<s> ^operator <o> +)
   (<o> ^name initialize-fifteen-puzzle)}
sp {eight*create*state*initial-and-desired-states
   (state <s> ^operator.name initialize-fifteen-puzzle)
-->
   (<s> ^name fifteen-puzzle
        ^desired <d>
        ^blank-cell <c44> ^tile-cell nil
        ^binding <bb0> <bb1> <bb2> <bb3> <bb4>
                 <bb5> <bb6> <bb7> <bb8> <bb9> <bb10> <bb11> <bb12> <bb13> <bb14> <bb15>)
   (<bb0>  ^cell  <c11> ^tile  <t2>)
   (<bb1>  ^cell  <c12> ^tile  <t1>)
   (<bb2>  ^cell  <c13> ^tile  <t7>)
   (<bb3>  ^cell  <c14> ^tile  <t8>)
   (<bb4>  ^cell  <c21> ^tile  <t6>)
   (<bb5>  ^cell  <c22> ^tile  <t15>)
   (<bb6>  ^cell  <c23> ^tile  <t3>)
   (<bb7>  ^cell  <c24> ^tile  <t4>)
   (<bb8>  ^cell  <c31> ^tile  <t5>)
   (<bb9>  ^cell  <c32> ^tile  <t9>)
   (<bb10> ^cell  <c33> ^tile <t10>)
   (<bb11> ^cell  <c34> ^tile <t11>)
   (<bb12> ^cell  <c41> ^tile <t12>)
   (<bb13> ^cell  <c42> ^tile <t13>)
   (<bb14> ^cell  <c43> ^tile <t14>)
   (<bb15> ^cell  <c44> ^tile <t0>)
   (<c11> ^name c11 ^cell <c12> ^cell <c21>)
   (<c12> ^name c12 ^cell <c11> ^cell <c13> ^cell <c22>)
   (<c13> ^name c13 ^cell <c12> ^cell <c23> ^cell <c14>)
   (<c14> ^name c14 ^cell <c13> ^cell <c24>)
   (<c21> ^name c21 ^cell <c11> ^cell <c31> ^cell <c22>)
   (<c22> ^name c22 ^cell <c21> ^cell <c12> ^cell <c23> ^cell <c32>)
   (<c23> ^name c23 ^cell <c22> ^cell <c33> ^cell <c13> ^cell <c24>)
   (<c24> ^name c24 ^cell <c14> ^cell <c23> ^cell <c34>)
   (<c31> ^name c31 ^cell <c32> ^cell <c21> ^cell <c41>)
   (<c32> ^name c32 ^cell <c31> ^cell <c22> ^cell <c33> ^cell <c42>)
   (<c33> ^name c33 ^cell <c32> ^cell <c23> ^cell <c43>)
   (<c34> ^name c34 ^cell <c33> ^cell <c24> ^cell <c44>)
   (<c41> ^name c41 ^cell <c31> ^cell <c42>)
   (<c42> ^name c42 ^cell <c41> ^cell <c32> ^cell <c43>)
   (<c43> ^name c43 ^cell <c42> ^cell <c33> ^cell <c44>)
   (<c44> ^name c44 ^cell <c43> ^cell <c34>)
   (<t0> ^name |0 |)
   (<t1> ^name |1 |)
   (<t2> ^name |2 |)
   (<t3> ^name |3 |)
   (<t4> ^name |4 |)
   (<t5> ^name |5 |)
   (<t6> ^name |6 |)
   (<t7> ^name |7 |)
   (<t8> ^name |8 |)
   (<t9> ^name |9 |)
   (<t10> ^name |10|)
   (<t11> ^name |11|)
   (<t12> ^name |12|)
   (<t13> ^name |13|)
   (<t14> ^name |14|)
   (<t15> ^name |15|)
   (<d> ^better higher
        ^binding <d16> <d1> <d2> <d3> <d4> <d5>
                 <d6> <d7> <d8> <d9> <d10> <d11>
                 <d12> <d13> <d14> <d15>)
   (<d1> ^cell <c11> ^tile <t1>)
   (<d2> ^cell <c12> ^tile <t2>)
   (<d3> ^cell <c13> ^tile <t3>)
   (<d4> ^cell <c14> ^tile <t4>)
   (<d5> ^cell <c21> ^tile <t5>)
   (<d6> ^cell <c22> ^tile <t6>)
   (<d7> ^cell <c23> ^tile <t7>)
   (<d8> ^cell <c24> ^tile <t8>)
   (<d9> ^cell <c31> ^tile <t9>)
   (<d10> ^cell <c32> ^tile <t10>)
   (<d11> ^cell <c33> ^tile <t11>)
   (<d12> ^cell <c34> ^tile <t12>)
   (<d13> ^cell <c41> ^tile <t13>)
   (<d14> ^cell <c42> ^tile <t14>)
   (<d15> ^cell <c43> ^tile <t15>)
   (<d16> ^cell <c44> ^tile <t0>)}
sp {eight*create*operator*move-tile
   (state <s> ^name fifteen-puzzle
              ^blank-cell <c1>)
   (<c1> ^cell <c2>)
-->
   (<s> ^operator <o>)
   (<o> ^name move-tile
        ^tile-cell <c2>
        ^blank-cell <c1>)}
sp {eight*apply*operator*move-tile
   (state <s> ^operator <o>
              ^binding <b1> { <> <b1> <b2>}
              ^blank-cell <c1>)
   (<o> ^name move-tile
        ^tile-cell <c2>
        ^blank-cell <c1>)
   (<b1> ^tile <t1> ^cell <c1>)
   (<b2> ^tile <t2> ^cell <c2>)
-->
   (<s> ^blank-cell <c1> - <c2>)
   (<b1> ^tile <t1> - <t2>)
   (<b2> ^tile <t2> - <t1>)}
sp {eight*apply*operator*remove-tile-cell
   (state <s> ^operator <o>
              ^tile-cell <last-move>)
   (<o> ^name move-tile
        ^blank-cell <> <last-move>)
-->
   (<s> ^tile-cell <last-move> -)}
sp {eight*apply*operator*add-tile-cell
   (state <s> ^operator <o>
              ^blank-cell <c1>)
   (<o> ^name move-tile
        ^blank-cell <c1>)
-->
   (<s> ^tile-cell <c1>)}
learn --on
multi-attributes binding 10
multi-attributes operator 4
sp {eight*elaborate*problem-space
   (state <s> ^name eight-puzzle)
-->
   (<s> ^problem-space <p>)
   (<p> ^name eight-puzzle
        ^default-state-copy yes
        ^default-operator-copy no
        ^one-level-attributes blank-cell
        ^two-level-attributes binding)}
sp {eight*operator*move-tile*inverse*reject
   "Reject the operator that was applied to create this state."
   (state <s> ^problem-space.name eight-puzzle
              ^operator <o> +
              ^tile-cell <tc>)
   (<o> ^tile-cell <tc>)
-->
   (<s> ^operator <o> - )}
 ## Want this to fire whenever an op is installed or
 ## whenever op is applied (bindings change) but NOT both.
 ## Try requiring that operator be finished.
  #
sp {eight*monitor*state
   (state <s> ^binding <x11> <x12> <x13>
                       <x21> <x22> <x23>
                       <x31> <x32> <x33>)
   (<x11> ^cell.name c11 ^tile <o11>)
   (<o11> ^name <v11>)
   (<x12> ^cell.name c12 ^tile <o12>)
   (<o12> ^name <v12>)
   (<x13> ^cell.name c13 ^tile <o13>)
   (<o13> ^name <v13>)
   (<x21> ^cell.name c21 ^tile <o21>)
   (<o21> ^name <v21>)
   (<x22> ^cell.name c22 ^tile <o22>)
   (<o22> ^name <v22>)
   (<x23> ^cell.name c23 ^tile <o23>)
   (<o23> ^name <v23>)
   (<x31> ^cell.name c31 ^tile <o31>)
   (<o31> ^name <v31>)
   (<x32> ^cell.name c32 ^tile <o32>)
   (<o32> ^name <v32>)
   (<x33> ^cell.name c33 ^tile <o33>)
   (<o33> ^name <v33>)
-->
   (write (crlf)  |      -------------|  | | (crlf) | | )
   (write |     \||  | | <v11>  | | |\||  | | <v21>  | | |\||  | | <v31>  | | |\||  | | (crlf) | | )
   (write |     \|---\|---\|---\||  | | (crlf) | | )
   (write |     \||  | | <v12>  | | |\||  | | <v22>  | | |\||  | | <v32>  | | |\||  | | (crlf) | | )
   (write |     \|---\|---\|---\||  | | (crlf) | | )
   (write |     \||  | | <v13>  | | |\||  | | <v23>  | | |\||  | | <v33>  | | |\||  | | (crlf) | | )
   (write |     -------------|  | | (crlf) | | )}
sp {eight*detect*state*success
   (state <s> ^problem-space.name eight-puzzle
              ^desired <d>
              ^binding <x11> <x12> <x13>
                       <x21> <x22> <x23>
                       <x31> <x32> <x33>)
   (<x11> ^cell.name c11 ^tile <o11>)
   (<x12> ^cell.name c12 ^tile <o12>)
   (<x13> ^cell.name c13 ^tile <o13>)
   (<x21> ^cell.name c21 ^tile <o21>)
   (<x22> ^cell.name c22 ^tile <o22>)
   (<x23> ^cell.name c23 ^tile <o23>)
   (<x31> ^cell.name c31 ^tile <o31>)
   (<x32> ^cell.name c32 ^tile <o32>)
   (<x33> ^cell.name c33 ^tile <o33>)
   (<d> ^binding <d11> <d12> <d13>
                 <d21> <d22> <d23>
                 <d31> <d32> <d33>)
   (<d11> ^cell.name c11 ^tile <o11>)
   (<d12> ^cell.name c12 ^tile <o12>)
   (<d13> ^cell.name c13 ^tile <o13>)
   (<d21> ^cell.name c21 ^tile <o21>)
   (<d22> ^cell.name c22 ^tile <o22>)
   (<d23> ^cell.name c23 ^tile <o23>)
   (<d31> ^cell.name c31 ^tile <o31>)
   (<d32> ^cell.name c32 ^tile <o32>)
   (<d33> ^cell.name c33 ^tile <o33>)
-->
   (<s> ^success <d>)}
 ## Define the initial state and the desired state:
 ## each state is a set of bindings#
 ## each binding points to a cell and a tile#
 ## each cell points to its neighboring cells.
sp {eight-puzzle*propose*initialize
   (state <s> ^name eight-puzzle
             -^blank-cell)
-->
   (<s> ^operator <o> +)
   (<o> ^name initialize)}
sp {eight*create*state*initial-and-desired-states
   (state <s> ^operator.name initialize
              ^desired <d>)
-->
   (<s> ^blank-cell <c23>
        ^tile-cell nil
        ^binding <bb0> <bb1> <bb2> <bb3> <bb4>
                 <bb5> <bb6> <bb7> <bb8>)
   (<bb0> ^cell <c11> ^tile <t2>)
   (<bb1> ^cell <c12> ^tile <t1>)
   (<bb2> ^cell <c13> ^tile <t7>)
   (<bb3> ^cell <c21> ^tile <t8>)
   (<bb4> ^cell <c22> ^tile <t6>)
   (<bb5> ^cell <c23> ^tile <t0>)
   (<bb6> ^cell <c31> ^tile <t3>)
   (<bb7> ^cell <c32> ^tile <t4>)
   (<bb8> ^cell <c33> ^tile <t5>)
   (<c11> ^name c11 ^cell <c12> ^cell <c21>)
   (<c12> ^name c12 ^cell <c11> ^cell <c13> ^cell <c22>)
   (<c13> ^name c13 ^cell <c12> ^cell <c23>)
   (<c21> ^name c21 ^cell <c11> ^cell <c31> ^cell <c22>)
   (<c22> ^name c22 ^cell <c21> ^cell <c12>
          ^cell <c23> ^cell <c32>)
   (<c23> ^name c23 ^cell <c22> ^cell <c33> ^cell <c13>)
   (<c31> ^name c31 ^cell <c32> ^cell <c21>)
   (<c32> ^name c32 ^cell <c31> ^cell <c22> ^cell <c33>)
   (<c33> ^name c33 ^cell <c32> ^cell <c23>)
   (<t0> ^name 0)
   (<t1> ^name 1)
   (<t2> ^name 2)
   (<t3> ^name 3)
   (<t4> ^name 4)
   (<t5> ^name 5)
   (<t6> ^name 6)
   (<t7> ^name 7)
   (<t8> ^name 8)
   (<d> ^better higher
        ^binding <d0> <d1> <d2> <d3> <d4> <d5>
                 <d6> <d7> <d8>)
   (<d1> ^cell <c11> ^tile <t1>)
   (<d2> ^cell <c12> ^tile <t8>)
   (<d3> ^cell <c13> ^tile <t7>)
   (<d8> ^cell <c21> ^tile <t2>)
   (<d0> ^cell <c22> ^tile <t0>)
   (<d4> ^cell <c23> ^tile <t6>)
   (<d7> ^cell <c31> ^tile <t3>)
   (<d6> ^cell <c32> ^tile <t4>)
   (<d5> ^cell <c33> ^tile <t5>)}
 ## A numeric evaluation function,
 ## based on changes by operators, is used
 ## to evaluate state.
sp {eight*elaborate*state*evaluation*positive*one
   (state <s> ^desired.binding <b2>
              ^tried-tied-operator
              ^tile-cell <c1>
              ^binding <b1>)
   (<b1> ^cell <c1> ^tile <v1>)
   (<b2> ^cell <c1> ^tile <v1>)
-->
   (<s> ^numeric-value 1)}
 ## 0 points for not moving tile in or out of its desired cell
  #
sp {eight*elaborate*state*evaluation*neutral*zero
   (state <s> ^desired <d>
              ^tried-tied-operator
              ^tile-cell <c1>
              ^blank-cell <c0>
              ^binding <b1> { <> <b1> <b2> } { <> <b1> <> <b2> <b3> })
   (<d> ^binding <b4> { <> <b4> <b5> })
   (<b1> ^cell <c1> ^tile <v1>)
   (<b2> ^tile <v2>)
   (<b3> ^tile <v3>)
   (<b4> ^cell <c1> ^tile { <> <v1> <v2> })
   (<b5> ^cell <c0> ^tile { <> <v1> <v3> })
-->
   (<s> ^numeric-value 0)}
 ## -1 points for moving tile out of its desired cell
  #
sp {eight*elaborate*state*evaluation*negative*one
   (state <s> ^desired.binding <b2>
              ^tried-tied-operator
              ^tile-cell <c1>
              ^binding <b1>
              ^blank-cell <c0>)
   (<b1> ^cell <c1> ^tile <v1>)
   (<b2> ^cell <c0> ^tile <v1>)
-->
   (<s> ^numeric-value -1)}
 ## Define the initial state and the desired state:
 ## each state is a set of bindings#
 ## each binding points to a cell and a tile#
 ## each cell points to its neighboring cells.
sp {eight-puzzle*propose*initialize
   (state <s> ^superstate nil
             -^name)
-->
   (<s> ^operator <o> +)
   (<o> ^name initialize-eight-puzzle)}
sp {eight*create*state*initial-and-desired-states
   (state <s> ^operator.name initialize-eight-puzzle)
-->
   (<s> ^name eight-puzzle
        ^desired <d>
        ^blank-cell <c23>
        ^tile-cell nil
        ^binding <bb0> <bb1> <bb2> <bb3> <bb4>
                 <bb5> <bb6> <bb7> <bb8>)
   (<bb0> ^cell <c11> ^tile <t2>)
   (<bb1> ^cell <c12> ^tile <t1>)
   (<bb2> ^cell <c13> ^tile <t7>)
   (<bb3> ^cell <c21> ^tile <t8>)
   (<bb4> ^cell <c22> ^tile <t6>)
   (<bb5> ^cell <c23> ^tile <t0>)
   (<bb6> ^cell <c31> ^tile <t3>)
   (<bb7> ^cell <c32> ^tile <t4>)
   (<bb8> ^cell <c33> ^tile <t5>)
   (<c11> ^name c11 ^cell <c12> ^cell <c21>)
   (<c12> ^name c12 ^cell <c11> ^cell <c13> ^cell <c22>)
   (<c13> ^name c13 ^cell <c12> ^cell <c23>)
   (<c21> ^name c21 ^cell <c11> ^cell <c31> ^cell <c22>)
   (<c22> ^name c22 ^cell <c21> ^cell <c12>
          ^cell <c23> ^cell <c32>)
   (<c23> ^name c23 ^cell <c22> ^cell <c33> ^cell <c13>)
   (<c31> ^name c31 ^cell <c32> ^cell <c21>)
   (<c32> ^name c32 ^cell <c31> ^cell <c22> ^cell <c33>)
   (<c33> ^name c33 ^cell <c32> ^cell <c23>)
   (<t0> ^name 0)
   (<t1> ^name 1)
   (<t2> ^name 2)
   (<t3> ^name 3)
   (<t4> ^name 4)
   (<t5> ^name 5)
   (<t6> ^name 6)
   (<t7> ^name 7)
   (<t8> ^name 8)
   (<d> ^better higher
        ^binding <d0> <d1> <d2> <d3> <d4> <d5>
                 <d6> <d7> <d8>)
   (<d1> ^cell <c11> ^tile <t1>)
   (<d2> ^cell <c12> ^tile <t8>)
   (<d3> ^cell <c13> ^tile <t7>)
   (<d8> ^cell <c21> ^tile <t2>)
   (<d0> ^cell <c22> ^tile <t0>)
   (<d4> ^cell <c23> ^tile <t6>)
   (<d7> ^cell <c31> ^tile <t3>)
   (<d6> ^cell <c32> ^tile <t4>)
   (<d5> ^cell <c33> ^tile <t5>)}
 ## Each state contains nine bindings.
 ## The bindings connect together a cell, one of the nine positions on 
 ## the board and a tile, one of the movable pieces. 
 ## The cells have pointers, ^cell, to each of their adjacent cells. 
 ## The state also has a pointer to the blank-cell and the cell
 ## that the last moved tile is in -- this improves efficiency and
 ## simplify computations that depend on the previous operator.
 ## Each operator contains a pointer to the cell with the blank
 ## and the cell with the tile to be moved.
sp {eight*create*operator*move-tile
   (state <s> ^name eight-puzzle
              ^blank-cell <c1>)
   (<c1> ^cell <c2>)
-->
   (<s> ^operator <o>)
   (<o> ^name move-tile
        ^tile-cell <c2>
        ^blank-cell <c1>)}
sp {eight*apply*operator*move-tile
   (state <s> ^operator <o>
              ^binding <b1> { <> <b1> <b2>}
              ^blank-cell <c1>)
   (<o> ^name move-tile
        ^tile-cell <c2>
        ^blank-cell <c1>)
   (<b1> ^tile <t1> ^cell <c1>)
   (<b2> ^tile <t2> ^cell <c2>)
-->
   (<s> ^blank-cell <c1> - <c2>)
   (<b1> ^tile <t1> - <t2>)
   (<b2> ^tile <t2> - <t1>)}
sp {eight*apply*operator*remove-tile-cell
   (state <s> ^operator <o>
              ^tile-cell <last-move>)
   (<o> ^name move-tile
        ^blank-cell <> <last-move>)
-->
   (<s> ^tile-cell <last-move> -)}
sp {eight*apply*operator*add-tile-cell
   (state <s> ^operator <o>
              ^blank-cell <c1>)
   (<o> ^name move-tile
        ^blank-cell <c1>)
-->
   (<s> ^tile-cell <c1>)}
learn --on
multi-attributes binding 10
multi-attributes operator 4
sp {elaborate*top-state*top-state
   (state <s> ^superstate nil)
-->
   (<s> ^top-state <s>)
}
sp {elaborate*state*name
   (state <s> ^superstate.operator.name <name>)
-->
   (<s> ^name <name>)
}
sp {elaborate*state*top-state
   (state <s> ^superstate.top-state <ts>)
-->
   (<s> ^top-state <ts>)
}
sp {reward
   (state <s> ^reward-link <rl>)
-->
   (<rl> ^reward.value 100)
}
sp {value*function
   :template
   (state <s> ^operator <op> +)
   (<op> ^name <op-name>
         ^rl <num>)
-->
   (<s> ^operator <op> = 0)
}
sp {one*propose*one-two
   (state <s> ^name one
              ^phase two)
-->
   (<s> ^operator <op> +)
   (<op> ^name one-two
         ^rl alpha)
}
sp {apply*one-two
   (state <s> ^operator <op>
              ^superstate <ss>)
   (<op> ^name one-two)
   (<ss> ^operator <ss-op>)
-->
   (<ss> ^case one -
         ^case two)
}
sp {one*propose*one-one
   (state <s> ^name one
             -^phase)
-->
   (<s> ^operator <op> +)
   (<op> ^name one-one
         ^rl alpha)
}
sp {apply*one-one
   (state <s> ^operator <op>)
   (<op> ^name one-one)
-->
   (<s> ^phase two)
}
sp {propose*initialize-rl-unit
   (state <s> ^superstate nil
             -^name)
-->
   (<s> ^operator <o> +)
   (<o> ^name initialize-rl-unit
        ^rl alpha)
}
sp {apply*initialize-rl-unit
   (state <s> ^operator <op>)
   (<op> ^name initialize-rl-unit)
-->
   (<s> ^name rl-unit
        ^case one
        ^max-cases five)
}
sp {rl-unit*propose*two
   (state <s> ^name rl-unit
              ^case two)
-->
   (<s> ^operator <op> + =)
   (<op> ^name two)
}
sp {rl-unit*propose*four
   (state <s> ^name rl-unit
              ^case four)
-->
   (<s> ^operator <op> + =)
   (<op> ^name four)
}
sp {rl-unit*propose*done
   (state <s> ^name rl-unit
              ^max-cases <max>
              ^case <max>)
-->
   (<s> ^operator <op> + =)
   (<op> ^name done)
}
sp {apply*done
   (state <s> ^operator <op>)
   (<op> ^name done)
-->
   (halt)
}
sp {two*propose*two-two
   (state <s> ^name two
              ^phase two)
-->
   (<s> ^operator <op> +)
   (<op> ^name two-two)
}
sp {apply*two-two
   (state <s> ^operator <op>)
   (<op> ^name two-two)
-->
   (<s> ^phase two -
        ^phase three)
}
sp {two*propose*two-one
   (state <s> ^name two
             -^phase)
-->
   (<s> ^operator <op> +)
   (<op> ^name two-one
         ^rl alpha)
}
sp {apply*two-one
   (state <s> ^operator <op>)
   (<op> ^name two-one)
-->
   (<s> ^phase two)
}
sp {two*propose*two-three
   (state <s> ^name two
              ^phase three)
-->
   (<s> ^operator <op> +)
   (<op> ^name two-three
         ^rl alpha)
}
sp {apply*two-three
   (state <s> ^operator <op>
              ^superstate <ss>)
   (<op> ^name two-three)
   (<ss> ^operator <ss-op>)
-->
   (<ss> ^case two -
         ^case three)
}
sp {four*propose*four-two
   (state <s> ^name four
              ^phase two)
-->
   (<s> ^operator <op> + =)
   (<op> ^name four-two)
}
sp {apply*four-two
   (state <s> ^operator <op>)
   (<op> ^name four-two)
-->
   (<s> ^phase two -
        ^phase three)
}
sp {four*propose*four-three
   (state <s> ^name four
              ^phase three)
-->
   (<s> ^operator <op> + =)
   (<op> ^name four-three)
}
sp {four*propose*four-one
   (state <s> ^name four
             -^phase)
-->
   (<s> ^operator <op> +)
   (<op> ^name four-one
         ^rl alpha)
}
sp {apply*four-one
   (state <s> ^operator <op>)
   (<op> ^name four-one)
-->
   (<s> ^phase two)
}
sp {four-three*propose*four-three-one
   (state <s> ^name four-three)
-->
   (<s> ^operator <op> + =)
   (<op> ^name four-three-one)
}
sp {apply*four-three-one
   (state <s> ^operator <op>
              ^superstate <ss>)
   (<op> ^name four-three-one)
   (<ss> ^operator <ss-op>)
-->
   (<ss> ^phase three -
         ^phase four)
}
sp {four*propose*four-four
   (state <s> ^name four
              ^phase four)
-->
   (<s> ^operator <op> +)
   (<op> ^name four-four
         ^rl alpha)
}
sp {apply*four-four
   (state <s> ^operator <op>
              ^superstate <ss>)
   (<op> ^name four-four)
   (<ss> ^operator <ss-op>)
-->
   (<ss> ^case four -
         ^case five)
}
sp {rl-unit*propose*three
   (state <s> ^name rl-unit
              ^case three)
-->
   (<s> ^operator <op> +)
   (<op> ^name three)
}
sp {three*propose*three-one
   (state <s> ^name three
             -^phase)
-->
   (<s> ^operator <op> + =)
   (<op> ^name three-one
         ^rl alpha)
}
sp {three-one*propose*three-one-one
   (state <s> ^name three-one)
-->
   (<s> ^operator <op> + =)
   (<op> ^name three-one-one)
}
sp {apply*three-one-one
   (state <s> ^operator <op>
              ^superstate <ss>)
   (<op> ^name three-one-one)
   (<ss> ^operator <ss-op>)
-->
   (<ss> ^phase two)
}
sp {three*propose*three-two
   (state <s> ^name three
              ^phase two)
-->
   (<s> ^operator <op> + =)
   (<op> ^name three-two
         ^rl alpha)
}
sp {apply*three-two
   (state <s> ^operator <op>
              ^superstate <ss>)
   (<op> ^name three-two)
   (<ss> ^operator <ss-op>)
-->
   (<ss> ^case three -
         ^case four)
}
sp {rl-unit*propose*one
   (state <s> ^name rl-unit
              ^case one)
-->
   (<s> ^operator <op> + =)
   (<op> ^name one)
}
rl --set learning on
rl --set learning-rate 0.1
rl --set discount-rate 0.5
watch --rl
sp {elaborate*top-state*top-state
   (state <s> ^superstate nil)
-->
   (<s> ^top-state <s>)
}
sp {elaborate*state*name
   (state <s> ^superstate <ss>)
   (<ss> ^operator <op>)
   (<op> ^name <name>)
-->
   (<s> ^name <name>)
}
sp {elaborate*state*top-state
   (state <s> ^superstate <ss>)
   (<ss> ^top-state <ts>)
-->
   (<s> ^top-state <ts>)
}
sp {elaborate*reward
   (state <s> ^name left-right
              ^reward-link <r>
              ^location <d-name>
              ^direction <dir>)
   (<dir> ^name <d-name> ^reward <d-reward>)
-->
   (<r> ^reward <rr>)
   (<rr> ^value <d-reward>)
}
sp {elaborate*done
   (state <s> ^name left-right
              ^location {<> start})
-->
   (halt)
}
sp {propose*initialize-left-right
   (state <s> ^superstate nil
             -^name)
-->
   (<s> ^operator <o> +)
   (<o> ^name initialize-left-right)
}
sp {apply*initialize-left-right
   (state <s> ^operator <op>)
   (<op> ^name initialize-left-right)
-->
   (<s> ^name left-right
        ^direction <d1> <d2>
        ^location start)
   (<d1> ^name left ^reward -1)
   (<d2> ^name right ^reward 1)
}
sp {left-right*propose*move
   (state <s> ^name left-right
              ^direction <d>
              ^location start)
   (<d> ^name <dir>)
-->
   (<s> ^operator <op> +)
   (<op> ^name move
         ^dir <dir>)
}
sp {left-right*rl*left
   (state <s> ^name left-right
              ^operator <op> +)
   (<op> ^name move
         ^dir left)
-->
   (<s> ^operator <op> = 0)
}
sp {left-right*rl*right
   (state <s> ^name left-right
              ^operator <op> +)
   (<op> ^name move
         ^dir right)
-->
   (<s> ^operator <op> = 0)
}
sp {apply*move
   (state <s> ^operator <op>
              ^location start)
   (<op> ^name move
         ^dir <dir>)
-->
   (<s> ^location start - <dir>)
   (write (crlf) |Moved: | <dir>)
}
rl --set learning on

# the following 3 commands test the fix for issues 95 and 102
sp {literals_test
   (state <s> ^superstate nil) # }}}}
-->
   (<s> ^literal |##}}}}}{{##|)}

w 0 # blah blah blah

# should be empty
