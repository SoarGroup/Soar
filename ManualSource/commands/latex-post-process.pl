#!/usr/bin/perl

# Extra processing of the tex files generated by html2latex to make them ready
# for inclusion in the manual source.

use strict;

my $state = "header";
my $removed_dash = "no";
my $after_hline = "no";
my $delete_next_newrow = "yes";
my $in_aliases = "no";
my $removed_command_name = "no";
my $in_verbatim = "no";

my $command;

while (<>) {

  # handle the verbatim environment
  if (/\\begin\{verbatim\}/) {
    $in_verbatim = "yes";
  }
  if ($in_verbatim eq "yes") {
    if (/\\end\{verbatim\}/) {
      $in_verbatim = "no";
    }
    else {
      # remove all newlines in verbatim. Not sure if this is desirable in all
      # cases, but for the most part it doesn't seem to hurt
      if (not /^\s*$/) {
        print $_;
      }
      next;
    }
  }

  # lone \\'s cause problems if they follow directly after the end of some tex
  # environment or a blank line - You'll get an error saying "There's no line
  # to end here" - but they're required otherwise
  if ($delete_next_newrow eq "yes" and /^\s*\\\\\s*$/) {
    next;
  }

  $delete_next_newrow = (/\\end/ or /^\s*$/) ? "yes" : "no";

  if (/\\documentclass/) {
    next;
  }

  if (/\\usepackage/) {
    next;
  }
  
  if (/\\title/) {
    next;
  }
  
  if (/\\begin\{tabular\}\{\|c\|c\|\}/) {
    if ($in_aliases eq "yes") {
      print "\n\\begin{tabularx}{0.4\\textwidth}{|l|X|}\n";
      $in_aliases = "no";
    }
    else {
      print "\n\\begin{tabularx}{\\textwidth}{|l|X|}\n";
    }
    next;
  } 
  elsif (/\\begin\{tabular\}\{\|c\|c\|c\|\}/) {
    print "\n\\begin{tabularx}{\\textwidth}{|l|X|X|}\n";
    next;
  }

  if (/\\hline/) {
    $after_hline = "yes";
    print "\\hline\n";
    next;
  }

  if ($after_hline eq "yes") {
    if (not /^\s*$/) {
      $after_hline = "no";
    }
    if (/\\end\{tabular\}/) {
      print "\\end{tabularx}\n\n";
      next;
    }
    
    # This puts a \soar{} around the first cell in a table row
    if (/([^\&]+)( +\&.+)/) {
      print "\\soar{$1}$2\n";
      next;
    }
  }

  if (/\\end\{document\}/) {
    next;
  }
  
  if ($state eq "header") {
    if (/\\begin.*/) {
      next;
    }

    if (/\\section\*\{(.+)\}/) {
      $command = lc $+;
      $command =~ s/documentation\/cli\///; # get rid of the documentation/cli/ prefix
      print "\\subsection{\\soarb{$command}}\n";

      print "\\label{$command}\n";
      print "\\index{$command}\n";
      
      $state = "body";
      next;
    }
  }

  if ($state eq "body") {

    if (/\\section\*\{\s*Name\s*\}/) {
      next;
    }
    
    if (/\\section\*\{([^}]+)\}/) {
      $_ = $+;
      if (/[Ss]tructured [Oo]utput/) {
        $_ = "Structured Output:";
      } 
      if (/[Ee]rror [Vv]alues/) {
        $_ = "Error Values:";
      }
      if (/[Ss]ee [Aa]lso/) {
        $state = "seealso";
      }
      if (/[Dd]efault [Aa]liases/) {
        $in_aliases = "yes";
      }
      $_ =~ s/^\s*//;
      $_ =~ s/\s*$//;
      print "\\subsubsection\*\{$_\}\n";
      next;
    }

    if (/\\subsection\*\{([^}]+)\}/) {
      my $n = $+;
      $n =~ s/^\s*//;
      $n =~ s/\s*$//;
      print "\\subsubsection\*\{$n\}\n";
      next;
    }
    
    # This is a little fragile, but the standard for the wiki pages seems to
    # include a line that has the command name in bold followed by a - and then
    # a short summary of the command. In the manual we don't want the bolded
    # name or the -, just the short summary. 
    if (/\\textbf\{$command\}/ and $removed_command_name ne "yes") {
      $removed_command_name = "yes";
      if ($removed_dash eq "no") {
        $state = "remove-dash";
      }
      next;
    }
  }

  # this deletes the - following the command name mentioned above
  if ($state eq "remove-dash") {
    $state = "body";
    $removed_dash = "yes";
    if (/\s*\-+\s*([^ ].+)/) {
      print $+ . "\n";
    }
    next;
  }
  
  # make clickable hyperrefs to all the see also entries
  if ($state eq "seealso") {
    if (not /^\s*$/) {
      $state = "body";
      my @seealsos = split /[\, ]/, $_;
      foreach (@seealsos) {
        my $element = $_;
        chomp $element;
        if ($element) {
          if ($element ne "home") { # obsolete commands
            print "\\hyperref[$element]{$element} ";
          }
        }
      }
    }
    next;
  }

  print $_;
}
