\chapter{Episodic Memory}
\label{EPMEM}
\index{episodic memory}
\index{epmem}

Episodic memory is a record of an agent's stream of experience. 
The episodic storage mechanism will automatically record episodes as a Soar agent executes. 
The agent can later deliberately retrieve episodic knowledge to extract information and regularities that may not have been noticed during the original experience and combine them with current knowledge such as to improve performance on future tasks.

This chapter is organized as follows: episodic memory structures in working memory (\ref{EPMEM-wm}); episodic storage (\ref{EPMEM-storage}); retrieving episodes (\ref{EPMEM-retrieval}); and a discussion of performance (\ref{EPMEM-perf}). 
The detailed behavior of episodic memory is determined by numerous parameters that can be controlled and configured via the \soarb{epmem} command. 
Please refer to the documentation for that command in Section \ref{epmem} on page \pageref{epmem}.

\section{Working Memory Structure}
\label{EPMEM-wm}

Upon creation of a new state in working memory (see Section \ref{ARCH-impasses-types} on page \pageref{ARCH-impasses-types}; Section \ref{SYNTAX-impasses} on page \pageref{SYNTAX-impasses}), the architecture creates the following augmentations to facilitate agent interaction with episodic memory:

\begin{verbatim}
(<s> ^epmem <e>)
  (<e> ^command <e-c>)
  (<e> ^result <e-r>)
\end{verbatim}

As rules augment the \emph{command} structure in order to retrieve episodes (\ref{EPMEM-retrieval}), episodic memory augments the \emph{result} structure in response.
Production actions should not remove augmentations of the \emph{result} structure directly, as episodic memory will maintain these WMEs.


\section{Episodic Storage}
\label{EPMEM-storage}

Episodic memory records new episodes without deliberate action/consideration by the agent. 
The timing and frequency of recording new episodes is controlled by the \soarb{phase} and \soarb{trigger} parameters.  
The \soarb{phase} parameter sets the phase in the decision cycle (default: end of Output phase) during which episodic memory stores episodes and processes commands.  
The value of the \soarb{trigger} parameter indicates to the architecture the event that concludes an episode: adding a new augmentation to the output-link (default) or each decision cycle.

For debugging purposes, the \soarb{force} parameter allows the user to manually request that an episode be recorded (or not) during the current decision cycle.  
Behavior is as follows:

\begin{itemize}
\item 
The value of the \soarb{force} parameter is initialized to \soarb{off} every decision cycle.

\item 
During the \soarb{phase} of episodic storage, episodic memory tests the value of the \soarb{force} parameter; if it has a value other than of off, episodic memory follows the \emph{forced} policy irrespective of the value of the \soarb{trigger} parameter.

\end{itemize}

\subsection{Episode Contents}
When episodic memory stores a new episode, it captures the entire top-state of working memory. 
There are currently two exceptions to this policy:

\begin{itemize}
\item 
Episodic memory only supports WMEs whose attribute is a constant. 
Behavior is currently undefined when attempting to store a WME that has an attribute that is an identifier.

\item 
The \soarb{exclusions} parameter allows the user to specify a set of attributes for which Soar will not store WMEs. 
The storage process currently walks the top-state of working memory in a breadth-first manner, and any WME that is not reachable other than via an excluded WME will not be stored. 
By default, episodic memory excludes the \emph{epmem} and \emph{smem} structures, to prevent encoding of potentially large and/or frequently changing memory retrievals.

\end{itemize}

\subsection{Storage Location}
Episodic memory uses SQLite to facilitate efficient and standardized storage and querying of episodes.  
The episodic store can be maintained in memory or on disk (per the \soarb{database} and \soarb{path} parameters).  
If the store is located on disk, users can use any standard SQLite programs/components to access/query its contents. 
See the later discussion on performance (\ref{EPMEM-perf}) for additional parameters dealing with databases on disk.

\section{Retrieving Episodes}
\label{EPMEM-retrieval}

An agent retrieves episodes by creating an appropriate command (we detail the types of commands below) on the \emph{command} link of a state's \emph{epmem} structure. 
At the end of the \soarb{phase} of each decision, after episodic storage, episodic memory processes each state's \emph{epmem} command structure.  
Results, meta-data, and errors are placed on the \emph{result} structure of that state's \emph{epmem} structure.

Only one type of retrieval command (which may include optional modifiers) can be issued per state in a single decision cycle.  
Malformed commands (including attempts at multiple retrieval types) will result in an error:

\begin{verbatim}
<s> ^epmem.result.status bad-cmd
\end{verbatim}

After a command has been processed, episodic memory will ignore it until some aspect of the command structure changes (via addition/removal of WMEs).  
When this occurs, the result structure is cleared and the new command (if one exists) is processed.

\subsection{Cue-Based Retrievals}
Cue-based retrieval commands are used to search for an episode in the store that best matches an agent-supplied cue, while adhering to optional modifiers.  
A cue is composed of WMEs that partially describe a top-state of working memory in the retrieved episode.  
All cue-based retrieval requests must contain a single \emph{query} cue and, optionally, a single \emph{neg-query} cue.  

\begin{verbatim}
<s> ^epmem.command.query <required-cue>
<s> ^epmem.command.neg-query <optional-negative-cue>
\end{verbatim}

A \emph{query} cue describes structures desired in the retrieved episode, whereas a \emph{neg-query} cue describes non-desired structures.  
For example, the following Soar production creates a \emph{query} cue consisting of a particular state name and a copy of a current value on the \emph{input-link} structure:

\begin{verbatim}
sp {epmem*sample*query
    (state <s> ^epmem.command <ec>
               ^io.input-link.foo <bar>)
-->
    (<ec> ^query <q>)
    (<q> ^name my-state-name
         ^io.input-link.foo <bar>)
}
\end{verbatim}

As detailed below, multiple prior episodes may equally match the structure and contents of an agent's cue. 
Nuxoll has produced initial evidence that in some tasks, retrieval quality improves when using \emph{activation} of cue WMEs as a form of feature weighting.  
Thus, episodic memory supports integration with working memory activation (see Section \ref{wma} on page \pageref{wma}).  
For a theoretical discussion of the Soar implementation of working memory activation, consider reading \emph{Comprehensive Working Memory Activation in Soar} (Nuxoll, A., Laird, J., James, M., ICCM 2004).

The cue-based retrieval process can be thought of conceptually as a nearest-neighbor search. 
First, all candidate episodes, defined as episodes containing at least one leaf WME (a cue WME with no sub-structure) in at least one cue, are identified.  
Two quantities are calculated for each candidate episode, with respect to the supplied cue(s): the cardinality of the match (defined as the number of matching leaf WMEs) and the activation of the match (defined as the sum of the activation values of each matching leaf WME).  
Note that each of these values is negated when applied to a negative query.  
To compute each candidate episode's match score, these quantities are combined with respect to the \soarb{balance} parameter as follows:

$$(balance)*(cardinality) + (1-balance)*(activation)$$

Performing a graph match on each candidate episode, with respect to the structure of the cue, could be very computationally expensive, so episodic memory implements a two-stage matching process.
An episode with perfect cardinality is considered a perfect \emph{surface} match and, per the \soarb{graph-match} parameter, is subjected to further \emph{structural} matching.  
Whereas surface matching efficiently determines if all paths to leaf WMEs exist in a candidate episode, graph matching indicates whether or not the cue can be structurally unified with the candidate episode (paying special regard to the structural constraints imposed by shared identifiers).  
Cue-based matching will return the most recent structural match, or the most recent candidate episode with the greatest match score.

A special note should be made with respect to how short- vs. long-term identifiers (see Section \ref{SMEM-kr} on page \pageref{SMEM-kr}) are interpreted in a cue.  
Short-term identifiers are processed much as they are in working memory -- transient structures.  
Cue matching will try to find any identifier in an episode (with respect to WME path from state) that can apply.  
Long-term identifiers, however, are treated as constants. 
Thus, when analyzing the cue, episodic memory will not consider long-term identifier augmentations, and will only match with the same long-term identifier (in the same context) in an episode.

The case-based retrieval process can be further controlled using optional modifiers:

\begin{itemize}

\item 
The \emph{before} command requires that the retrieved episode come relatively before a supplied time:
\begin{verbatim}
<s> ^epmem.command.before time
\end{verbatim}

\item 
The \emph{after} command requires that the retrieved episode come relatively after a supplied time:
\begin{verbatim}
<s> ^epmem.command.after time
\end{verbatim}

\item 
The \emph{prohibit} command requires that the time of the retrieved episode is not equal to a supplied time:
\begin{verbatim}
<s> ^epmem.command.prohibit time
\end{verbatim}
Multiple prohibit command WMEs may be issued as modifiers to a single CB retrieval.

\end{itemize}

If no episode satisfies the cue(s) and optional modifiers an error is returned:

\begin{verbatim}
<s> ^epmem.result.failure <query> <optional-neg-query>
\end{verbatim}

If an episode is returned, there is additional meta-data supplied (\ref{EPMEM-meta}).

\subsection{Absolute Non-Cue-Based Retrieval}
At time of storage, each episode is attributed a unique \emph{time}.  
This is the current value of \soarb{time} statistic and is provided as the \emph{memory-id} meta-data item of retrieved episodes (\ref{EPMEM-meta}).  
An absolute non-cue-based retrieval is one that requests an episode by time.  
An agent issues an absolute non-cue-based retrieval by creating a WME on the \emph{command} structure with attribute \emph{retrieve} and value equal to the desired time:

\begin{verbatim}
<s> ^epmem.command.retrieve time
\end{verbatim}

Supplying an invalid value for the \emph{retrieve} command will result in an error.

The time of the first episode in an episodic store will have value 1 and each subsequent episode's time will increase by 1.  
Thus the desired time may be the mathematical result of operations performed on a known episode's time.

The current episodic memory implementation does not implement any episodic store dynamics, such as forgetting.  
Thus any integer time greater than 0 and less than the current value of the \soarb{time} statistic will be valid.  
However, if forgetting is implemented in future versions, no such guarantee will be made.

\subsection{Relative Non-Cue-Based Retrieval}
Episodic memory supports the ability for an agent to ``play forward" episodes using relative non-cue-based retrievals. 

Episodic memory stores the time of the last successful retrieval (non-cue-based or cue-based).  
Agents can indirectly make use of this information by issuing \emph{next} or \emph{previous} commands.  
Episodic memory executes these commands by attempting to retrieve the episode immediately proceeding/preceding the last successful retrieval (respectively).  
To issue one of these commands, the agent must create a new WME on the \emph{command} link with the appropriate attribute (\emph{next} or \emph{previous}) and value of an arbitrary identifier:

\begin{verbatim}
<s> ^epmem.command.next <n>
<s> ^epmem.command.previous <p>
\end{verbatim}

If no such episode exists then an error is returned.

Currently, if the time of the last successfully retrieved episode is known to the agent (as could be the case by accessing result meta-data), these commands are identical to performing an absolute non-cue-based retrieval after adding/subtracting 1 to the last time (respectively).  
However, if an episodic store dynamic like forgetting is implemented, these relative commands are guaranteed to return the next/previous valid episode (assuming one exists).

\subsection{Retrieval Meta-Data}
\label{EPMEM-meta}
The following list details the WMEs that episodic memory creates in the \emph{result} link of the \emph{epmem} structure wherein a command was issued:

\begin{itemize}

\item \soarb{retrieved <retrieval-root>}

If episodic memory retrieves an episode, that memory is placed here. 
This WME is an identifier that is treated as the root of the state that was used to create the episodic memory. 
If the \emph{retrieve} command was issued with an invalid time, the value of this WME will be \emph{no-memory}.

\item \soarb{success <query> <optional-neg-query>}

If the cue-based retrieval was successful, the WME will have the status as the attribute and the value of the identifier of the query (and neg-query, if applicable).

\item \soarb{match-score}

This WME is created whenever an episode is successfully retrieved from a cue-based retrieval command. 
The WME value is a decimal indicating the raw match score for that episode with respect to the cue(s).

\item \soarb{cue-size}

This WME is created whenever an episode is successfully retrieved from a cue-based retrieval command.  
The WME value is an integer indicating the number of leaf WMEs in the cue(s).

\item \soarb{normalized-match-score}

This WME is created whenever an episode is successfully retrieved from a cue-based retrieval command.  
The WME value is the decimal result of dividing the raw match score by the cue size.  
It can hypothetically be used as a measure of episodic memory's relative confidence in the retrieval.

\item \soarb{match-cardinality}

This WME is created whenever an episode is successfully retrieved from a cue-based retrieval command.  
The WME value is an integer indicating the number of leaf WMEs matched in the \emph{query} cue minus those matched in the \emph{neg-query} cue.

\item \soarb{memory-id}

This WME is created whenever an episode is successfully retrieved from a cue-based retrieval command.  
The WME value is an integer indicating the time of the retrieved episode.

\item \soarb{present-id}

This WME is created whenever an episode is successfully retrieved from a cue-based retrieval command.  
The WME value is an integer indicating the current time, such as to provide a sense of ``now" in episodic memory terms.  
By comparing this value to the \emph{memory-id} value, the agent can gain a sense of the relative time that has passed since the retrieved episode was recorded.

\item \soarb{graph-match}

This WME is created whenever an episode is successfully retrieved from a cue-based retrieval command and the \soarb{graph-match} parameter was \soarb{on}.  
The value is an integer with value 1 if graph matching was executed successfully and 0 otherwise.

\item \soarb{mapping <mapping-root>}

This WME is created whenever an episode is successfully retrieved from a cue-based retrieval command, the \soarb{graph-match} parameter was \soarb{on}, and structural match was successful on the retrieved episode.  
This WME provides a mapping between identifiers in the cue and in the retrieved episode.  
For each identifier in the cue, there is a \emph{node} WME as an augmentation to the \emph{mapping} identifier.  
The node has a \emph{cue} augmentation, whose value is an identifier in the cue, and a \emph{retrieved} augmentation, whose value is an identifier in the retrieved episode.  
In a graph match it is possible to have multiple identifier mappings -- this map represents the ``first" unified mapping (with respect to episodic memory algorithms).

\end{itemize}

\section{Performance}
\label{EPMEM-perf}

There are currently two sources of ``unbounded" computation: graph matching and cue-based queries.  
Graph matching is combinatorial in the worst case.  
Thus, if an episode presents a perfect surface match, but imperfect structural match (i.e. there is no way to unify the cue with the candidate episode), there is the potential for exhaustive search.  
Each identifier in the cue can be assigned one of any historically consistent identifiers (with respect to the sequence of attributes that leads to the identifier from the root), termed a literal.  
If the identifier is a multi-valued attribute, there will be more than one candidate literals and this situation can lead to a very expensive search process.  
Currently there are no heuristics in place to attempt to combat the expensive backtracking.  
Worst-case performance will be combinatorial in the total number of literals for each cue identifier (with respect to cue structure).

The cue-based query algorithm begins with the most recent candidate episode and will stop search as soon as a match is found (since this episode must be the most recent).  
Given this procedure, it is trivial to create a two-WME cue that forces a linear search of the episodic store. 
Episodic memory combats linear scan by only searching candidate episodes, i.e. only those that contain a change in at least one of the cue WMEs.  
However, a cue that has no match and contains WMEs relevant to all episodes will force inspection of all episodes.  
Thus, worst-case performance will be linear in the number of episodes. 

\subsection{Performance Tweaking}
When using a database stored to disk, several parameters become crucial to performance.  
The first is \soarb{commit}, which controls the number of episodes that occur between writes to disk.  
If the total number of episodes (or a range) is known ahead of time, setting this value to a greater number will result in greatest performance (due to decreased I/O).

The next two parameters deal with the SQLite cache, which is a memory store used to speed operations like queries by keeping in memory structures like levels of index B+-trees. 
The first parameter, \soarb{page\_size}, indicates the size, in bytes, of each cache page. 
The second parameter, \soarb{cache\_size}, suggests to SQLite how many pages are available for the cache. 
Total cache size is the product of these two parameter settings. 
The cache memory is not pre-allocated, so short/small runs will not necessarily make use of this space. 
Generally speaking, a greater number of cache pages will benefit query time, as SQLite can keep necessary meta-data in memory. 
However, some documented situations have shown improved performance from decreasing cache pages to increase memory locality. 
This is of greater concern when dealing with file-based databases, versus in-memory. 
The size of each page, however, may be important whether databases are disk- or memory-based. 
This setting can have far-reaching consequences, such as index B+-tree depth. 
While this setting can be dependent upon a particular situation, a good heuristic is that short, simple runs should use small values of the page size (\soarb{1k}, \soarb{2k}, \soarb{4k}), whereas longer, more complicated runs will benefit from larger values (\soarb{8k}, \soarb{16k}, \soarb{32k}, \soarb{64k}). 
One known situation of concern is that as indexed tables accumulate many rows (~millions), insertion time of new rows can suffer an infrequent, but linearly increasing burst of computation. 
In episodic memory, this situation will typically arise with many episodes and/or many working memory changes. 
Increasing the page size will reduce the intensity of the spikes at the cost of increasing disk I/O and average/total time for episode storage. 
Thus, the settings of page size for long, complicated runs establishes the desired balance of reactivity (i.e. max computation) and average speed. 
To ground this discussion, the Figure \ref{fig:epmem-cache} depicts maximum and average episodic storage time (the value of the epmem\_storage timer, converted to milliseconds) with different page sizes after 10 million decisions (1 episode/decision) of a very basic agent (i.e. very few working memory changes per episode) running on a 2.8GHz Core i7 with Mac OS X 10.6.5. 
While only a single use case, the cross-point of these data forms the basis for the decision to default the parameter at 8192 bytes.

\begin{figure}
\insertfigure{Figures/epmem-cache}{2.5in}
\insertcaption{Example episodic memory cache setting data.}
\label{fig:epmem-cache}
\end{figure}

The next parameter is \soarb{optimization}.  
The \soarb{safety} parameter setting will use SQLite default settings.  
If data integrity is of importance, this setting is ideal.  
The performance setting will make use of lesser data consistency guarantees for significantly greater performance.  
First, writes are no longer synchronous with the OS (synchronous pragma), thus episodic memory won't wait for writes to complete before continuing execution.  
Second, transaction journaling is turned off (journal\_mode pragma), thus groups of modifications to the episodic store are not atomic (and thus interruptions due to application/os/hardware failure could lead to inconsistent database state).  
Finally, upon initialization, episodic memory maintains a continuous exclusive lock to the database (locking\_mode pragma), thus other applications/agents cannot make simultaneous read/write calls to the database (thereby reducing the need for potentially expensive system calls to secure/release file locks).

Finally, maintaining accurate operation timers can be relatively expensive in Soar.  
Thus, these should be enabled with caution and understanding of their limitations.  
First, they will affect performance, depending on the level (set via the \soarb{timers} parameter).  
A level of \soarb{three}, for instance, times every step in the cue-based retrieval candidate episode search.  
Furthermore, because these iterations are relatively cheap (typically a single step in the linked-list of a b+-tree), timer values are typically unreliable (depending upon the system, resolution is 1 microsecond more).

