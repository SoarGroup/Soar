/* Auto-generated by gen_cli_help.sh on Mon Oct  9 16:13:48 EDT 2017 */
#include "portability.h"

#include "cli_CommandLineInterface.h"
#include "sml_Names.h"

#include <map>

using namespace cli;
using namespace sml;

std::map<std::string, const char*> docstrings;

void initdocstrings();

bool CommandLineInterface::Print_9_4_Help_Mapping(std::string pCmd, const char* pNewCmd, const char* pNewCmdFull)
{
    std::map<std::string, const char*>::iterator i;

    if ((i = docstrings.find(pNewCmd)) != docstrings.end())
    {
        m_Result << i->second;
        m_Result << std::endl << "Note: This was the '" << pNewCmd << "' help page.  The '" << pCmd << "' command is now '" << pNewCmdFull << "'." << std::endl;
        return true;
    }
    return false;
}

bool CommandLineInterface::Find_Closest_Help_Command(const std::string pCmd)
{
    std::list<std::string> foundList;
    std::string lStr;

    for (auto it = docstrings.begin(); it != docstrings.end(); it++)
    {
        lStr = it->first;
        if (lStr.find(pCmd) == 0)
        {
            foundList.push_back(lStr);
        }
    }
    if (foundList.empty())
    {
        return false;
    }
    else if (foundList.size() == 1)
    {
        std::map<std::string, const char*>::iterator i;

        if ((i = docstrings.find(foundList.front())) != docstrings.end())
        {
            m_Result << i->second;
            return true;
        }
    } else {
        m_Result << "I'm not sure which help page you want.  Did you mean";
        std::string lastOption("");
        bool firstItem = true;
        for (auto it = foundList.begin(); it != foundList.end(); it++)
        {
            if (!lastOption.empty())
            {
                m_Result << (((firstItem || (foundList.size() == 2))) ? " " : ", ") << lastOption;
                firstItem = false;
            }
            lastOption = *it;
        }
        m_Result << " or " << lastOption << "?\n";
    }

    return true;
}

bool CommandLineInterface::DoHelp(const std::vector<std::string>& argv)
{
    std::map<std::string, const char*>::iterator i;
    
    if (docstrings.size() == 0)
    {
        initdocstrings();
    }
    
    if (argv.size() == 1)
    {
        m_Result << "Soar " << sml_Names::kSoarVersionValue << " Command List:" << std::endl << std::endl;
        for (i = docstrings.begin(); i != docstrings.end(); ++i)
        {
            m_Result << i->first << std::endl;
        }
        m_Result << "\nTo read an in-depth description of the command:               help <command>\n" <<
                    "To get a quick summary of sub-command and settings:           <command> ?\n";
        m_Result << "\nNote:  Many previous Soar commands are now sub-commands. To locate a help \n"
                      "       entry, try 'help <old command name>'.";
    }
    else
    {
        if ((i = docstrings.find(argv[1])) == docstrings.end())
        {
            /* If user does a help on a command whose name changed in 9.6.0, give them a little help */
            if (argv[1] == std::string("gds-print")) Print_9_4_Help_Mapping(argv[1], "print", "print --gds");
            else if (argv[1] == std::string("unalias")) Print_9_4_Help_Mapping(argv[1], "alias", "alias -r");
            else if (argv[1] == std::string("capture-input")) Print_9_4_Help_Mapping(argv[1], "save", "save percepts");
            else if (argv[1] == std::string("learn")) Print_9_4_Help_Mapping(argv[1], "chunk", "chunk");
            else if (argv[1] == std::string("watch")) Print_9_4_Help_Mapping(argv[1], "trace", "trace");

            else if (argv[1] == std::string("chunk-name-format")) Print_9_4_Help_Mapping(argv[1], "chunk", "chunk naming-style");
            else if (argv[1] == std::string("max-chunks")) Print_9_4_Help_Mapping(argv[1], "chunk", "chunk max-chunks");

            else if (argv[1] == std::string("allocate")) Print_9_4_Help_Mapping(argv[1], "debug", "debug allocate");
            else if (argv[1] == std::string("internal-symbols")) Print_9_4_Help_Mapping(argv[1], "debug", "debug internal-symbols");
            else if (argv[1] == std::string("port")) Print_9_4_Help_Mapping(argv[1], "debug", "debug port");
            else if (argv[1] == std::string("time")) Print_9_4_Help_Mapping(argv[1], "debug", "debug time");

            else if (argv[1] == std::string("indifferent-selection")) Print_9_4_Help_Mapping(argv[1], "decide", "decide indifferent-selection");
            else if (argv[1] == std::string("numeric-indifferent-mode")) Print_9_4_Help_Mapping(argv[1], "decide", "decide numeric-indifferent-mode");
            else if (argv[1] == std::string("predict")) Print_9_4_Help_Mapping(argv[1], "decide", "decide predict");
            else if (argv[1] == std::string("select")) Print_9_4_Help_Mapping(argv[1], "decide", "decide select");

            else if (argv[1] == std::string("load-library")) Print_9_4_Help_Mapping(argv[1], "load", "load library");
            else if (argv[1] == std::string("source")) Print_9_4_Help_Mapping(argv[1], "load", "load file");
            else if (argv[1] == std::string("replay-input")) Print_9_4_Help_Mapping(argv[1], "load", "load percepts");
            else if (argv[1] == std::string("rete-net")) Print_9_4_Help_Mapping(argv[1], "load", "load rete-net (also see 'save')");

            else if (argv[1] == std::string("clog")) Print_9_4_Help_Mapping(argv[1], "output", "output log");
            else if (argv[1] == std::string("command-to-file")) Print_9_4_Help_Mapping(argv[1], "output", "output command-to-file");
            else if (argv[1] == std::string("default-wme-depth")) Print_9_4_Help_Mapping(argv[1], "output", "output print-depth");
            else if (argv[1] == std::string("warnings")) Print_9_4_Help_Mapping(argv[1], "output", "output warnings");

            else if (argv[1] == std::string("excise")) Print_9_4_Help_Mapping(argv[1], "production", "production excise");
            else if (argv[1] == std::string("firing-counts")) Print_9_4_Help_Mapping(argv[1], "production", "production firing-counts");
            else if (argv[1] == std::string("matches")) Print_9_4_Help_Mapping(argv[1], "production", "production matches");
            else if (argv[1] == std::string("memories")) Print_9_4_Help_Mapping(argv[1], "production", "production memory-usage");
            else if (argv[1] == std::string("multi-attributes")) Print_9_4_Help_Mapping(argv[1], "production", "production optimize-attribute");
            else if (argv[1] == std::string("pbreak")) Print_9_4_Help_Mapping(argv[1], "production", "production break");
            else if (argv[1] == std::string("production-find")) Print_9_4_Help_Mapping(argv[1], "production", "production find");
            else if (argv[1] == std::string("pwatch")) Print_9_4_Help_Mapping(argv[1], "production", "production watch");

            else if (argv[1] == std::string("cli")) Print_9_4_Help_Mapping(argv[1], "soar", "soar tcl");
            else if (argv[1] == std::string("gp-max")) Print_9_4_Help_Mapping(argv[1], "soar", "soar gp-max");
            else if (argv[1] == std::string("init-soar")) Print_9_4_Help_Mapping(argv[1], "soar", "soar init");
            else if (argv[1] == std::string("max-dc-time")) Print_9_4_Help_Mapping(argv[1], "soar", "soar max-dc-time");
            else if (argv[1] == std::string("max-elaborations")) Print_9_4_Help_Mapping(argv[1], "soar", "soar max-elaborations");
            else if (argv[1] == std::string("max-goal-depth")) Print_9_4_Help_Mapping(argv[1], "soar", "soar max-goal-depth");
            else if (argv[1] == std::string("max-memory-usage")) Print_9_4_Help_Mapping(argv[1], "soar", "soar max-memory-usage");
            else if (argv[1] == std::string("max-nil-output-cycles")) Print_9_4_Help_Mapping(argv[1], "soar", "soar max-nil-output-cycles");
            else if (argv[1] == std::string("srand")) Print_9_4_Help_Mapping(argv[1], "soar", "soar srand");
            else if (argv[1] == std::string("stop-soar")) Print_9_4_Help_Mapping(argv[1], "soar", "soar stop-soar");
            else if (argv[1] == std::string("set-stop-phase")) Print_9_4_Help_Mapping(argv[1], "soar", "soar set-stop-phase");
            else if (argv[1] == std::string("timers")) Print_9_4_Help_Mapping(argv[1], "soar", "soar timers");
            else if (argv[1] == std::string("version")) Print_9_4_Help_Mapping(argv[1], "soar", "soar version");
            else if (argv[1] == std::string("waitsnc")) Print_9_4_Help_Mapping(argv[1], "soar", "soar waitsnc");

            else if (argv[1] == std::string("wma")) Print_9_4_Help_Mapping(argv[1], "wm", "wm activation");
            else if (argv[1] == std::string("add-wme")) Print_9_4_Help_Mapping(argv[1], "wm", "wm add");
            else if (argv[1] == std::string("remove-wme")) Print_9_4_Help_Mapping(argv[1], "wm", "wm remove");
            else if (argv[1] == std::string("watch-wmes")) Print_9_4_Help_Mapping(argv[1], "wm", "wm watch");
            else if (!Find_Closest_Help_Command(argv[1]))
            {
                m_Result << "No such command '" << argv[1] << "'." << std::endl;
                return false;
            }
            return true;
        }
        m_Result << i->second;
    }
    return true;
}

void initdocstrings()
{
	docstrings["alias"] = 
		"Define a new alias of existing commands and arguments.\n"
		"\n"
		"Synopsis\n"
		"\n"
		"  alias\n"
		"  alias <name> [args]\n"
		"  alias -r <name>\n"
		"\n"
		"Adding a new alias\n"
		"\n"
		"This command defines new aliases by creating Soar procedures with the given\n"
		"name. The new procedure can then take an arbitrary number of arguments which\n"
		"are post-pended to the given definition and then that entire string is executed\n"
		"as a command. The definition must be a single command, multiple commands are\n"
		"not allowed. The alias procedure checks to see if the name already exists, and\n"
		"does not destroy existing procedures or aliases by the same name. Existing\n"
		"aliases can be removed by using the unalias command.\n"
		"\n"
		"Removing an existing alias\n"
		"\n"
		"To undefine a previously created alias, use the -r argument along with the name\n"
		"of the alias to remove.\n"
		"alias -r existing-alias\n"
		"Note: If you are trying to create an alias for a command that also has a -\n"
		"r option, make sure to enclose it in quotes. For example:\n"
		"alias unalias \"alias -r\"\n"
		"\n"
		"Printing Existing Aliases\n"
		"\n"
		"With no arguments, alias returns the list of defined aliases. With only the\n"
		"name given, alias returns the current definition.\n"
		"\n"
		"Examples\n"
		"\n"
		"The alias wmes is defined as:\n"
		"\n"
		"  alias wmes print -i\n"
		"\n"
		"If the user executes a command such as:\n"
		"\n"
		"  wmes {(* ^superstate nil)}\n"
		"\n"
		"... it is as if the user had typed this command:\n"
		"\n"
		"  print -i {(* ^superstate nil)}\n"
		"\n"
		"To check what a specific alias is defined as, you would type\n"
		"\n"
		"  alias wmes\n"
		"\n"
		"Default Alias Aliases\n"
		"\n"
		"  a               alias\n"
		"  unalias, un     alias -r\n"
	;
	docstrings["chunk"] = 
		"Sets the parameters for explanation-based chunking.\n"
		"\n"
		"Synopsis\n"
		"\n"
		"  ===================================================\n"
		"             Chunk Commands and Settings\n"
		"  ===================================================\n"
		"  ? | help                                              Print this help listing\n"
		"  timers                                 [ on | OFF ]   Timing statistics (no args to print stats)\n"
		"  stats                                                 Print statistics on learning\n"
		"  ------------------- Settings ----------------------\n"
		"  always | NEVER | only | except                        When Soar will learn new rules\n"
		"  bottom-only                            [ on | OFF ]   Learn only from bottom sub-state\n"
		"  naming-style                     [ numbered | RULE]   Numeric names or rule-based names\n"
		"  max-chunks                                 50         Max chunks learned per phase\n"
		"  max-dupes                                   3         Max duplicate chunks (per rule, per phase)\n"
		"  ------------------- Debugging ---------------------\n"
		"  interrupt                              [ on | OFF ]   Stop after learning from any rule\n"
		"  explain-interrupt                      [ on | OFF ]   Stop after learning watched rule\n"
		"  warning-interrupt                      [ on | OFF ]   Stop after detecting learning issue\n"
		"  ------------------- Fine Tune ---------------------\n"
		"  singleton                                             Print all WME singletons\n"
		"  singleton                <type> <attribute> <type>    Add a WME singleton pattern\n"
		"  singleton -r             <type> <attribute> <type>    Remove a WME singleton pattern\n"
		"  ----------------- EBC Mechanisms ------------------\n"
		"  add-ltm-links                          [ on | OFF ]   Recreate LTM links in results\n"
		"  add-osk                                [ on | OFF ]   Incorporate operator selection rules\n"
		"  merge                                  [ ON | off ]   Merge redundant conditions\n"
		"  lhs-repair                             [ ON | off ]   Add conds for unconnected LHS IDs\n"
		"  rhs-repair                             [ ON | off ]   Add conds for unconnected RHS IDs\n"
		"  user-singletons                        [ ON | off ]   Unify with domain singletons\n"
		"  ---------- Correctness Guarantee Filters ----------     Allow rules to form that...\n"
		"  allow-local-negations                  [ ON | off ]   ...used local negative reasoning\n"
		"  allow-opaque*                          [ ON | off ]   ...used knowledge from a LTM recall\n"
		"  allow-missing-osk*                     [ ON | off ]   ...tested operators selected through OSK\n"
		"  allow-uncertain-operators*             [ ON | off ]   ...tested operators selected probabilistically\n"
		"  * disabled\n"
		"  ---------------------------------------------------\n"
		"\n"
		"  To change a setting:                                  chunk <setting>\n"
		"  [<value>]\n"
		"  For a detailed explanation of these settings:         help chunk\n"
		"\n"
		"Description\n"
		"\n"
		"The chunk command controls the parameters for explanation-based chunking. With\n"
		"no arguments, this command prints out a basic summary of the current learning\n"
		"parameters, how many rules have been learned and which states have learning\n"
		"active. With an ? argument, it will list all sub-commands, options and their\n"
		"current values.\n"
		"\n"
		"Turning on Explanation-Based Chunking\n"
		"\n"
		"Chunking is disabled by default. Learning can be turned on or off at any point\n"
		"during a run. Also note that Soar uses most aspects of EBC to create\n"
		"justifications as well, so many aspects of the chunking algorithm still occur\n"
		"even when learning is off.\n"
		"\n"
		"  chunk always:      Soar will always attempt to learn rules from sub-state\n"
		"                     problem-solving.\n"
		"  chunk never:       Soar will never attempt to learn rules.\n"
		"  chunk unflagged:   Chunking is on in all states _except_ those that have had\n"
		"  RHS\n"
		"                     `dont-learn` actions executed in them.\n"
		"  chunk flagged:     Chunking is off for all states except those that are\n"
		"  flagged\n"
		"                     via a RHS `force-learn` actions.\n"
		"\n"
		"The flagged argument and its companion force-learn RHS action allow Soar\n"
		"developers to turn learning on in a particular problem space, so that they can\n"
		"focus on debugging the learning problems in that particular problem space\n"
		"without having to address the problems elsewhere in their programs at the same\n"
		"time. Similarly, the unflagged flag and its companion dont-learn RHS action\n"
		"allow developers to temporarily turn learning off for debugging purposes. These\n"
		"facilities are provided as debugging tools, and do not correspond to any theory\n"
		"of learning in Soar.\n"
		"The bottom-only setting control when chunks are formed when there are multiple\n"
		"levels of subgoals. With bottom-up learning, chunks are learned only in states\n"
		"in which no subgoal has yet generated a chunk. In this mode, chunks are learned\n"
		"only for the \"bottom\" of the subgoal hierarchy and not the intermediate levels.\n"
		"With experience, the subgoals at the bottom will be replaced by the chunks,\n"
		"allowing higher level subgoals to be chunked.\n"
		"\n"
		"Debugging Explanation-Based Chunking\n"
		"\n"
		"The best way to understand why and how rules formed is to use the explain\n"
		"command. It will create detailed snapshots of everything that existed when a\n"
		"rule or justification formed that you can interactively explore. See explain\n"
		"for more information. You can even use it in conjunction with the visualizer to\n"
		"create graphs depicting the dependency between rules in a sub-state.\n"
		"The stats command will print a detailed table containing statistics about all\n"
		"chunking activity during that run.\n"
		"The interrupt setting forces Soar to stop after forming any rule.\n"
		"The explain-interrupt setting forces Soar to stop when it attempts to form a\n"
		"rule from a production that is being watched by the explainer. See explain for\n"
		"more information.\n"
		"The warning interrupts setting forces Soar to stop when it attempts to form a\n"
		"rule but detects an issue that may be problematic.\n"
		"The record-utility command is a tool to determine how much processing may be\n"
		"saved by a particular learned rule. When enabled, Soar will detect that a chunk\n"
		"matched, but will not fire it. Assuming that the rule is correct, this should\n"
		"lead to an impasse that causes a duplicate chunk to form. The amount of time\n"
		"and decision cycles spent in that impasse are recorded and stored for the rule.\n"
		"Rules are also flagged if a duplicate is not detected or if an impasse is not\n"
		"generated.\n"
		"This feature is not yet implemented.\n"
		"\n"
		"Preventing Possible Correctness Issues\n"
		"\n"
		"chunk allow-local-negations\n"
		"\n"
		"The option allow-local-negations control whether or not chunks can be created\n"
		"that are derived from rules that check local WMEs in the substate don't exist.\n"
		"Chunking through local negations can result in overgeneral chunks, but\n"
		"disabling this ability will reduce the number of chunks formed. The default is\n"
		"to enable chunking through local negations.\n"
		"If chunking through local negations is disabled, to see when chunks are\n"
		"discarded (and why), set watch --learning print (see watch command).\n"
		"The following commands are not yet enabled. Soar will currently allow all of\n"
		"these situations.\n"
		"\n"
		"allow-missing-osk\n"
		"\n"
		"Used operator selection rules to choose operator\n"
		"\n"
		"allow-opaque\n"
		"\n"
		"Used knowledge from opaque knowledge retrieval\n"
		"\n"
		"allow-uncertain-operators\n"
		"\n"
		"Used operators selected probabilistically\n"
		"\n"
		"allow-conflated-reasoning\n"
		"\n"
		"Tests a WME that has multiple reasons it exists\n"
		"\n"
		"Other Settings that Control WHEN Rules are Learned\n"
		"\n"
		"chunk max-chunks\n"
		"\n"
		"The max-chunks command is used to limit the maximum number of chunks that may\n"
		"be created during a decision cycle. The initial value of this variable is 50;\n"
		"allowable settings are any integer greater than 0.\n"
		"The chunking process will end after max-chunks chunks have been created, even\n"
		"if there are more results that have not been backtraced through to create\n"
		"chunks, and Soar will proceed to the next phase. A warning message is printed\n"
		"to notify the user that the limit has been reached.\n"
		"This limit is included in Soar to prevent getting stuck in an infinite loop\n"
		"during the chunking process. This could conceivably happen because newly-built\n"
		"chunks may match immediately and are fired immediately when this happens; this\n"
		"can in turn lead to additional chunks being formed, etc.\n"
		"Important note:\n"
		"If you see this warning, something is seriously wrong; Soar will be unable to\n"
		"guarantee consistency of its internal structures. You should not continue\n"
		"execution of the Soar program in this situation; stop and determine whether\n"
		"your program needs to build more chunks or whether you've discovered a bug (in\n"
		"your program or in Soar itself).\n"
		"\n"
		"chunk max-dupes\n"
		"\n"
		"The max-dupes command is used to limit the maximum number of duplicate chunks\n"
		"that can form from a particular rule in a single decision cycle. The initial\n"
		"value of this variable is 3; allowable settings are any integer greater than 0.\n"
		"Note that this limit is per-rule, per-state. With the default value, each rule\n"
		"can match three times in a sub-state and create two duplicate, reject rules\n"
		"before Soar will stop attempting to create new rules based on that rule. The\n"
		"limit is reset the next decision cycle.\n"
		"This limit is included in Soar to prevent slowing down when multiple matches of\n"
		"a rule in a substate produce the same general rule. Explanation-based chunking\n"
		"can now produce very general chunks, so this can happen in problem states in\n"
		"which the logic leads to multiple matches, which leads to results being created\n"
		"multiple times in the same decision cycle.\n"
		"\n"
		"Settings that Alter the Mechanisms that EBC Uses\n"
		"\n"
		"chunk add-osk\n"
		"\n"
		"The option add-osk control whether or not operator selection knowledge is\n"
		"backtraced through when creating justifications and chunks. When this option is\n"
		"disabled, only requirement preferences (requires and prohibits) will be added\n"
		"backtraced through. When this option is enabled, relevant desirability prefs\n"
		"(better, best, worse, worst, indifferent) will also be added, producing more\n"
		"specific and possibly correct chunks. This feature is still experimental, so\n"
		"the default is to not include operator selection knowledge.\n"
		"The following commands are not yet enabled. Soar will always use the EBC\n"
		"mechanisms listed below.\n"
		"\n"
		"variablize-identity\n"
		"\n"
		"Variablize symbols based on identity analysis\n"
		"\n"
		"variablize-rhs-funcs\n"
		"\n"
		"Variablize and compose RHS functions\n"
		"\n"
		"enforce-constraints\n"
		"\n"
		"Track and enforce transitive constraints\n"
		"\n"
		"repair\n"
		"\n"
		"Repair rules that aren't fully connected\n"
		"\n"
		"merge\n"
		"\n"
		"Merge redundant conditions\n"
		"\n"
		"user-singletons\n"
		"\n"
		"Unify identities using domain-specific singletons\n"
		"\n"
		"Chunk Naming Style\n"
		"\n"
		"The numbered style for naming newly-created chunks is:\n"
		"\n"
		"  <prefix><chunknum>\n"
		"\n"
		"The rule-based (default) style for naming chunks is:\n"
		"\n"
		"  <prefix>*<original-rule-name>*<impassetype>*<dc>-<dcChunknum>\n"
		"\n"
		"where:\n"
		"\n"
		"* prefix is either chunk or justification, depending on whether learning was on\n"
		"  for that state,\n"
		"* chunknum is a counter starting at 1 for the first chunk created,\n"
		"* original-rule-name is the name of the production that produced the result\n"
		"  that resulted in this chunk,\n"
		"* dc is the number of the decision cycle in which the chunk was formed,\n"
		"* impassetype is one of Tie, Conflict, Failure, StateNoChange, OpNoChange,\n"
		"* dcChunknum is the number of the chunk within that specific decision cycle.\n"
		"\n"
		"Note that when using the rule-based naming format, a chunk based on another\n"
		"chunk will have a name that begins with prefix followed by -xN, for example\n"
		"chunk-x3*apply-rule*42-2.\n"
		"\n"
		"Default Aliases\n"
		"\n"
		"  learn    chunk\n"
		"  cs       chunk --stats\n"
		"\n"
		"See Also\n"
		"\n"
		"explain trace visualize\n"
	;
	docstrings["debug"] = 
		"Contains commands that provide access to Soar's internals. Most users will not\n"
		"need to access these commands.\n"
		"\n"
		"Synopsis\n"
		"\n"
		"  ======================================================================\n"
		"                       Debug Commands and Settings\n"
		"  ======================================================================\n"
		"  allocate [pool blocks]         Allocates extra memory to a memory pool\n"
		"  internal-symbols                                   Prints symbol table\n"
		"  port                                             Prints listening port\n"
		"  time <command> [args]           Executes command and prints time spent\n"
		"\n"
		"debug allocate\n"
		"\n"
		"  debug allocate [pool blocks]\n"
		"\n"
		"This allocate command allocates additional blocks of memory for a specified\n"
		"memory pool. Each block is 32 kilobyte.\n"
		"Soar allocates blocks of memory for its memory pools as it is needed during a\n"
		"run (or during other actions like loading productions). Unfortunately, this\n"
		"behavior translates to an increased run time for the first run of a memory-\n"
		"intensive agent. To mitigate this, blocks can be allocated before a run by\n"
		"using this command.\n"
		"Issuing the command with no parameters lists current pool usage, exactly like\n"
		"stats command's memory flag.\n"
		"Issuing the command with part of a pool's name and a positive integer will\n"
		"allocate that many additional blocks for the specified pool. Only the first few\n"
		"letters of the pool's name are necessary. If more than one pool starts with the\n"
		"given letters, which pool will be chosen is unspecified.\n"
		"Memory pool block size in this context is approximately 32 kilobytes, the exact\n"
		"size determined during agent initialization.\n"
		"\n"
		"debug internal-symbols\n"
		"\n"
		"The internal-symbols command prints information about the Soar symbol table.\n"
		"Such information is typically only useful for users attempting to debug Soar by\n"
		"locating memory leaks or examining I/O structure.\n"
		"\n"
		"debug port\n"
		"\n"
		"The port command prints the port the kernel instance is listening on.\n"
		"\n"
		"debug time\n"
		"\n"
		"  debug time command [arguments]\n"
		"\n"
		"The time command uses a system clock timer to record the time spent while\n"
		"executing a command. The most common use for this is to time how long an agent\n"
		"takes to run.\n"
		"\n"
		"See Also\n"
		"\n"
		"stats\n"
	;
	docstrings["decide"] = 
		"Commands and settings related to the selection of operators during the Soar\n"
		"decision process\n"
		"\n"
		"Synopsis\n"
		"\n"
		"  =============================================================================\n"
		"  -                      Decide Sub-Commands and Options                      -\n"
		"  =============================================================================\n"
		"  decide                          [? | help]\n"
		"  -----------------------------------------------------------------------------\n"
		"  decide numeric-indifferent-mode [--avg --sum]\n"
		"  -----------------------------------------------------------------------------\n"
		"  decide indifferent-selection\n"
		"  decide indifferent-selection   <policy>\n"
		"                                 <policy> = [--boltzmann | --epsilon-greedy |\n"
		"                                             --first | --last | -- softmax ]\n"
		"  decide indifferent-selection   <param> [value]\n"
		"                                 <param> = [--epsilon --temperature]\n"
		"  decide indifferent-selection   [--reduction-policy| -p] <param> [<policy>]\n"
		"  decide indifferent-selection   [--reduction-rate| -r] <param> <policy> [<rate>]\n"
		"  decide indifferent-selection   [--auto-reduce] [setting]\n"
		"  decide indifferent-selection   [--stats]\n"
		"  ----------------------------------------------------------------------------\n"
		"  decide predict\n"
		"  decide select                  <operator ID>\n"
		"  -----------------------------------------------------------------------------\n"
		"  decide set-random-seed         [<seed>]\n"
		"  -----------------------------------------------------------------------------\n"
		"  For a detailed explanation of sub-commands:    help decide\n"
		"\n"
		"Summary Screen\n"
		"\n"
		"Using the decide command without any arguments will display key elements of\n"
		"Soar's current decision settings:\n"
		"\n"
		"  =======================================================\n"
		"                       Decide Summary\n"
		"  =======================================================\n"
		"  Numeric indifference mode:                          sum\n"
		"  -------------------------------------------------------\n"
		"  Exploration Policy:                             softmax\n"
		"  Automatic Policy Parameter Reduction:               off\n"
		"  Epsilon:                                       0.100000\n"
		"  Epsilon Reduction Policy:                   exponential\n"
		"  Temperature:                                  25.000000\n"
		"  Temperature Reduction Policy:               exponential\n"
		"  -------------------------------------------------------\n"
		"\n"
		"  Use 'decide ?' for a command overview or 'help decide' for the manual page.\n"
		"\n"
		"decide numeric-indifferent-mode\n"
		"\n"
		"The numeric-indifferent-mode command sets how multiple numeric indifferent\n"
		"preference values given to an operator are combined into a single value for use\n"
		"in random selection.\n"
		"The default procedure is --sum which sums all numeric indifferent preference\n"
		"values given to the operator, defaulting to 0 if none exist. The alternative --\n"
		"avg mode will average the values, also defaulting to 0 if none exist.\n"
		"\n"
		"decide indifferent-selection\n"
		"\n"
		"The indifferent-selection command allows the user to set options relating to\n"
		"selection between operator proposals that are mutually indifferent in\n"
		"preference memory.\n"
		"The primary option is the exploration policy (each is covered below). When Soar\n"
		"starts, softmax is the default policy.\n"
		"Note: As of version 9.3.2, the architecture no longer automatically changes the\n"
		"policy to epsilon-greedy the first time Soar-RL is enabled.\n"
		"Some policies have parameters to temper behavior. The indifferent-selection\n"
		"command provides basic facilities to automatically reduce these parameters\n"
		"exponentially and linearly each decision cycle by a fixed rate. In addition to\n"
		"setting these policies/rates, the auto-reduce option enables the automatic\n"
		"reduction system (disabled by default), for which the Soar decision cycle\n"
		"incurs a small performance cost.\n"
		"\n"
		"indifferent-selection options:\n"
		"\n"
		"Option                                  Description\n"
		"-s, --stats                             Summary of settings\n"
		"policy                                  Set exploration policy\n"
		"parameter [exploration policy           Get/Set exploration policy parameters\n"
		"parameters]                             (if value not given, returns the\n"
		"                                        current value)\n"
		"                                        Get/Set exploration policy parameter\n"
		"parameter [reduction_policy](value]     reduction policy (if policy not given,\n"
		"                                        returns the current)\n"
		"parameter reduction_policy [exploration Get/Set exploration policy parameter\n"
		"policy parameter]                       reduction rate for a policy (if rate\n"
		"                                        not give, returns the current)\n"
		"-a, --auto-reduce [on,off](reduction-   Get/Set auto-reduction setting (if\n"
		"rate]                                   setting not provided, returns the\n"
		"                                        current)\n"
		"\n"
		"indifferent-selection exploration policies:\n"
		"\n"
		"Option               Description\n"
		"-b, --boltzmann      Tempered softmax (uses temperature)\n"
		"-g, --epsilon-greedy Tempered greedy (uses epsilon)\n"
		"                     Random, biased by numeric indifferent values (if a non-\n"
		"-x, --softmax        positive value is encountered, resorts to a uniform random\n"
		"                     selection)\n"
		"-f, --first          Deterministic, first indifferent preference is selected\n"
		"-l, --last           Deterministic, last indifferent preference is selected\n"
		"\n"
		"indifferent-selection exploration policy parameters:\n"
		"\n"
		"Parameter Name    Acceptable Values Default Value\n"
		"-e, --epsilon     [0, 1]            0.1\n"
		"-t, --temperature (0, inf)          25\n"
		"\n"
		"indifferent-selection auto-reduction policies:\n"
		"\n"
		"Parameter Name      Acceptable Values Default Value\n"
		"exponential default [0, 1]            1\n"
		"linear              [0, inf]          0\n"
		"\n"
		"decide predict\n"
		"\n"
		"The predict command determines, based upon current operator proposals, which\n"
		"operator will be chosen during the next decision phase. If predict determines\n"
		"an operator tie will be encountered, \"tie\" is returned. If predict determines\n"
		"no operator will be selected (state no-change), \"none\" is returned. If predict\n"
		"determines a conflict will arise during the decision phase, \"conflict\" is\n"
		"returned. If predict determines a constraint failure will occur, \"constraint\"\n"
		"is returned. Otherwise, predict will return the id of the operator to be\n"
		"chosen. If operator selection will require probabilistic selection, and no\n"
		"alterations to the probabilities are made between the call to predict and\n"
		"decision phase, predict will manipulate the random number generator to enforce\n"
		"its prediction.\n"
		"\n"
		"decide select\n"
		"\n"
		"The select command will force the selection of an operator, whose id is\n"
		"supplied as an argument, during the next decision phase. If the argument is not\n"
		"a proposed operator in the next decision phase, an error is raised and operator\n"
		"selection proceeds as if the select command had not been called. Otherwise, the\n"
		"supplied operator will be selected as the next operator, regardless of\n"
		"preferences. If select is called with no id argument, the command returns the\n"
		"operator id currently forced for selection (by a previous call to select), if\n"
		"one exists.\n"
		"\n"
		"Example\n"
		"\n"
		"Assuming operator \"O2\" is a valid operator, this would select it as the next\n"
		"operator to be selected:\n"
		"\n"
		"  decide select O2\n"
		"\n"
		"decide set-random-seed\n"
		"\n"
		"Seeds the random number generator with the passed seed. Calling decide set-\n"
		"random-seed (or equivalently, decide srand) without providing a seed will seed\n"
		"the generator based on the contents of /dev/urandom (if available) or else\n"
		"based on time() and clock() values.\n"
		"\n"
		"Example\n"
		"\n"
		"  decide set-random-seed 23\n"
		"\n"
		"Default Aliases\n"
		"\n"
		"  inds           indifferent-selection\n"
		"  srand          set-random-seed\n"
		"\n"
		"See Also\n"
		"\n"
		"rl\n"
	;
	docstrings["echo"] = 
		"Print a string to the current output device.\n"
		"\n"
		"Synopsis\n"
		"\n"
		"  echo [--nonewline] [string]\n"
		"\n"
		"Options\n"
		"\n"
		"Option          Description\n"
		"string          The string to print.\n"
		"-n, --nonewline Supress printing of the newline character\n"
		"\n"
		"Description\n"
		"\n"
		"This command echos the args to the current output stream. This is normally\n"
		"stdout but can be set to a variety of channels. If an arg is --nonewline then\n"
		"no newline is printed at the end of the printed strings. Otherwise a newline is\n"
		"printed after printing all the given args. Echo is the easiest way to add user\n"
		"comments or identification strings in a log file.\n"
		"\n"
		"Example\n"
		"\n"
		"This example will add these comments to the screen and any open log file.\n"
		"\n"
		"  echo This is the first run with disks = 12\n"
		"\n"
		"See Also\n"
		"\n"
		"clog\n"
	;
	docstrings["epmem"] = 
		"Control the behavior of episodic memory.\n"
		"\n"
		"Synopsis\n"
		"\n"
		"  epmem\n"
		"  epmem -e|--enable|--on\n"
		"  epmem -d|--disable|--off\n"
		"  epmem -i|--init\n"
		"  epmem -c|--close\n"
		"  epmem -g|--get <parameter>\n"
		"  epmem -s|--set <parameter> <value>\n"
		"  epmem -S|--stats [<statistic>]\n"
		"  epmem -t|--timers [<timer>]\n"
		"  epmem -v|--viz <episode id>\n"
		"  epmem -p|--print <episode id>\n"
		"  epmem -b|--backup <file name>\n"
		"\n"
		"Options:\n"
		"\n"
		"Option               Description\n"
		"-e, --enable, --on   Enable episodic memory.\n"
		"-d, --disable, --off Disable episodic memory.\n"
		"-i, --init           Re-initialize episodic memory\n"
		"-c, --close          Disconnect from episodic memory\n"
		"-g, --get            Print current parameter setting\n"
		"-s, --set            Set parameter value\n"
		"-S, --stats          Print statistic summary or specific statistic\n"
		"-t, --timers         Print timer summary or specific statistic\n"
		"-v, --viz            Print episode in graphviz format\n"
		"-p, --print          Print episode in user-readable format\n"
		"-b, --backup         Creates a backup of the episodic database on disk\n"
		"\n"
		"Description\n"
		"\n"
		"The epmem command is used to change all behaviors of the episodic memory\n"
		"module, except for watch output, which is controlled by the trace --epmem\n"
		"command.\n"
		"\n"
		"Parameters\n"
		"\n"
		"Due to the large number of parameters, the epmem command uses the --get|--set\n"
		"<parameter> <value> convention rather than individual switches for each\n"
		"parameter. Running epmem without any switches displays a summary of the\n"
		"parameter settings.\n"
		"\n"
		"Main Parameters:\n"
		"\n"
		"Parameter  Description                        Possible values       Default\n"
		"           Controls whether database is\n"
		"append     overwritten or appended when       on, off               off\n"
		"           opening or re-initializing\n"
		"           Linear weight of match cardinality\n"
		"balance    (1) vs. working memory activation  [0, 1]                1\n"
		"           (0) used in calculating match\n"
		"           score\n"
		"database   Database storage method            file, memory          memory\n"
		"exclusions Toggle the exclusion of an         any string            epmem, smem\n"
		"           attribute string constant\n"
		"force      Forces episode encoding/ignoring   ignore, remember, off off\n"
		"           in the next storage phase\n"
		"learning   Episodic memory enabled            on, off               off\n"
		"           Controls how retrievals interact\n"
		"merge      with long-term identifiers in      none, add             none\n"
		"           working memory\n"
		"path       Location of database file          empty, some path      empty\n"
		"           Decision cycle phase to encode new\n"
		"phase      episodes and process epmem link    output, selection     output\n"
		"           commands\n"
		"trigger    How episode encoding is triggered  dc, output, none      output\n"
		"\n"
		"Performance Parameters:\n"
		"\n"
		"Parameter            Description              Possible values      Default\n"
		"cache-size           Number of memory pages   1, 2, ...            10000\n"
		"                     used in the SQLite cache\n"
		"graph-match          Graph matching enabled   on, off              on\n"
		"graph-match-ordering Ordering of identifiers  undefined, dfs, mcv  undefined\n"
		"                     during graph match\n"
		"                     Delay writing semantic\n"
		"lazy-commit          store changes to file    on, off              on\n"
		"                     until agent exits\n"
		"optimization         Policy for committing    safety, performance  performance\n"
		"                     data to disk\n"
		"page-size            Size of each memory page 1k, 2k, 4k, 8k, 16k, 8k\n"
		"                     used in the SQLite cache 32k, 64k\n"
		"timers               Timer granularity        off, one, two, three off\n"
		"\n"
		"The learning parameter turns the episodic memory module on or off. When\n"
		"learning is set to off, no new episodes are encoded and no commands put on the\n"
		"epmem link are processed. This is the same as using the enable and disable\n"
		"commands.\n"
		"The phase parameter determines which decision cycle phase episode encoding and\n"
		"retrieval will be performed.\n"
		"The trigger parameter controls when new episodes will be encoded. When it is\n"
		"set to output, new episodes will be encoded only if the agent made\n"
		"modifications to the output-link during that decision cycle. When set to 'dc',\n"
		"new episodes will be encoded every decision cycle.\n"
		"The exclusions parameter can be used to prevent episodic memory from encoding\n"
		"parts of working memory into new episodes. The value of exclusions is a list of\n"
		"string constants. During encoding, episodic memory will walk working memory\n"
		"starting from the top state identifier. If it encounters a WME whose attribute\n"
		"is a member of the exclusions list, episodic memory will ignore that WME and\n"
		"abort walking the children of that WME, and they will not be included in the\n"
		"encoded episode. Note that if the children of the excluded WME can be reached\n"
		"from top state via an alternative non-excluded path, they will still be\n"
		"included in the encoded episode. The exclusions parameter behaves differently\n"
		"from other parameters in that issuing epmem --set exclusions <val> does not set\n"
		"its value to <val>. Instead, it will toggle the membership of <val> in the\n"
		"exclusions list.\n"
		"The path parameter specifies the file system path the database is stored in.\n"
		"When path is set to a valid file system path and database mode is set to file,\n"
		"then the SQLite database is written to that path.\n"
		"The append parameter will determine whether all existing episodes recorded in a\n"
		"database on disk will be erased when epmem loads it. Note that this affects\n"
		"episodic memory re-initialization also, i.e. if the append setting is off, all\n"
		"episodic memories stored to disk will be lost when an init-soar is performed.\n"
		"Note that episodic memory cannot currently append to an in-memory database. If\n"
		"you perform an init-soar while using an in-memory database, all current\n"
		"episodes stored will be cleared.\n"
		"Note that changes to database, path and append will not have an effect until\n"
		"the database is used after an initialization. This happens either shortly after\n"
		"launch (on first use) or after a database initialization command is issued. To\n"
		"switch databases or database storage types after running, set your new\n"
		"parameters and then perform an epmem --init.\n"
		"The epmem --backup command can be used to make a copy of the current state of\n"
		"the database, whether in memory or on disk. This command will commit all\n"
		"outstanding changes before initiating the copy.\n"
		"When the database is stored to disk, the lazy-commit and optimization\n"
		"parameters control how often cached database changes are written to disk. These\n"
		"parameters trade off safety in the case of a program crash with database\n"
		"performance. When optimization is set to performance, the agent will have an\n"
		"exclusive lock on the database, meaning it cannot be opened concurrently by\n"
		"another SQLite process such as SQLiteMan. The lock can be relinquished by\n"
		"setting the database to memory or another database and issuing init-soar/epmem\n"
		"--init or by shutting down the Soar kernel.\n"
		"The balance parameter sets the linear weight of match cardinality vs. cue\n"
		"activation. As a performance optimization, when the value is 1 (default),\n"
		"activation is not computed. If this value is not 1 (even close, such as 0.99),\n"
		"and working memory activation is enabled, this value will be computed for each\n"
		"leaf WME, which may incur a noticeable cost, depending upon the overall\n"
		"complexity of the retrieval.\n"
		"The graph-match-ordering parameter sets the heuristic by which identifiers are\n"
		"ordered during graph match (assuming graph-match is on). The default,\n"
		"undefined, does not enforce any order and may be sufficient for small cues. For\n"
		"more complex cues, there will be a one-time sorting cost, during each\n"
		"retrieval, if the parameter value is changed. The currently available\n"
		"heuristics are depth-first search (dfs) and most-constrained variable (mcv). It\n"
		"is advised that you attempt these heuristics to improve performance if the\n"
		"query_graph_match timer reveals that graph matching is dominating retrieval\n"
		"time.\n"
		"The merge parameter controls how the augmentations of retrieved long-term\n"
		"identifiers (LTIs) interact with an existing LTI in working memory. If the LTI\n"
		"is not in working memory or has no augmentations in working memory, this\n"
		"parameter has no effect. If the augmentation is in working memory and has\n"
		"augmentations, by default (none), episodic memory will not augment the LTI. If\n"
		"the parameter is set to add then any augmentations that augmented the LTI in a\n"
		"retrieved episode are added to working memory.\n"
		"\n"
		"Statistics\n"
		"\n"
		"Episodic memory tracks statistics over the lifetime of the agent. These can be\n"
		"accessed using epmem --stats <statistic>. Running epmem --stats without a\n"
		"statistic will list the values of all statistics. Unlike timers, statistics\n"
		"will always be updated. Available statistics are:\n"
		"\n"
		"Name           Label                  Description\n"
		"time           Time                   Current episode ID\n"
		"db-lib-version SQLite Version         SQLite library version\n"
		"mem-usage      Memory Usage           Current SQLite memory usage in bytes\n"
		"mem-high       Memory Highwater       High SQLite memory usage watermark in\n"
		"                                      bytes\n"
		"queries        Queries                Number of times the query command has\n"
		"                                      been processed\n"
		"nexts          Nexts                  Number of times the next command has been\n"
		"                                      processed\n"
		"prevs          Prevs                  Number of times the previous command has\n"
		"                                      been processed\n"
		"ncb-wmes       Last Retrieval WMEs    Number of WMEs added to working memory in\n"
		"                                      last reconstruction\n"
		"qry-pos        Last Query Positive    Number of leaf WMEs in the query cue of\n"
		"                                      last cue-based retrieval\n"
		"qry-neg        Last Query Negative    Number of leaf WMEs in the neg-query cue\n"
		"                                      of the last cue-based retrieval\n"
		"qry-ret        Last Query Retrieved   Episode ID of last retrieval\n"
		"qry-card       Last Query Cardinality Match cardinality of last cue-based\n"
		"                                      retrieval\n"
		"qry-lits       Last Query Literals    Number of literals in the DNF graph of\n"
		"                                      last cue-based retrieval\n"
		"\n"
		"Timers\n"
		"\n"
		"Episodic memory also has a set of internal timers that record the durations of\n"
		"certain operations. Because fine-grained timing can incur runtime costs,\n"
		"episodic memory timers are off by default. Timers of different levels of detail\n"
		"can be turned on by issuing epmem --set timers <level>, where the levels can be\n"
		"off, one, two, or three, three being most detailed and resulting in all timers\n"
		"being turned on. Note that none of the episodic memory statistics nor timing\n"
		"information is reported by the stats command.\n"
		"All timer values are reported in seconds.\n"
		"Level one\n"
		"\n"
		"Timer  Description\n"
		"_total Total epmem operations\n"
		"\n"
		"Level two\n"
		"\n"
		"Timer               Description\n"
		"epmem_api           Agent command validation\n"
		"epmem_hash          Hashing symbols\n"
		"epmem_init          Episodic store initialization\n"
		"epmem_ncb_retrieval Episode reconstruction\n"
		"epmem_next          Determining next episode\n"
		"epmem_prev          Determining previous episode\n"
		"epmem_query         Cue-based query\n"
		"epmem_storage       Encoding new episodes\n"
		"epmem_trigger       Deciding whether new episodes should be encoded\n"
		"epmem_wm_phase      Converting preference assertions to working memory changes\n"
		"\n"
		"Level three\n"
		"\n"
		"Timer                 Description\n"
		"ncb_edge              Collecting edges during reconstruction\n"
		"ncb_edge_rit          Collecting edges from relational interval tree\n"
		"ncb_node              Collecting nodes during reconstruction\n"
		"ncb_node_rit          Collecting nodes from relational interval tree\n"
		"query_cleanup         Deleting dynamic data structures\n"
		"query_dnf             Building the first level of the DNF\n"
		"query_graph_match     Graph match\n"
		"query_result          Putting the episode in working memory\n"
		"query_sql_edge        SQL query for an edge\n"
		"query_sql_end_ep      SQL query for the end of the range of an edge\n"
		"query_sql_end_now     SQL query for the end of the now of an edge\n"
		"query_sql_end_point   SQL query for the end of the point of an edge\n"
		"query_sql_start_ep    SQL query for the start of the range of an edge\n"
		"query_sql_start_now   SQL query for the start of the now of an edge\n"
		"query_sql_start_point SQL query for the start of the point of an edge\n"
		"query_walk            Walking the intervals\n"
		"query_walk_edge       Expanding edges while walking the intervals\n"
		"query_walk_interval   Updating satisfaction while walking the intervals\n"
		"\n"
		"Visualization\n"
		"\n"
		"When debugging agents using episodic memory it is often useful to inspect the\n"
		"contents of individual episodes. Running epmem --viz <episode id> will output\n"
		"the contents of an episode in graphviz format. For more information on this\n"
		"format and visualization tools, see http://www.graphviz.org. The epmem --print\n"
		"option has the same syntax, but outputs text that is similar to using the print\n"
		"command to get the substructure of an identifier in working memory, which is\n"
		"possibly more useful for interactive debugging.\n"
		"\n"
		"See Also\n"
		"\n"
		"trace wm\n"
	;
	docstrings["explain"] = 
		"Allows you to explore how rules were learned.\n"
		"\n"
		"Synopsis\n"
		"\n"
		"  ======= Explainer Commands and Settings =======\n"
		"  explain ?                                             Print this help listing\n"
		"  ---------------- What to Record ---------------\n"
		"  all                                    [ on | OFF ]   Record all rules\n"
		"  learned\n"
		"  justifications                         [ on | OFF ]   Record justifications\n"
		"  record <chunk-name>                                   Record specific rule\n"
		"  list-chunks                                           List all rules learned\n"
		"  list-justifications                                   List all justifications\n"
		"  ----------- Starting an Explanation -----------\n"
		"  chunk [<chunk name> | <chunk id> ]                    Start discussing chunk\n"
		"  formation                                             Describe formation\n"
		"  ----------- Browsing an Explanation -----------\n"
		"  instantiation <inst id>                               Explain instantiation\n"
		"  explanation-trace                                     Switch explanation\n"
		"  trace\n"
		"  wm-trace                                              Switch to WM trace\n"
		"  ------------ Supporting Analysis --------------\n"
		"  constraints                                           Display extra\n"
		"  transitive\n"
		"                                                         constraints required\n"
		"  by\n"
		"                                                         problem-solving\n"
		"  identity                                              Display identity to\n"
		"                                                         identity set mappings\n"
		"  stats                                                 Display statistics\n"
		"  about\n"
		"                                                         currently discussed\n"
		"  chunk\n"
		"  ------------------ Settings -------------------\n"
		"  after-action-report                    [ on | OFF ]   Print statistics to\n"
		"  file\n"
		"                                                         on init and exit\n"
		"  only-chunk-identities                  [ ON | off ]   Identity analysis only\n"
		"                                                         prints identities sets\n"
		"\n"
		"                                                         found in chunk\n"
		"  -----------------------------------------------\n"
		"\n"
		"  To change a setting:                               explain <setting>\n"
		"  [<value>]\n"
		"  For a detailed explanation of these settings:      help explain\n"
		"\n"
		"Summary Screen\n"
		"\n"
		"Using the explain command without any arguments will display a summary of which\n"
		"rule firings the explainer is watching for learning. It also shows which chunk\n"
		"or justification the user has specified is the current focus of its output,\n"
		"i.e. the chunk being discussed.\n"
		"Tip: This is a good way to get a chunk id so that you don't have to type or\n"
		"paste in a chunk name.\n"
		"\n"
		"  =======================================================\n"
		"                     Explainer Summary\n"
		"  =======================================================\n"
		"  Watch all chunk formations                            Yes\n"
		"  Explain justifications                                No\n"
		"  Number of specific rules watched                      0\n"
		"\n"
		"  Chunks available for discussion:                      chunkx2*apply2 (c 14)\n"
		"                                                        chunk*apply*o (c 13)\n"
		"                                                        chunkx2*apply2 (c 12)\n"
		"                                                        chunk*apply*d (c 11)\n"
		"                                                        chunkx2*apply2 (c 6)\n"
		"                                                        chunk*apply* (c 15)\n"
		"                                                        chunkx2*apply (c 8)\n"
		"                                                        chunk*apply*c (c 5)\n"
		"                                                        chunkx2*apply (c 10)\n"
		"                                                        chunk*apply (c 1)\n"
		"\n"
		"  * Note:  Printed the first 10 chunks. 'explain list' to see other 6 chunks.\n"
		"\n"
		"  Current chunk being discussed:                        chunk*apply*down-\n"
		"  gripper(c 3)\n"
		"\n"
		"  Use 'explain chunk [ <chunk-name> | id ]' to discuss the formation of that\n"
		"  chunk.\n"
		"  Use 'explain ?' to learn more about explain's sub-command and settings.\n"
		"\n"
		"explain chunk\n"
		"\n"
		"This starts the process.\n"
		"Tip: Use c, which is an alias to explain chunk, to quickly start discussing a\n"
		"chunk, for example:\n"
		"\n"
		"  soar % c 3\n"
		"  Now explaining chunk*apply*move-gripper-above*pass*top-state*OpNoChange*t6-1.\n"
		"  - Note that future explain commands are now relative\n"
		"    to the problem-solving that led to that chunk.\n"
		"\n"
		"  Explanation Trace                                     Using variable identity\n"
		"  IDs                  Shortest Path to Result Instantiation\n"
		"\n"
		"  sp {chunk*apply*move-gripper-above*pass*top-state*OpNoChange*t6-1\n"
		"  1:    (<s1> ^top-state <s2>)                          ([140] ^top-state\n"
		"  [162])\n"
		"       -{\n"
		"  2:    (<s1> ^operator <o*1>)                          ([140] ^operator [141])\n"
		"  3:    (<o*1> ^name evaluate-operator)                 ([141] ^name evaluate-\n"
		"  operator)\n"
		"       }\n"
		"  4:    (<s2> ^gripper <g1>)                            ([162] ^gripper [156])\n"
		"  i 30 -> i 31\n"
		"  5:    (<g1> ^position up)                             ([156] ^position up)\n"
		"  i 30 -> i 31\n"
		"  6:    (<g1> ^holding nothing)                         ([156] ^holding\n"
		"  nothing)                     i 30 -> i 31\n"
		"  7:    (<g1> ^above <t1>)                              ([156] ^above [157])\n"
		"  i 30 -> i 31\n"
		"  8:    (<s2> ^io <i2>)                                 ([162] ^io [163])\n"
		"  i 31\n"
		"  9:    (<i2> ^output-link <i1>)                        ([163] ^output-link\n"
		"  [164])                   i 31\n"
		"  10:   (<i1> ^gripper <g2>)                            ([164] ^gripper [165])\n"
		"  i 31\n"
		"  11:   (<s2> ^clear { <> <t1> <b1> })                  ([162] ^clear { <>[161]\n"
		"  [161] })            i 30 -> i 31\n"
		"  12:   (<s1> ^operator <o1>)                           ([140] ^operator [149])\n"
		"  13:   (<o1> ^moving-block <b1>)                       ([149] ^moving-block\n"
		"  [161])\n"
		"  14:   (<o1> ^name pick-up)                            ([149] ^name pick-up)\n"
		"        -->\n"
		"  1:    (<g2> ^command move-gripper-above +)            ([165] ^command move-\n"
		"  gripper-above +)\n"
		"  2:    (<g2> ^destination <c1> +)                      ([165] ^destination\n"
		"  [161] +)\n"
		"  }\n"
		"\n"
		"explain formation\n"
		"\n"
		"explain formation provides an explanation of the initial rule that fired which\n"
		"created a result. This is what is called the 'base instantiation' and is what\n"
		"led to the chunk being learned. Other rules may also be base instantiations if\n"
		"they previously created children of the base instantiation's results. They also\n"
		"will be listed in the initial formation output.\n"
		"\n"
		"  soar % explain formation\n"
		"  -----------------------------------------------------------------------------\n"
		"  -------\n"
		"  The formation of chunk 'chunk*apply*move-gripper-above*pass*top-\n"
		"  state*OpNoChange*t6-1' (c 1)\n"
		"  -----------------------------------------------------------------------------\n"
		"  -------\n"
		"\n"
		"  Initial base instantiation (i 31) that fired when apply*move-gripper-\n"
		"  above*pass*top-state matched at level 3 at time 6:\n"
		"\n"
		"  Explanation trace of instantiation # 31            (match of rule apply*move-\n"
		"  gripper-above*pass*top-state at level 3)\n"
		"   (produced chunk result)\n"
		"                                                     Identities instead of\n"
		"  variables       Operational    Creator\n"
		"\n"
		"  1:    (<s> ^operator <op>)                         ([159] ^operator [160])\n"
		"  No         i 30 (pick-up*propose*move-gripper-above)\n"
		"  2:    (<op> ^name move-gripper-above)              ([160] ^name move-gripper-\n"
		"  above)          No         i 30 (pick-up*propose*move-gripper-above)\n"
		"  3:    (<op> ^destination <des>)                    ([160] ^destination [161])\n"
		"  No         i 30 (pick-up*propose*move-gripper-above)\n"
		"  4:    (<s> ^top-state <t*1>)                       ([159] ^top-state [162])\n"
		"  No         i 27 (elaborate*state*top-state)\n"
		"  5:    (<t*1> ^io <i*1>)                            ([162] ^io [163])\n"
		"  Yes        Higher-level Problem Space\n"
		"  6:    (<i*1> ^output-link <o*1>)                   ([163] ^output-link [164])\n"
		"  Yes        Higher-level Problem Space\n"
		"  7:    (<o*1> ^gripper <gripper>)                   ([164] ^gripper [165])\n"
		"  Yes        Higher-level Problem Space\n"
		"     -->\n"
		"  1:    (<gripper> ^command move-gripper-above +)    ([165] ^command move-\n"
		"  gripper-above +)\n"
		"  2:    (<gripper> ^destination <des> +)             ([165] ^destination [161]\n"
		"  +)\n"
		"  ------\n"
		"\n"
		"This chunk summarizes the problem-solving involved in the following 5 rule\n"
		"firings:\n"
		"\n"
		"     i 27 (elaborate*state*top-state)\n"
		"     i 28 (elaborate*state*operator*name)\n"
		"     i 29 (pick-up*elaborate*desired)\n"
		"     i 30 (pick-up*propose*move-gripper-above)\n"
		"     i 31 (apply*move-gripper-above*pass*top-state)\n"
		"\n"
		"explain instantiation\n"
		"\n"
		"This is probably one of the most common things you will do while using the\n"
		"explainer. You are essentially browsing the instantiation graph one rule at a\n"
		"time.\n"
		"Tip: Use i, which is an alias to explain instantiation, to quickly view an\n"
		"instantiation, for example:\n"
		"\n"
		"  soar % i 30\n"
		"  Explanation trace of instantiation # 30            (match of rule pick-\n"
		"  up*propose*move-gripper-above at level 3)\n"
		"  - Shortest path to a result: i 30 -> i 31\n"
		"                                                     Identities instead of\n"
		"  variables       Operational    Creator\n"
		"\n"
		"  1:    (<s> ^name pick-up)                          ([152] ^name pick-up)\n"
		"  No         i 28 (elaborate*state*operator*name)\n"
		"  2:    (<s> ^desired <d*1>)                         ([152] ^desired [153])\n"
		"  No         i 29 (pick-up*elaborate*desired)\n"
		"  3:    (<d*1> ^moving-block <mblock>)               ([153] ^moving-block\n"
		"  [154])               No         i 29 (pick-up*elaborate*desired)\n"
		"  4:    (<s> ^top-state <ts>)                        ([152] ^top-state [155])\n"
		"  No         i 27 (elaborate*state*top-state)\n"
		"  5:    (<ts> ^clear <mblock>)                       ([155] ^clear [154])\n"
		"  Yes        Higher-level Problem Space\n"
		"  6:    (<ts> ^gripper <g>)                          ([155] ^gripper [156])\n"
		"  Yes        Higher-level Problem Space\n"
		"  7:    (<g> ^position up)                           ([156] ^position up)\n"
		"  Yes        Higher-level Problem Space\n"
		"  8:    (<g> ^holding nothing)                       ([156] ^holding nothing)\n"
		"  Yes        Higher-level Problem Space\n"
		"  9:    (<g> ^above { <> <mblock> <a*1> })           ([156] ^above { <>[154]\n"
		"  [157] })         Yes        Higher-level Problem Space\n"
		"     -->\n"
		"  1:    (<s> ^operator <op1> +)                      ([152] ^operator [158] +)\n"
		"  2:    (<op1> ^name move-gripper-above +)           ([158] ^name move-gripper-\n"
		"  above +)\n"
		"  3:    (<op1> ^destination <mblock> +)              ([158] ^destination [154]\n"
		"  +)\n"
		"\n"
		"explain explanation-trace and wm-trace\n"
		"\n"
		"In most cases, users spend most of their time browsing the explanation trace.\n"
		"This is where chunking learns most of the subtle relationships that you are\n"
		"likely to be debugging. But users will also need to examine the working memory\n"
		"trace to see the specific values matched.\n"
		"To switch between traces, you can use the explain e and the explain w commands.\n"
		"Tip: Use et and 'wt', which are aliases to the above two commands, to quickly\n"
		"switch between traces.\n"
		"\n"
		"  soar % explain w\n"
		"  Working memory trace of instantiation # 30     (match of rule pick-\n"
		"  up*propose*move-gripper-above at level 3)\n"
		"  1:    (S9 ^name pick-up)                               No         i 28\n"
		"  (elaborate*state*operator*name)\n"
		"  2:    (S9 ^desired D6)                                 No         i 29 (pick-\n"
		"  up*elaborate*desired)\n"
		"  3:    (D6 ^moving-block B3)                            No         i 29 (pick-\n"
		"  up*elaborate*desired)\n"
		"  4:    (S9 ^top-state S1)                               No         i 27\n"
		"  (elaborate*state*top-state)\n"
		"  5:    (S1 ^clear B3)                                   Yes        Higher-\n"
		"  level Problem Space\n"
		"  6:    (S1 ^gripper G2)                                 Yes        Higher-\n"
		"  level Problem Space\n"
		"  7:    (G2 ^position up)                                Yes        Higher-\n"
		"  level Problem Space\n"
		"  8:    (G2 ^holding nothing)                            Yes        Higher-\n"
		"  level Problem Space\n"
		"  9:    (G2 ^above { <> B3 T1 })                         Yes        Higher-\n"
		"  level Problem Space\n"
		"     -->\n"
		"  1:    (S9 ^operator O9) +\n"
		"  2:    (O9 ^name move-gripper-above) +\n"
		"  3:    (O9 ^destination B3) +\n"
		"\n"
		"explain constraints\n"
		"\n"
		"This feature explains any constraints on the value of variables in the chunk\n"
		"that were required by the problem-solving that occurred in the substate. If\n"
		"these constraints were not met, the problem-solving would not have occurred.\n"
		"Explanation-based chunking tracks constraints as they apply to identity sets\n"
		"rather than how they apply to specific variables or identifiers. This means\n"
		"that sometimes constraints that appear in a chunk may have been a result of\n"
		"conditions that tested sub-state working memory element. Such conditions don't\n"
		"result in actual conditions in the chunk, but they can provide constraints.\n"
		"explain constraints allows users to see where such constraints came from.\n"
		"This feature is not yet implemented. You can use explain stats to see if any\n"
		"transitive constraints were added to a particular chunk.\n"
		"\n"
		"explain identity\n"
		"\n"
		"explain identity will show the mappings from variable identities to identity\n"
		"sets. If available, the variable in a chunk that an identity set maps to will\n"
		"also be displayed. (Requires a debug build because of efficiency cost.)\n"
		"Variable identities are the ID values that are displayed when explaining an\n"
		"individual chunk or instantiation. An identity set is a set of variable\n"
		"identities that were unified to a particular variable mapping. The null\n"
		"identity set indicates identities that should not be generalized, i.e. they\n"
		"retain their matched literal value even if the explanation trace indicates that\n"
		"the original rule had a variable in that element.\n"
		"By default, only identity sets that appear in the chunk will be displayed in\n"
		"the identity analysis. To see the identity set mappings for other sets, change\n"
		"the only-chunk-identities setting to off.\n"
		"\n"
		"  soar % explain identity\n"
		"  =========================================================================\n"
		"  -             Variablization Identity to Identity Set Mappings          -\n"
		"  =========================================================================\n"
		"\n"
		"  -== NULL Identity Set ==-\n"
		"\n"
		"  The following variable identities map to the null identity set and will\n"
		"  not be generalized: 282 301 138 291 355 336 227 309 328 318 128 218 345\n"
		"\n"
		"  -== How variable identities map to identity sets ==-\n"
		"\n"
		"  Variablization IDs      Identity     CVar    Mapping Type\n"
		"\n"
		"  Instantiation 36:\n"
		"    125 -> 482          | IdSet 12  | <s>       | New identity set\n"
		"    126 -> 493          | IdSet 11  | <o>       | New identity set\n"
		"  Instantiation 38:\n"
		"  Instantiation 41:\n"
		"    146 -> 482          | IdSet 12  | <s>       | New identity set\n"
		"    147 -> 493          | IdSet 11  | <o>       | New identity set\n"
		"  Instantiation 42:\n"
		"    151 -> 180          | IdSet 1   | <ss>      | New identity set\n"
		"    149 -> 482          | IdSet 12  | <s>       | New identity set\n"
		"    150 -> 493          | IdSet 11  | <o>       | New identity set\n"
		"    307 -> 180          | IdSet 1   | <ss>      | Added to identity set\n"
		"    187 -> 180          | IdSet 1   | <ss>      | Added to identity set\n"
		"    334 -> 180          | IdSet 1   | <ss>      | Added to identity set\n"
		"    173 -> 180          | IdSet 1   | <ss>      | Added to identity set\n"
		"    280 -> 180          | IdSet 1   | <ss>      | Added to identity set\n"
		"  Instantiation 53:\n"
		"    219 -> 489          | IdSet 15  | <b>       | New identity set\n"
		"  Instantiation 61:\n"
		"  Instantiation 65:\n"
		"    319 -> 492          | IdSet 20  | <t>       | New identity set\n"
		"\n"
		"explain stats\n"
		"\n"
		"explain stats prints statistics about the chunk being discussed.\n"
		"\n"
		"  ===========================================================\n"
		"  Statistics for 'chunk*apply*move-gripper-above*pass*top-state*OpNoChange*t6-\n"
		"  1' (c 1):\n"
		"  ===========================================================\n"
		"  Number of conditions                                       14\n"
		"  Number of actions                                          2\n"
		"  Base instantiation                                         i 31 (apply*move-\n"
		"  gripper-above*pass*top-state)\n"
		"\n"
		"  ===========================================================\n"
		"                   Generality and Correctness\n"
		"  ===========================================================\n"
		"\n"
		"  Tested negation in local substate                          No\n"
		"  LHS required repair                                        No\n"
		"  RHS required repair                                        No\n"
		"  Was unrepairable chunk                                     No\n"
		"\n"
		"  ===========================================================\n"
		"                        Work Performed\n"
		"  ===========================================================\n"
		"  Instantiations backtraced through                          5\n"
		"  Instantiations skipped                                     6\n"
		"  Constraints collected                                      1\n"
		"  Constraints attached                                       0\n"
		"  Duplicates chunks later created                            0\n"
		"  Conditions merged                                          2\n"
		"\n"
		"After-Action Reports\n"
		"\n"
		"The explainer has an option to create text files that contain statistics about\n"
		"the rules learned by an agent during a particular run. When enabled, the\n"
		"explainer will write out a file with the statistics when either Soar exits or a\n"
		"soar init is executed. This option is still considered experimental and in\n"
		"beta.\n"
		"\n"
		"Visualizing an Explanation\n"
		"\n"
		"Soar's visualize command allows you to create images that represent processing\n"
		"that the explainer recorded. There are two types of explainer-related\n"
		"visualizations.\n"
		"(1) The visualizer can create an image that shows the entire instantiation\n"
		"graph at once and how it contributed to the learned rule. The graph includes\n"
		"arrows that show the dependencies between actions in one rule and conditions in\n"
		"others. This image is one of the most effective ways to understand how a chunk\n"
		"was formed, especially for particularly complex chunks. To use this feature,\n"
		"first choose a chunk for discussion. You can then issue the visualize command\n"
		"with the appropriate settings.\n"
		"(2) The visualizer can also create an image that shows how identities were\n"
		"joined during identity analysis. This can be useful in determining why two\n"
		"elements were assigned the same variable.\n"
		"\n"
		"Default Aliases\n"
		"\n"
		"  c    explain chunk\n"
		"  i    explain instantiation\n"
		"\n"
		"  ef   explain formation\n"
		"  ei   explain identities\n"
		"  es   explain stats\n"
		"\n"
		"  et   explain explanation-trace\n"
		"  wt   explain wm-trace\n"
		"\n"
		"See Also\n"
		"\n"
		"chunk visualize\n"
	;
	docstrings["file-system"] = 
		"File System\n"
		"\n"
		"Soar can handle the following Unix-style file system navigation commands\n"
		"\n"
		"pwd\n"
		"\n"
		"Print the current working directory.\n"
		"\n"
		"ls\n"
		"\n"
		"List the contents of the current working directory.\n"
		"\n"
		"cd\n"
		"\n"
		"Change the current working directory. If run with no arguments, returns to the\n"
		"directory that the command line interface was started in, often referred to as\n"
		"the home directory.\n"
		"\n"
		"dirs\n"
		"\n"
		"This command lists the directory stack. Agents can move through a directory\n"
		"structure by pushing and popping directory names. The dirs command returns the\n"
		"stack.\n"
		"\n"
		"pushd\n"
		"\n"
		"Push the directory on to the stack. Can be relative path name or a fully\n"
		"specified one.\n"
		"\n"
		"popd\n"
		"\n"
		"Pop the current working directory off the stack and change to the next\n"
		"directory on the stack. Can be relative pathname or a fully specified path.\n"
		"\n"
		"Default Aliases\n"
		"\n"
		"  chdir        cd\n"
		"  dir          ls\n"
		"  topd         pwd\n"
	;
	docstrings["gp"] = 
		"Generate productions according to a specified pattern.\n"
		"\n"
		"Synopsis\n"
		"\n"
		"  gp { production_body }\n"
		"\n"
		"Description\n"
		"\n"
		"The gp command defines a pattern used to generate and source a set of Soar\n"
		"productions. production_body is a single argument that looks almost identical\n"
		"to a standard Soar rule that would be used with the sp command. Indeed, any\n"
		"syntax that is allowed in sp is also allowed in gp.\n"
		"Patterns in gp are specified with sets of whitespace-seprated values in square\n"
		"brackets. Every combination of values across all square-bracketed value lists\n"
		"will be generated. Values with whitespaces can be used if wrapped in pipes.\n"
		"Characters can also be escaped with a backslash (so string literals with\n"
		"embedded pipes and spaces outside of string literals are both possible).\n"
		"gp is primarily intended as an alternative to :template rules for reinforcement\n"
		"learning. :template rules generate new rules as patterns occur at run time.\n"
		"Unfortunately, this incurs a high run time cost. If all possible values are\n"
		"known in advance, then the rules can be generated using gp at source time, thus\n"
		"allowing code to run faster. gp is not appropriate when all possible values are\n"
		"not known or if the total number of possible rules is very large (and the\n"
		"system is likely to encounter only a small subset at run time). It is also\n"
		"possible to combine gp and :template (e.g., if some of the values are known and\n"
		"not others). This should reduce the run time cost of :template.\n"
		"There is nothing that actually restricts gp to being used for RL, although for\n"
		"non-RL rules, a disjunction list (using << and >>) is better where it can be\n"
		"used. More esoteric uses may include multiple bracketed value lists inside a\n"
		"disjunction list, or even variables in bracketed value lists.\n"
		"Each rule generated by gp has *integer appended to its name (where integer is\n"
		"some incrementing number).\n"
		"\n"
		"Examples\n"
		"\n"
		"Template version of rule:\n"
		"\n"
		"  sp {water-jug*fill\n"
		"     :template\n"
		"     (state <s1> ^name water-jug ^operator <op> +\n"
		"                 ^jug <j1> <j2>)\n"
		"     (<op> ^name fill ^fill-jug.volume <fvol>)\n"
		"     (<j1> ^volume 3 ^contents <c1>)\n"
		"     (<j2> ^volume 5 ^contents <c2>)\n"
		"  -->\n"
		"     (<s1> ^operator <op> = 0)\n"
		"  }\n"
		"\n"
		"gp version of rule (generates 144 rules):\n"
		"\n"
		"  gp {water-jug*fill\n"
		"     (state <s1> ^name water-jug ^operator <op> +\n"
		"                 ^jug <j1> <j2>)\n"
		"     (<op> ^name fill ^fill-jug.volume [3 5])\n"
		"     (<j1> ^volume 3 ^contents [0 1 2 3])\n"
		"     (<j2> ^volume 5 ^contents [0 1 2 3 4 5])\n"
		"  -->\n"
		"     (<s1> ^operator <op> = 0)\n"
		"  }\n"
		"\n"
		"Esoteric example (generates 24 rules):\n"
		"\n"
		"  gp {strange-example\n"
		"     (state <s1> ^<< [att1 att2] [att3 att4] >> [ val |another val| |strange\n"
		"  val\\|| ])\n"
		"  -->\n"
		"     (<s1> ^foo [bar <bar>])\n"
		"  }\n"
		"\n"
		"testgp.soar contains many more examples.\n"
		"\n"
		"See Also\n"
		"\n"
		"sp\n"
	;
	docstrings["help"] = 
		"Provide formatted usage information about Soar commands.\n"
		"\n"
		"Synopsis\n"
		"\n"
		"  help [command_name]\n"
		"\n"
		"Default Aliases\n"
		"\n"
		"* ?\n"
		"* man\n"
		"\n"
		"Description\n"
		"\n"
		"This command prints formatted help for the given command name. Issue alone to\n"
		"see what topics have help available.\n"
	;
	docstrings["load"] = 
		"Loads soar files, rete networks, saved percept streams and external libraries.\n"
		"\n"
		"Synopsis\n"
		"\n"
		"  ============================================================\n"
		"  -               Load Sub-Commands and Options              -\n"
		"  ============================================================\n"
		"  load                            [? | help]\n"
		"  ------------------------------------------------------------\n"
		"  load file                       [--all --disable] <filename>\n"
		"  load file                       [--verbose]     ]\n"
		"  ------------------------------------------------------------\n"
		"  load library                    <filename> <args...>\n"
		"  ------------------------------------------------------------\n"
		"  load rete-network               --load <filename>\n"
		"  ------------------------------------------------------------\n"
		"  load percepts                   --open <filename>\n"
		"  load percepts                   --close\n"
		"  ------------------------------------------------------------\n"
		"\n"
		"load file\n"
		"\n"
		"Load and evaluate the contents of a file. The filename can be a relative path\n"
		"or a fully qualified path. The source will generate an implicit push to the new\n"
		"directory, execute the command, and then pop back to the current working\n"
		"directory from which the command was issued. This is traditionally known as the\n"
		"source command.\n"
		"\n"
		"Options:\n"
		"\n"
		"Option        Description\n"
		"filename      The file of Soar productions and commands to load.\n"
		"-a, --all     Enable a summary for each file sourced\n"
		"-d, --disable Disable all summaries\n"
		"-v, --verbose Print excised production names\n"
		"\n"
		"Summaries\n"
		"\n"
		"After the source completes, the number of productions sourced and excised is\n"
		"summarized:\n"
		"\n"
		"  agent> source demos/mac/mac.soar\n"
		"  ******************\n"
		"  Total: 18 productions sourced.\n"
		"  Source finished.\n"
		"  agent> source demos/mac/mac.soar\n"
		"  #*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*\n"
		"  Total: 18 productions sourced. 18 productions excised.\n"
		"  Source finished.\n"
		"\n"
		"This can be disabled by using the -d flag.\n"
		"\n"
		"Multiple Summaries\n"
		"\n"
		"A separate summary for each file sourced can be enabled using the -a flag:\n"
		"\n"
		"  agent> source demos/mac/mac.soar -a\n"
		"  _firstload.soar: 0 productions sourced.\n"
		"  all_source.soar: 0 productions sourced.\n"
		"  **\n"
		"  goal-test.soar: 2 productions sourced.\n"
		"  ***\n"
		"  monitor.soar: 3 productions sourced.\n"
		"  ****\n"
		"  search-control.soar: 4 productions sourced.\n"
		"  top-state.soar: 0 productions sourced.\n"
		"  elaborations_source.soar: 0 productions sourced.\n"
		"  _readme.soar: 0 productions sourced.\n"
		"  **\n"
		"  initialize-mac.soar: 2 productions sourced.\n"
		"  *******\n"
		"  move-boat.soar: 7 productions sourced.\n"
		"  mac_source.soar: 0 productions sourced.\n"
		"  mac.soar: 0 productions sourced.\n"
		"  Total: 18 productions sourced.\n"
		"  Source finished.\n"
		"\n"
		"Listing Excised Productions\n"
		"\n"
		"  agent> source demos/mac/mac.soar -d\n"
		"  ******************\n"
		"  Source finished.\n"
		"  agent> source demos/mac/mac.soar -d\n"
		"  #*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*\n"
		"  Source finished.\n"
		"\n"
		"A list of excised productions is available using the -v flag:\n"
		"\n"
		"  agent> source demos/mac/mac.soar -v\n"
		"  #*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*\n"
		"  Total: 18 productions sourced. 18 productions excised.\n"
		"  Excised productions:\n"
		"          mac*detect*state*success\n"
		"          mac*evaluate*state*failure*more*cannibals\n"
		"          monitor*move-boat\n"
		"          monitor*state*left\n"
		"  ...\n"
		"\n"
		"Combining the -a and -v flags add excised production names to the output for\n"
		"each file.\n"
		"\n"
		"load rete-network\n"
		"\n"
		"The load rete-network command loads a Rete net previously saved. The Rete net\n"
		"is Soar's internal representation of production memory; the conditions of\n"
		"productions are reordered and common substructures are shared across different\n"
		"productions. This command provides a fast method of saving and loading\n"
		"productions since a special format is used and no parsing is necessary. Rete-\n"
		"net files are portable across platforms that support Soar.\n"
		"If the filename contains a suffix of .Z, then the file is compressed\n"
		"automatically when it is saved and uncompressed when it is loaded. Compressed\n"
		"files may not be portable to another platform if that platform does not support\n"
		"the same uncompress utility.\n"
		"\n"
		"Usage:\n"
		"\n"
		"  load rete-network -l <filename>\n"
		"\n"
		"load percepts\n"
		"\n"
		"Replays input stored using the capture-input command. The replay file also\n"
		"includes a random number generator seed and seeds the generator with that.\n"
		"\n"
		"Synopsis\n"
		"\n"
		"  load percepts --open filename\n"
		"  load percepts --close\n"
		"\n"
		"Options\n"
		"\n"
		"Option      Description\n"
		"filename    Open filename and load input and random seed.\n"
		"-o, --open  Reads captured input from file in to memory and seeds the random\n"
		"            number generator.\n"
		"-c, --close Stop replaying input.\n"
		"\n"
		"load library\n"
		"\n"
		"Load a shared library into the local client (for the purpose of, e.g.,\n"
		"providing custom event handling).\n"
		"\n"
		"Options:\n"
		"\n"
		"Option       Description\n"
		"library_name The root name of the library (without the .dll or .so extension;\n"
		"             this is added for you depending on your platform).\n"
		"arguments    Whatever arguments the library's initialization function is\n"
		"             expecting, if any.\n"
		"\n"
		"Technical Details\n"
		"\n"
		"Sometimes, a user will want to extend an existing environment. For example, the\n"
		"person may want to provide custom RHS functions, or register for print events\n"
		"for the purpose of logging trace information. If modifying the existing\n"
		"environment is cumbersome or impossible, then the user has two options: create\n"
		"a remote client that provides the functionality, or use load library. load\n"
		"library creates extensions in the local client, making it orders of magnitude\n"
		"faster than a remote client.\n"
		"To create a loadable library, the library must contain the following function:\n"
		"\n"
		"  #ifdef __cplusplus\n"
		"  extern \"C\" {\n"
		"  #endif\n"
		"\n"
		"      EXPORT char* sml_InitLibrary(Kernel* pKernel, int argc, char** argv) {\n"
		"          // Your code here\n"
		"      }\n"
		"\n"
		"  #ifdef __cplusplus\n"
		"  } // extern \"C\"\n"
		"  #endif\n"
		"\n"
		"This function is called when load library loads your library. It is responsible\n"
		"for any initialization that you want to take place (e.g. registering custom RHS\n"
		"functions, registering for events, etc).\n"
		"The argc and argv arguments are intended to mirror the arguments that a\n"
		"standard SML client would get. Thus, the first argument is the name of the\n"
		"library, and the rest are whatever other arguments are provided. This is to\n"
		"make it easy to use the same codebase to create a loadable library or a\n"
		"standard remote SML client (e.g. when run as a standard client, just pass the\n"
		"arguments main gets into sml_InitLibrary).\n"
		"The return value of sml_InitLibrary is for any error messages you want to\n"
		"return to the load-library call. If no error occurs, return a zero-length\n"
		"string.\n"
		"An example library is provided in the Tools/TestExternalLibraryLib project.\n"
		"This example can also be compiled as a standard remote SML client. The Tools/\n"
		"TestExternalLibraryExe project tests loading the TestExternalLibraryLib\n"
		"library.\n"
		"\n"
		"Load Library Examples\n"
		"\n"
		"To load TestExternalLibraryLib:\n"
		"\n"
		"  load library TestExternalLibraryLib\n"
		"\n"
		"To load a library that takes arguments (say, a logger):\n"
		"\n"
		"  load library my-logger -filename mylog.log\n"
		"\n"
		"Default aliases\n"
		"\n"
		"  source               load file\n"
		"  rete-net, rn         load rete-network\n"
		"  replay-input         load input\n"
		"  load-libarary        load library\n"
		"\n"
		"See Also\n"
		"\n"
		"file_system decide production save\n"
	;
	docstrings["output"] = 
		"Controls settings related to Soar's output\n"
		"\n"
		"Synopsis\n"
		"\n"
		"  =======================================================\n"
		"  -           Output Sub-Commands and Options           -\n"
		"  =======================================================\n"
		"  output                                       [? | help]\n"
		"  -------------------------------------------------------\n"
		"  enabled                                              on   Globally toggle all output\n"
		"  console                                             off   Send output to std::out for debugging\n"
		"  callbacks                                            on   Send output to standard print callback\n"
		"  -------------------------------------------------------\n"
		"  agent-logs                  <channel-number> [on | off]   Whether agent trace channel prints\n"
		"  agent-writes                                         on   Allow RHS-funtion output\n"
		"  -------------------------------------------------------\n"
		"  output log                   [--append | -A] <filename>   Log all output to file\n"
		"  output log                               --add <string>\n"
		"  output log                                    [--close]\n"
		"  -------------------------------------------------------\n"
		"  output command-to-file         [-a] <file> <cmd> [args]   Log output from\n"
		"  single command\n"
		"  -------------------------------------------------------\n"
		"  echo-commands                                       off   Echo commands to debugger\n"
		"  print-depth                                           1   Default print depth\n"
		"  warnings                                             on   Print all warnings\n"
		"  -------------------------------------------------------\n"
		"  To view/change a setting:                                 output <setting> [<value>]\n"
		"\n"
		"  For a detailed explanation of these settings:             help output\n"
		"\n"
		"Summary Screen\n"
		"\n"
		"Using the output command without any arguments will display some key output\n"
		"settings:\n"
		"\n"
		"  =======================================================\n"
		"  -                   Output Status                     -\n"
		"  =======================================================\n"
		"  Printing enabled                                    Yes\n"
		"  Printing to std::out                                Yes\n"
		"  -------------------------------------------------------\n"
		"  Agent RHS write output                               on\n"
		"  All agent log channels enabled.\n"
		"  -------------------------------------------------------\n"
		"  Warnings                                             on\n"
		"  -------------------------------------------------------\n"
		"  Soar release compilation                            OFF\n"
		"  Debug printing                                       ON\n"
		"  -------------------------------------------------------\n"
		"\n"
		"output command-to-file\n"
		"\n"
		"This command logs a single command. It is almost equivalent to opening a log\n"
		"using clog, running the command, then closing the log, the only difference is\n"
		"that input isn't recorded.\n"
		"Running this command while a log is open is an error. There is currently not\n"
		"support for multiple logs in the command line interface, and this would be an\n"
		"instance of multiple logs.\n"
		"This command echoes output both to the screen and to a file, just like clog.\n"
		"\n"
		"Options:\n"
		"\n"
		"Option       Description\n"
		"-a, --append Append if file exists.\n"
		"filename     The file to log the results of the command to\n"
		"command      The command to log\n"
		"args         Arguments for command\n"
		"\n"
		"output log\n"
		"\n"
		"The output log command allows users to save all user-interface input and output\n"
		"to a file. When Soar is logging to a file, everything typed by the user and\n"
		"everything printed by Soar is written to the file (in addition to the screen).\n"
		"Invoke output log with no arguments to query the current logging status. Pass a\n"
		"filename to start logging to that file (relative to the command line\n"
		"interface's home directory). Use the close option to stop logging.\n"
		"\n"
		"Usage\n"
		"\n"
		"  output log [-A] filename\n"
		"  output log --add string\n"
		"  output log --close\n"
		"\n"
		"Options:\n"
		"\n"
		"Option           Description\n"
		"filename         Open filename and begin logging.\n"
		"-c, --close      Stop logging, close the file.\n"
		"-a, --add string Add the given string to the open log file.\n"
		"-A, --append     Opens existing log file named filename and logging is added at\n"
		"                 the end of the file.\n"
		"\n"
		"Examples\n"
		"\n"
		"To initiate logging and place the record in foo.log:\n"
		"\n"
		"  output log foo.log\n"
		"\n"
		"To append log data to an existing foo.log file:\n"
		"\n"
		"  output log -A foo.log\n"
		"\n"
		"To terminate logging and close the open log file:\n"
		"\n"
		"  output log -c\n"
		"\n"
		"Known Issues with log\n"
		"\n"
		"Does not log everything when structured output is selected.\n"
		"\n"
		"General Output Settings\n"
		"\n"
		"Invoke a sub-command with no arguments to query the current setting. Partial\n"
		"commands are accepted.\n"
		"\n"
		"Option        Valid Values Default\n"
		"echo-commands yes or no    off\n"
		"print-depth   >= 1         1\n"
		"verbose       yes or no    no\n"
		"warnings      yes or no    yes\n"
		"\n"
		"output echo-commands\n"
		"\n"
		"output echo-commands will echo typed commands to other connected debuggers.\n"
		"Otherwise, the output is displayed without the initiating command, and this can\n"
		"be confusing.\n"
		"\n"
		"output print-depth\n"
		"\n"
		"The print-depth command reflects the default depth used when working memory\n"
		"elements are printed (using the print). The default value is 1. This default\n"
		"depth can be overridden on any particular call to the print command by\n"
		"explicitly using the --depth flag, e.g. print --depth 10 args.\n"
		"By default, the print command prints objects in working memory, not just the\n"
		"individual working memory element. To limit the output to individual working\n"
		"memory elements, the --internal flag must also be specified in the print\n"
		"command. Thus when the print depth is 0, by default Soar prints the entire\n"
		"object, which is the same behavior as when the print depth is 1. But if --\n"
		"internal is also specified, then a depth of 0 prints just the individual WME,\n"
		"while a depth of 1 prints all WMEs which share that same identifier. This is\n"
		"true when printing timetags, identifiers or WME patterns.\n"
		"When the depth is greater than 1, the identifier links from the specified WME's\n"
		"will be followed, so that additional substructure is printed. For example, a\n"
		"depth of 2 means that the object specified by the identifier, wme-pattern, or\n"
		"timetag will be printed, along with all other objects whose identifiers appear\n"
		"as values of the first object. This may result in multiple copies of the same\n"
		"object being printed out. If --internal is also specified, then individuals\n"
		"WMEs and their timetags will be printed instead of the full objects.\n"
		"\n"
		"output verbose\n"
		"\n"
		"The verbose command enables tracing of a number of low-level Soar execution\n"
		"details during a run. The details printed by verbose are usually only valuable\n"
		"to developers debugging Soar implementation details.\n"
		"\n"
		"output warnings\n"
		"\n"
		"The warnings command enables and disables the printing of warning messages. At\n"
		"startup, warnings are initially enabled. If warnings are disabled using this\n"
		"command, then some warnings may still be printed, since some are considered too\n"
		"important to ignore.\n"
		"The warnings that are printed apply to the syntax of the productions, to notify\n"
		"the user when they are not in the correct syntax. When a lefthand side error is\n"
		"discovered (such as conditions that are not linked to a common state or impasse\n"
		"object), the production is generally loaded into production memory anyway,\n"
		"although this production may never match or may seriously slow down the\n"
		"matching process. In this case, a warning would be printed only if warnings\n"
		"were on. Righthand side errors, such as preferences that are not linked to the\n"
		"state, usually result in the production not being loaded, and a warning\n"
		"regardless of the warnings setting.\n"
		"\n"
		"Default Aliases\n"
		"\n"
		"  ctf                        output command-to-file\n"
		"  clog                       output log\n"
		"  default-wme-depth          output print-depth\n"
		"  echo-commands              output echo-commands\n"
		"  verbose                    output verbose\n"
		"  warnings                   output warnings\n"
	;
	docstrings["preferences"] = 
		"Examine details about the preferences that support the specified identifier and\n"
		"attribute.\n"
		"\n"
		"Synopsis\n"
		"\n"
		"  preferences [options] [identifier [attribute]]\n"
		"\n"
		"Options\n"
		"\n"
		"Option             Description\n"
		"-0, -n, --none     Print just the preferences themselves\n"
		"-1, -N, --names    Print the preferences and the names of the productions that\n"
		"                   generated them\n"
		"                   Print the information for the --names option above plus the\n"
		"-2, -t, --timetags timetags of the wmes matched by the LHS of the indicated\n"
		"                   productions\n"
		"-3, -w, --wmes     Print the information for the --timetags option above plus\n"
		"                   the entire WME matched on the LHS.\n"
		"-o, --object       Print the support for all the WMEs that comprise the object\n"
		"                   (the specified identifier).\n"
		"identifier         Must be an existing Soar object identifier.\n"
		"attribute          Must be an existing attribute of the specified identifier.\n"
		"\n"
		"Description\n"
		"\n"
		"The preferences command prints all the preferences for the given object\n"
		"identifier and attribute. If identifier and attribute are not specified, they\n"
		"default to the current state and the current operator. The Soar syntax\n"
		"attribute carat (^) is optional when specifying the attribute. The optional\n"
		"arguments indicates the level of detail to print about each preference.\n"
		"This command is useful for examining which candidate operators have been\n"
		"proposed and what relationships, if any, exist among them. If a preference has\n"
		"o-support, the string, :O will also be printed.\n"
		"When only the identifier is specified on the command line, if the identifier is\n"
		"a state, Soar uses the default attribute ^operator. If the identifier is not a\n"
		"state, Soar prints the support information for all WMEs whose value is the\n"
		"identifier.\n"
		"When an identifier and the --object flag are specified, Soar prints the\n"
		"preferences / WME support for all WMEs comprising the specified identifier.\n"
		"For the time being, numeric-indifferent preferences are listed under the\n"
		"heading binary indifferents:.\n"
		"By default, using the --wmes option with a WME on the top state will only print\n"
		"the timetags. To change this, the kernel can be recompiled with\n"
		"DO_TOP_LEVEL_REF_CTS, but this has other consequences (see comments in\n"
		"kernel.h).\n"
		"\n"
		"Examples\n"
		"\n"
		"This example prints the preferences on (S1 ^operator) and the production names\n"
		"which created the preferences:\n"
		"\n"
		"  soar> preferences S1 operator --names\n"
		"  Preferences for S1 ^operator:\n"
		"\n"
		"  acceptables:\n"
		"    O2 (fill) + :I\n"
		"      From water-jug*propose*fill\n"
		"\n"
		"    O3 (fill) + :I\n"
		"      From water-jug*propose*fill\n"
		"\n"
		"  unary indifferents:\n"
		"    O2 (fill) = :I\n"
		"      From water-jug*propose*fill\n"
		"\n"
		"    O3 (fill) = :I\n"
		"      From water-jug*propose*fill\n"
		"\n"
		"  selection probabilities:\n"
		"    O3 (fill) + =0. :I (50.0%)\n"
		"      From water-jug*propose*fill\n"
		"\n"
		"    O2 (fill) + =0. :I (50.0%)\n"
		"      From water-jug*propose*fill\n"
		"\n"
		"If the current state is S1, then the above syntax is equivalent to:\n"
		"\n"
		"  preferences -n\n"
		"\n"
		"This example shows the support for the WMEs with the ^jug attribute:\n"
		"\n"
		"  soar> preferences s1 jug\n"
		"\n"
		"  Preferences for S1 ^jug:\n"
		"\n"
		"  acceptables:\n"
		"    (S1 ^jug I4)  :O\n"
		"    (S1 ^jug J1)  :O\n"
		"\n"
		"This example shows the support for the WMEs with value J1, and the productions\n"
		"that generated them:\n"
		"\n"
		"  soar> pref J1 -1\n"
		"\n"
		"  Support for (33: O3 ^fill-jug J1)\n"
		"    (O3 ^fill-jug J1)  =0. :I (100.0%)\n"
		"      From water-jug*propose*fill\n"
		"\n"
		"  Support for (22: S1 ^jug J1)\n"
		"    (S1 ^jug J1)  =0. :O (100.0%)\n"
		"      From water-jug*apply*initialize-water-jug\n"
		"\n"
		"This example shows the support for all WMEs that make up the object S1:\n"
		"\n"
		"  soar> pref -o s1\n"
		"\n"
		"  Support for S1 ^name:\n"
		"    (S1 ^name water-jug)  :O\n"
		"  Support for S1 ^jug:\n"
		"    (S1 ^jug I4)  :O\n"
		"    (S1 ^jug J1)  :O\n"
		"  Support for S1 ^svs:\n"
		"  Preferences for S1 ^operator:\n"
		"  acceptables:\n"
		"    O2 (fill) + :I\n"
		"    O3 (fill) + :I\n"
		"\n"
		"  unary indifferents:\n"
		"    O2 (fill) = :I\n"
		"    O3 (fill) = :I\n"
		"  Support for S1 ^smem:\n"
		"  Support for S1 ^epmem:\n"
		"  Support for S1 ^reward-link:\n"
		"  Arch-created wmes for S1 :\n"
		"  (2: S1 ^superstate nil)\n"
		"  (1: S1 ^type state)\n"
		"  Input (IO) wmes for S1 :\n"
		"  (15: S1 ^io I1)\n"
		"\n"
		"Default Aliases\n"
		"\n"
		"* pref\n"
		"\n"
		"See Also\n"
		"\n"
		"decide\n"
	;
	docstrings["print"] = 
		"Print items in working memory or production memory.\n"
		"\n"
		"Synopsis\n"
		"\n"
		"  print [options] [production_name]\n"
		"  print [options] identifier|timetag|pattern\n"
		"  print [--gds --stack]\n"
		"\n"
		"Options\n"
		"\n"
		"Production printing options:\n"
		"\n"
		"Option               Description\n"
		"-a, --all            print the names of all productions currently loaded\n"
		"-c, --chunks         print the names of all chunks currently loaded\n"
		"-D, --defaults       print the names of all default productions currently\n"
		"                     loaded\n"
		"-j, --justifications print the names of all justifications currently loaded.\n"
		"-r, --rl             Print Soar-RL rules\n"
		"-T, --template       Print Soar-RL templates\n"
		"-u, --user           print the names of all user productions currently loaded\n"
		"production_name      print the production named production-name\n"
		"\n"
		"Production print formatting:\n"
		"\n"
		"Option         Description\n"
		"-f, --full     When printing productions, print the whole production. This is\n"
		"               the default when printing a named production.\n"
		"-F, --filename also prints the name of the file that contains the production.\n"
		"               items should be printed in their internal form. For productions,\n"
		"-i, --internal this means leaving conditions in their reordered (rete net)\n"
		"               form.\n"
		"               When printing productions, print only the name and not the whole\n"
		"-n, --name     production. This is the default when printing any category of\n"
		"               productions, as opposed to a named production.\n"
		"\n"
		"Working memory printing options:\n"
		"\n"
		"Option         Description\n"
		"-d, --depth n  This option overrides the default printing depth (see the\n"
		"               default-wme-depth command for more detail).\n"
		"-e, --exact    Print only the wmes that match the pattern\n"
		"               items should be printed in their internal form. For working\n"
		"-i, --internal memory, this means printing the individual elements with their\n"
		"               timetags and activation, rather than the objects.\n"
		"-t, --tree     wmes should be printed in in a tree form (one wme per line).\n"
		"-v, --varprint Print identifiers enclosed in angle brackets.\n"
		"identifier     print the object identifier. identifier must be a valid Soar\n"
		"               symbol such as S1\n"
		"               print the object whose working memory elements matching the\n"
		"pattern        given pattern. See Description for more information on printing\n"
		"               objects matching a specific pattern.\n"
		"timetag        print the object in working memory with the given timetag\n"
		"\n"
		"Subgoal stack printing options:\n"
		"\n"
		"Option          Description\n"
		"-s, --stack     Specifies that the Soar goal stack should be printed. By\n"
		"                default this includes both states and operators.\n"
		"-o, --operators When printing the stack, print only operators.\n"
		"-S, --states    When printing the stack, print only states.\n"
		"\n"
		"Printing the Goal Dependency Set:\n"
		"\n"
		"print --gds\n"
		"The Goal Dependency Set (GDS) is described in a subsection of the The Soar\n"
		"Architecture chapter of the manual. This command is a debugging command for\n"
		"examining the GDS for each goal in the stack. First it steps through all the\n"
		"working memory elements in the rete, looking for any that are included in any\n"
		"goal dependency set, and prints each one. Then it also lists each goal in the\n"
		"stack and prints the wmes in the goal dependency set for that particular goal.\n"
		"This command is useful when trying to determine why subgoals are disappearing\n"
		"unexpectedly: often something has changed in the goal dependency set, causing a\n"
		"subgoal to be regenerated prior to producing a result.\n"
		"print --gds is horribly inefficient and should not generally be used except\n"
		"when something is going wrong and you need to examine the Goal Dependency Set.\n"
		"\n"
		"Description\n"
		"\n"
		"The print command is used to print items from production memory or working\n"
		"memory. It can take several kinds of arguments. When printing items from\n"
		"working memory, the Soar objects are printed unless the --internal flag is\n"
		"used, in which case the wmes themselves are printed.\n"
		"\n"
		"  (identifier ^attribute value [activation] [+])\n"
		"\n"
		"The activation value is only printed if activation is turned on. See wma.\n"
		"The pattern is surrounded by parentheses. The identifier, attribute, and value\n"
		"must be valid Soar symbols or the wildcard symbol * which matches all\n"
		"occurrences. The optional + symbol restricts pattern matches to acceptable\n"
		"preferences. If wildcards are included, an object will be printed for each\n"
		"pattern match, even if this results in the same object being printed multiple\n"
		"times.\n"
		"\n"
		"Examples\n"
		"\n"
		"Print the objects in working memory (and their timetags) which have wmes with\n"
		"identifier s1 and value v2 (note: this will print the entire s1 object for each\n"
		"match found):\n"
		"\n"
		"  print --internal (s1 ^* v2)\n"
		"\n"
		"Print the Soar stack which includes states and operators:\n"
		"\n"
		"  print --stack\n"
		"\n"
		"Print the named production in its RETE form:\n"
		"\n"
		"  print -if named*production\n"
		"\n"
		"Print the names of all user productions currently loaded:\n"
		"\n"
		"  print -u\n"
		"\n"
		"Default print vs tree print:\n"
		"\n"
		"  print s1 --depth 2\n"
		"  (S1 ^io I1 ^reward-link R1 ^superstate nil ^type state)\n"
		"    (I1 ^input-link I2 ^output-link I3)\n"
		"\n"
		"  print s1 --depth 2 --tree\n"
		"  (S1 ^io I1)\n"
		"    (I1 ^input-link I2)\n"
		"    (I1 ^output-link I3)\n"
		"  (S1 ^reward-link R1)\n"
		"  (S1 ^superstate nil)\n"
		"  (S1 ^type state)\n"
		"\n"
		"Default Aliases\n"
		"\n"
		"p print pc print --chunks ps print --stack wmes print --depth 0 --internal\n"
		"varprint print --varprint --depth 100 gds_print print --gds\n"
		"\n"
		"See Also\n"
		"\n"
		"output trace wm\n"
	;
	docstrings["production"] = 
		"Commands to manipulate Soar rules and analyze their usage.\n"
		"\n"
		"Synopsis\n"
		"\n"
		"  ==================================================================\n"
		"  -               Production Sub-Commands and Options              -\n"
		"  ==================================================================\n"
		"  production                    [? | help]\n"
		"  ------------------------------------------------------------------\n"
		"  production break              [--clear --print]\n"
		"  production break              --set <prod-name>\n"
		"  ------------------------------------------------------------------\n"
		"  production excise             <production-name>\n"
		"  production excise             [--all --chunks --default ]\n"
		"                                [--never-fired --rl       ]\n"
		"                                [--task --templates --user]\n"
		"  ------------------------------------------------------------------\n"
		"  production find               [--lhs --rhs         ] <pattern>\n"
		"                                [--show-bindings     ]\n"
		"                                [--chunks --nochunks ]\n"
		"  ------------------------------------------------------------------\n"
		"  production firing-counts      [--all --chunks --default --rl]  [n]\n"
		"                                [--task --templates --user --fired]\n"
		"  production firing-counts      <prod-name>\n"
		"  ------------------------------------------------------------------\n"
		"  production matches            [--names --count  ]  <prod-name>\n"
		"                                [--timetags --wmes]\n"
		"  production matches            [--names --count  ] [--assertions ]\n"
		"                                [--timetags --wmes] [--retractions]\n"
		"  ------------------------------------------------------------------\n"
		"  production memory-usage       [options] [max]\n"
		"  production memory-usage       <production_name>\n"
		"  ------------------------------------------------------------------\n"
		"  production optimize-attribute [symbol [n]]\n"
		"  ------------------------------------------------------------------\n"
		"  production watch              [--disable --enable] <prod-name>\n"
		"  ------------------------------------------------------------------\n"
		"\n"
		"  For a detailed explanation of sub-commands:    help production\n"
		"\n"
		"Summary Screen\n"
		"\n"
		"Using the production command without any arguments will display a summary of\n"
		"how many rules are loaded into memory:\n"
		"\n"
		"  =======================================================\n"
		"  -                     Productions                     -\n"
		"  =======================================================\n"
		"  User rules                                            0\n"
		"  Default rules                                         0\n"
		"  Chunks                                                0\n"
		"  Justifications                                        0\n"
		"  -------------------------------------------------------\n"
		"  Total                                                 0\n"
		"  -------------------------------------------------------\n"
		"  Use 'production ?' to learn more about the command\n"
		"\n"
		"production break\n"
		"\n"
		"Toggles the :interrupt flag on a rule at run-time, which stops the Soar\n"
		"decision cycle when the rule fires. The break command can be used to toggle the\n"
		":interrupt flag on production rules which did not have it set in the original\n"
		"source file, which stops the Soar decision cycle when the rule fires. This is\n"
		"intended to be used for debugging purposes.\n"
		"\n"
		"Synopsis\n"
		"\n"
		"  production break -c|--clear <production-name>\n"
		"  production break -p|--print\n"
		"  production break -s|--set <production-name>\n"
		"  production break <production-name>\n"
		"\n"
		"Options:\n"
		"\n"
		"Parameter   Argument          Description\n"
		"-c, --clear <production-name> Clear :interrupt flag from a production.\n"
		"-p, --print (none)            Print which production rules have had their :\n"
		"                              interrupt flags set.\n"
		"(none)      (none)            Print which production rules have had their :\n"
		"                              interrupt flags set.\n"
		"-s, --set   <production-name> Set :interrupt flag on a production rule.\n"
		"(none)      <production-name> Set flag :interrupt on a production rule.\n"
		"\n"
		"production excise\n"
		"\n"
		"This command removes productions from Soar's memory. The command must be called\n"
		"with either a specific production name or with a flag that indicates a\n"
		"particular group of productions to be removed.\n"
		"Note: As of Soar 9.6, using the flag -a or --all no longer causes a soar init.\n"
		"\n"
		"Synopsis\n"
		"\n"
		"  production excise production_name\n"
		"  production excise options\n"
		"\n"
		"Options:\n"
		"\n"
		"Option            Description\n"
		"-a, --all         Remove all productions from memory and perform an init-soar\n"
		"                  command\n"
		"-c, --chunks      Remove all chunks (learned productions) and justifications\n"
		"                  from memory\n"
		"-d, --default     Remove all default productions (:default) from memory\n"
		"-n, --never-fired Excise rules that have a firing count of 0\n"
		"-r, --rl          Excise Soar-RL rules\n"
		"-t, --task        Remove chunks, justifications, and user productions from\n"
		"                  memory\n"
		"-T, --templates   Excise Soar-RL templates\n"
		"-u, --user        Remove all user productions (but not chunks or default rules)\n"
		"                  from memory\n"
		"production_name   Remove the specific production with this name.\n"
		"\n"
		"Examples:\n"
		"\n"
		"This command removes the production my*first*production and all chunks:\n"
		"\n"
		"  production excise my*first*production --chunks\n"
		"\n"
		"This removes all productions:\n"
		"\n"
		"  production excise --all\n"
		"\n"
		"production find\n"
		"\n"
		"Find productions by condition or action patterns.\n"
		"\n"
		"Synopsis\n"
		"\n"
		"  production find [-lrs[n|c]] pattern\n"
		"\n"
		"Options:\n"
		"\n"
		"Option              Description\n"
		"-c, --chunks        Look only for chunks that match the pattern.\n"
		"-l, --lhs           Match pattern only against the conditions (left-hand side)\n"
		"                    of productions (default).\n"
		"-n, --nochunks      Disregard chunks when looking for the pattern.\n"
		"-r, --rhs           Match pattern against the actions (right-hand side) of\n"
		"                    productions.\n"
		"-s, --show-bindings Show the bindings associated with a wildcard pattern.\n"
		"pattern             Any pattern that can appear in productions.\n"
		"\n"
		"Description\n"
		"\n"
		"The production find command is used to find productions in production memory\n"
		"that include conditions or actions that match a given pattern. The pattern\n"
		"given specifies one or more condition elements on the left hand side of\n"
		"productions (or negated conditions), or one or more actions on the right-hand\n"
		"side of productions. Any pattern that can appear in productions can be used in\n"
		"this command. In addition, the asterisk symbol, *, can be used as a wildcard\n"
		"for an attribute or value. It is important to note that the whole pattern,\n"
		"including the parenthesis, must be enclosed in curly braces for it to be parsed\n"
		"properly.\n"
		"The variable names used in a call to production find do not have to match the\n"
		"variable names used in the productions being retrieved.\n"
		"The production find command can also be restricted to apply to only certain\n"
		"types of productions, or to look only at the conditions or only at the actions\n"
		"of productions by using the flags.\n"
		"\n"
		"Production Find Examples:\n"
		"\n"
		"Find productions that test that some object gumby has an attribute alive with\n"
		"value t. In addition, limit the rules to only those that test an operator named\n"
		"foo:\n"
		"\n"
		"  production find (<state> ^gumby <gv> ^operator.name foo)(<gv> ^alive t)\n"
		"\n"
		"Note that in the above command, <state> does not have to match the exact\n"
		"variable name used in the production.\n"
		"Find productions that propose the operator foo:\n"
		"\n"
		"  production find --rhs (<x> ^operator <op> +)(<op> ^name foo)\n"
		"\n"
		"Find chunks that test the attribute ^pokey:\n"
		"\n"
		"  production find --chunks (<x> ^pokey *)\n"
		"\n"
		"Examples using the water-jugs demo:\n"
		"\n"
		"  source demos/water-jug/water-jug.soar\n"
		"  production-find (<s> ^name *)(<j> ^volume *)\n"
		"  production-find (<s> ^name *)(<j> ^volume 3)\n"
		"  production-find --rhs (<j> ^* <volume>)\n"
		"\n"
		"production firing-counts\n"
		"\n"
		"Print the number of times productions have fired.\n"
		"\n"
		"Synopsis\n"
		"\n"
		"  production firing-counts [type] [n]\n"
		"  production firing-counts production_name\n"
		"\n"
		"Options:\n"
		"\n"
		"If given, an option can take one of two forms -- an integer or a production\n"
		"name:\n"
		"\n"
		"Option               Description\n"
		"n                    List the top n productions. If n is 0, only the\n"
		"                     productions which haven't fired are listed\n"
		"production_name      Print how many times a specific production has fired\n"
		"-f, --fired          Prints only rules that have fired\n"
		"-c, --chunks         Print how many times chunks (learned rules) fired\n"
		"-j, --justifications Print how many times justifications fired\n"
		"-d, --default        Print how many times default productions (:default) fired\n"
		"-r, --rl             Print how many times Soar-RL rules fired\n"
		"-T, --templates      Print how many times Soar-RL templates fired\n"
		"-u, --user           Print how many times user productions (but not chunks or\n"
		"                     default rules) fired\n"
		"\n"
		"Description\n"
		"\n"
		"The production firing-counts command prints the number of times each production\n"
		"has fired; production names are given from most frequently fired to least\n"
		"frequently fired. With no arguments, it lists all productions. If an integer\n"
		"argument, n, is given, only the top n productions are listed. If n is zero (0),\n"
		"only the productions that haven't fired at all are listed. If --fired is used,\n"
		"the opposite happens. Only rules that have fired are listed. If a production\n"
		"name is given as an argument, the firing count for that production is printed.\n"
		"Note that firing counts are reset by a call to soar_init.\n"
		"\n"
		"Examples:\n"
		"\n"
		"This example prints the 10 productions which have fired the most times along\n"
		"with their firing counts:\n"
		"\n"
		"  production firing-counts 10\n"
		"\n"
		"This example prints the firing counts of production my*first*production:\n"
		"\n"
		"  production firing-counts my*first*production\n"
		"\n"
		"This example prints all rules that have fired at least once:\n"
		"\n"
		"  production firing-counts -f\n"
		"\n"
		"production matches\n"
		"\n"
		"The production matches command prints a list of productions that have\n"
		"instantiations in the match set, i.e., those productions that will retract or\n"
		"fire in the next propose or apply phase. It also will print partial match\n"
		"information for a single, named production.\n"
		"\n"
		"Synopsis\n"
		"\n"
		"  production matches [options] production_name\n"
		"  production matches [options] -[a|r]\n"
		"\n"
		"Options:\n"
		"\n"
		"Option                   Description\n"
		"production_name          Print partial match information for the named\n"
		"                         production.\n"
		"                         For the match set, print only the names of the\n"
		"-n, --names, -c, --count productions that are about to fire or retract (the\n"
		"                         default). If printing partial matches for a\n"
		"                         production, just list the partial match counts.\n"
		"-t, --timetags           Also print the timetags of the wmes at the first\n"
		"                         failing condition\n"
		"-w, --wmes               Also print the full wmes, not just the timetags, at\n"
		"                         the first failing condition.\n"
		"-a, --assertions         List only productions about to fire.\n"
		"-r, --retractions        List only productions about to retract.\n"
		"\n"
		"Printing the match set\n"
		"\n"
		"When printing the match set (i.e., no production name is specified), the\n"
		"default action prints only the names of the productions which are about to fire\n"
		"or retract. If there are multiple instantiations of a production, the total\n"
		"number of instantiations of that production is printed after the production\n"
		"name, unless --timetags or --wmes are specified, in which case each\n"
		"instantiation is printed on a separate line.\n"
		"When printing the match set, the --assertions and --retractions arguments can\n"
		"be specified to restrict the output to print only the assertions or\n"
		"retractions.\n"
		"\n"
		"Printing partial matches for productions\n"
		"\n"
		"In addition to printing the current match set, the matches command can be used\n"
		"to print information about partial matches for a named production. In this\n"
		"case, the conditions of the production are listed, each preceded by the number\n"
		"of currently active matches for that condition. If a condition is negated, it\n"
		"is preceded by a minus sign -. The pointer >>>> before a condition indicates\n"
		"that this is the first condition that failed to match.\n"
		"When printing partial matches, the default action is to print only the counts\n"
		"of the number of WME's that match, and is a handy tool for determining which\n"
		"condition failed to match for a production that you thought should have fired.\n"
		"At levels --timetags and --wmes the matches command displays the WME's\n"
		"immediately after the first condition that failed to match -- temporarily\n"
		"interrupting the printing of the production conditions themselves.\n"
		"\n"
		"Notes:\n"
		"\n"
		"When printing partial match information, some of the matches displayed by this\n"
		"command may have already fired, depending on when in the execution cycle this\n"
		"command is called. To check for the matches that are about to fire, use the\n"
		"matches command without a named production.\n"
		"In Soar 8, the execution cycle (decision cycle) is input, propose, decide,\n"
		"apply output; it no longer stops for user input after the decision phase when\n"
		"running by decision cycles (run -d 1). If a user wishes to print the match set\n"
		"immediately after the decision phase and before the apply phase, then the user\n"
		"must run Soar by phases (run -p 1).\n"
		"\n"
		"Examples:\n"
		"\n"
		"This example prints the productions which are about to fire and the WMEs that\n"
		"match the productions on their left-hand sides:\n"
		"\n"
		"  production matches --assertions --wmes\n"
		"\n"
		"This example prints the WME timetags for a single production.\n"
		"\n"
		"  production matches -t my*first*production\n"
		"\n"
		"production memory-usage\n"
		"\n"
		"Print memory usage for partial matches.\n"
		"\n"
		"Synopsis\n"
		"\n"
		"  production memory-usage [options] [number]\n"
		"  production memory-usage production_name\n"
		"\n"
		"Options:\n"
		"\n"
		"Option               Description\n"
		"-c, --chunks         Print memory usage of chunks.\n"
		"-d, --default        Print memory usage of default productions.\n"
		"-j, --justifications Print memory usage of justifications.\n"
		"-u, --user           Print memory usage of user-defined productions.\n"
		"production_name      Print memory usage for a specific production.\n"
		"number               Number of productions to print, sorted by those that use\n"
		"                     the most memory.\n"
		"-T, --template       Print memory usage of Soar-RL templates.\n"
		"\n"
		"Description\n"
		"\n"
		"The memory-usage command prints out the internal memory usage for full and\n"
		"partial matches of production instantiations, with the productions using the\n"
		"most memory printed first. With no arguments, the memory-usage command prints\n"
		"memory usage for all productions. If a production_name is specified, memory\n"
		"usage will be printed only for that production. If a positive integer number is\n"
		"given, only number productions will be printed: the number productions that use\n"
		"the most memory. Output may be restricted to print memory usage for particular\n"
		"types of productions using the command options.\n"
		"Memory usage is recorded according to the tokens that are allocated in the Rete\n"
		"network for the given production(s). This number is a function of the number of\n"
		"elements in working memory that match each production. Therefore, this command\n"
		"will not provide useful information at the beginning of a Soar run (when\n"
		"working memory is empty) and should be called in the middle (or at the end) of\n"
		"a Soar run.\n"
		"The memory-usage command is used to find the productions that are using the\n"
		"most memory and, therefore, may be taking the longest time to match (this is\n"
		"only a heuristic). By identifying these productions, you may be able to rewrite\n"
		"your program so that it will run more quickly. Note that memory usage is just a\n"
		"heuristic measure of the match time: A production might not use much memory\n"
		"relative to others but may still be time-consuming to match, and excising a\n"
		"production that uses a large number of tokens may not speed up your program,\n"
		"because the Rete matcher shares common structure among different productions.\n"
		"As a rule of thumb, numbers less than 100 mean that the production is using a\n"
		"small amount of memory, numbers above 1000 mean that the production is using a\n"
		"large amount of memory, and numbers above 10,000 mean that the production is\n"
		"using a very large amount of memory.\n"
		"\n"
		"production optimize-attribute\n"
		"\n"
		"Declare a symbol to be multi-attributed so that conditions in productions that\n"
		"test that attribute are re-ordered so that the rule can be matched more\n"
		"efficiently.\n"
		"\n"
		"Synopsis\n"
		"\n"
		"  production optimize-attribute [symbol [n]]\n"
		"\n"
		"Options:\n"
		"\n"
		"Option Description\n"
		"symbol Any Soar attribute.\n"
		"n      Integer greater than 1, estimate of degree of simultaneous values for\n"
		"       attribute.\n"
		"\n"
		"Description:\n"
		"\n"
		"This command is used to improve efficiency of matching against attributes that\n"
		"can have multiple values at once.\n"
		"\n"
		"  (S1 ^foo bar1)\n"
		"  (S1 ^foo bar2)\n"
		"  (S1 ^foo bar3)\n"
		"\n"
		"If you know that a certain attribute will take on multiple values, optimize-\n"
		"attribute can be used to provide hints to the production condition reorderer so\n"
		"that it can produce better orderings that allow the Rete network to match\n"
		"faster. This command has no effect on the actual contents of working memory and\n"
		"is only used to improve efficiency in problematic situations.\n"
		"optimize-attribute declares a symbol to be an attribute which can take on\n"
		"multiple values. The optional n is an integer (greater than 1) indicating an\n"
		"upper limit on the number of expected values that will appear for an attribute.\n"
		"If n is not specified, the value 10 is used for each declared multi-attribute.\n"
		"More informed values will tend to result in greater efficiency.\n"
		"Note that optimize-attribute declarations must be made before productions are\n"
		"loaded into soar or this command will have no effect.\n"
		"\n"
		"Example:\n"
		"\n"
		"Declare the symbol \"thing\" to be an attribute likely to take more than 1 but no\n"
		"more than 4 values:\n"
		"\n"
		"  production optimize-attribute thing 4\n"
		"\n"
		"production watch\n"
		"\n"
		"Trace firings and retractions of specific productions.\n"
		"\n"
		"Synopsis\n"
		"\n"
		"  production watch [-d|e] [production name]\n"
		"\n"
		"Options:\n"
		"\n"
		"Option               Description\n"
		"                     Turn production watching off for the specified production.\n"
		"-d, --disable, --off If no production is specified, turn production watching\n"
		"                     off for all productions.\n"
		"                     Turn production watching on for the specified production.\n"
		"-e, --enable, --on   The use of this flag is optional, so this is watch's\n"
		"                     default behavior. If no production is specified, all\n"
		"                     productions currently being watched are listed.\n"
		"production name      The name of the production to watch.\n"
		"\n"
		"Description\n"
		"\n"
		"The production watch command enables and disables the tracing of the firings\n"
		"and retractions of individual productions. This is a companion command to\n"
		"watch, which cannot specify individual productions by name.\n"
		"With no arguments, production watch lists the productions currently being\n"
		"traced. With one production-name argument, production watch enables tracing the\n"
		"production; --enable can be explicitly stated, but it is the default action.\n"
		"If --disable is specified followed by a production-name, tracing is turned off\n"
		"for the production. When no production-name is specified, --enable lists all\n"
		"productions currently being traced, and --disable disables tracing of all\n"
		"productions.\n"
		"Note that production watch now only takes one production per command. Use\n"
		"multiple times to watch multiple functions.\n"
		"\n"
		"Default Aliases\n"
		"\n"
		"  ex                         production excise\n"
		"  excise                     production excise\n"
		"  fc                         production firing-counts\n"
		"  firing-counts              production firing-counts\n"
		"  matches                    production matches\n"
		"  memories                   production memory-usage\n"
		"  multi-attributes           production optimize-attribute\n"
		"  pbreak                     production break\n"
		"  production-find            production find\n"
		"  pw                         production watch\n"
		"  pwatch                     production watch\n"
		"\n"
		"See Also\n"
		"\n"
		"soar_init\n"
		"sp trace\n"
	;
	docstrings["rl"] = 
		"Control how numeric indifferent preference values in RL rules are updated via\n"
		"reinforcement learning.\n"
		"\n"
		"Synopsis\n"
		"\n"
		"  rl -g|--get <parameter>\n"
		"  rl -s|--set <parameter> <value>\n"
		"  rl -t|--trace <parameter> <value>\n"
		"  rl -S|--stats <statistic>\n"
		"\n"
		"Options:\n"
		"\n"
		"Option      Description\n"
		"-g, --get   Print current parameter setting\n"
		"-s, --set   Set parameter value\n"
		"-t, --trace Print, clear, or init traces\n"
		"-S, --stats Print statistic summary or specific statistic\n"
		"\n"
		"Description\n"
		"\n"
		"The rl command sets parameters and displays information related to\n"
		"reinforcement learning. The print and trace commands display additional RL\n"
		"related information not covered by this command.\n"
		"\n"
		"Parameters\n"
		"\n"
		"Due to the large number of parameters, the rl command uses the --get|--set\n"
		"<parameter> <value> convention rather than individual switches for each\n"
		"parameter. Running rl without any switches displays a summary of the parameter\n"
		"settings.\n"
		"\n"
		"Parameter           Description              Possible values         Default\n"
		"                    If enabled, chunking\n"
		"                    does not create\n"
		"chunk-stop          duplicate RL rules that  on, off                 on\n"
		"                    differ only in numeric-\n"
		"                    indifferent preference\n"
		"                    value\n"
		"                    How the learning rate    normal, exponential,\n"
		"decay-mode          changes over time        logarithmic, delta-bar- normal\n"
		"                                             delta\n"
		"discount-rate       Temporal discount        [0, 1]                  0.9\n"
		"                    (gamma)\n"
		"eligibility-trace-  Eligibility trace decay  [0, 1]                  0\n"
		"decay-rate          factor (lambda)\n"
		"eligibility-trace-  Smallest eligibility\n"
		"tolerance           trace value not          (0, inf)                0.001\n"
		"                    considered 0\n"
		"                    Discounting of RL\n"
		"hrl-discount        updates over time in     on, off                 off\n"
		"                    impassed states\n"
		"learning            Reinforcement learning   on, off                 off\n"
		"                    enabled\n"
		"learning-rate       Learning rate (alpha)    [0, 1]                  0.3\n"
		"step-size-parameter Secondary learning rate  [0,1]                   1\n"
		"                                             sarsa, q-learning, off-\n"
		"learning-policy     Value update policy      policy-gq-lambda, on-   sarsa\n"
		"                                             policy-gq-lambda\n"
		"meta                Store rule metadata in   on, off                 off\n"
		"                    header string\n"
		"meta-learning-rate  Delta-Bar-Delta learning [0, 1]                  0.1\n"
		"                    parameter\n"
		"temporal-discount   Discount RL updates over on, off                 on\n"
		"                    gaps\n"
		"temporal-extension  Propagation of RL        on, off                 on\n"
		"                    updates over gaps\n"
		"trace               Update the trace         on, off                 off\n"
		"update-log-path     File to log information  \"\", <filename>          \"\"\n"
		"                    about RL rule updates\n"
		"\n"
		"Apoptosis Parameters:\n"
		"\n"
		"Parameter        Description                    Possible values         Default\n"
		"                 Automatic excising of\n"
		"apoptosis        productions via base-level     none, chunks, rl-chunks none\n"
		"                 decay\n"
		"apoptosis-decay  Base-level decay parameter     [0, 1]                  0.5\n"
		"apoptosis-thresh Base-level threshold parameter (0, inf)                2\n"
		"                 (negates supplied value)\n"
		"\n"
		"Apoptosis is a process to automatically excise chunks via the base-level decay\n"
		"model (where rule firings are the activation events). A value of chunks has\n"
		"this apply to any chunk, whereas rl-chunks means only chunks that are also RL\n"
		"rules can be forgotten.\n"
		"\n"
		"RL Statistics\n"
		"\n"
		"Soar tracks some RL statistics over the lifetime of the agent. These can be\n"
		"accessed using rl --stats <statistic>. Running rl --stats without a statistic\n"
		"will list the values of all statistics.\n"
		"\n"
		"Option        Description\n"
		"update-error  Difference between target and current values in last RL update\n"
		"total-reward  Total accumulated reward in the last update\n"
		"global-reward Total accumulated reward since agent initialization\n"
		"\n"
		"RL Delta-Bar-Delta\n"
		"\n"
		"This is an experimental feature of Soar RL. It based on the work in Richard S.\n"
		"Sutton's paper \"Adapting Bias by Gradient Descent: An Incremental Version of\n"
		"Delta-Bar-Delta\", available online at http://webdocs.cs.ualberta.ca/~sutton/\n"
		"papers/sutton-92a.pdf.\n"
		"Delta Bar Delta (DBD) is implemented in Soar RL as a decay mode. It changes the\n"
		"way all the rules in the eligibility trace get their values updated. In order\n"
		"to implement this, the agent gets an additional learning parameter meta-\n"
		"learning-rate and each rule gets two additional decay parameters: beta and h.\n"
		"The meta learning rate is set manually; the per-rule features are handled\n"
		"automatically by the DBD algorithm. The key idea is that the meta parameters\n"
		"keep track of how much a rule's RL value has been updated recently, and if a\n"
		"rule gets updates in the same direction multiple times in a row then subsequent\n"
		"updates in the same direction will have more effect. So DBD acts sort of like\n"
		"momentum for the learning rate.\n"
		"To enable DBD, use rl --set decay-mode delta-bar-delta. To change the meta\n"
		"learning rate, use e.g. rl --set meta-learning-rate 0.1. When you execute rl,\n"
		"under the \"Experimental\" section of output you'll see the current settings for\n"
		"decay-mode and meta-learning-rate. Also, if a rule gets printed concisely (e.g.\n"
		"by executing p), and the rule is an RL rule, and the decay mode is set to\n"
		"delta-bar-delta, then instead of printing the rule name followed by the update\n"
		"count and the RL value, it will print the rule name, beta, h, update count, and\n"
		"RL value.\n"
		"Note that DBD is a different feature than meta. Meta determines whether\n"
		"metadata about a production is stored in its header string. If meta is on and\n"
		"DBD is on, then each rule's beta and h values will be stored in the header\n"
		"string in addition to the update count, so you can print out the rule, source\n"
		"it later and that metadata about the rule will still be in place.\n"
		"\n"
		"RL GQ(λ)\n"
		"\n"
		"Linear GQ(λ) is a gradient-based off-policy temporal-difference learning\n"
		"algorithm, as developed by Hamid Maei and described by Adam White and Rich\n"
		"Sutton (https://arxiv.org/pdf/1705.03967.pdf). This reinforcement learning\n"
		"option provides off-policy learning quite effectively. This is a good approach\n"
		"in cases when agent training performance is less important than agent execution\n"
		"performance. GQ(λ) converges despite irreversible actions and other\n"
		"difficulties approaching the training goal. Convergence should be guaranteed\n"
		"for stable environments.\n"
		"To change the secondary learning rate that only applies when learning with GQ\n"
		"(λ), set the rl step-size-parameter. It controls how fast the secondary set of\n"
		"weights changes to allow GQ(λ) to improve the rate of convergence to a stable\n"
		"policy. Small learning rates such as 0.01 or even lower seems to be good\n"
		"practice.\n"
		"rl --set learning-policy off-policy-gq-lambda will set Soar to use linear GQ\n"
		"(λ). It is preferable to use GQ(λ) over sarsa or q-learning when multiple\n"
		"weights are active in parallel and sequences of actions required for agents to\n"
		"be successful are sufficiently complex that divergence is possible. To take\n"
		"full advantage of GQ(λ), it is important to set step-size-parameter to a\n"
		"reasonable value for a secondary learning rate, such as 0.01.\n"
		"rl --set learning-policy on-policy-gq-lambda will set Soar to use a\n"
		"simplification of GQ(λ) to make it on-policy while otherwise functioning\n"
		"identically. It is still important to set step-size-parameter to a reasonable\n"
		"value for a secondary learning rate, such as 0.01.\n"
		"For more information, please see the relevant slides on http://www-\n"
		"personal.umich.edu/~bazald/b/publications/009-sw35-gql.pdf\n"
		"\n"
		"RL Update Logging\n"
		"\n"
		"Sets a path to a file that Soar RL will write to whenever a production's RL\n"
		"value gets updated. This can be useful for logging these updates without having\n"
		"to capture all of Soar's output and parse it for these updates. Enable with\n"
		"e.g. rl --set update-log-path rl\\_log.txt. Disable with rl --set update-log-\n"
		"path \"\" - that is, use the empty string \"\" as the log path. The current log\n"
		"path appears under the experimental section when you execute \"rl\".\n"
		"\n"
		"RL Trace\n"
		"\n"
		"If rl --set trace on has been called, then proposed operators will be recorded\n"
		"in the trace for all goal levels. Along with operator names and other\n"
		"attribute-value pairs, transition probabilities derived from their numeric\n"
		"preferences are recorded.\n"
		"Legal arguments following rl -t or rl --trace are as follows:\n"
		"\n"
		"Option Description\n"
		"print  Print the trace for the top state.\n"
		"clear  Erase the traces for all goal levels.\n"
		"init   Restart recording from the beginning of the traces for all goal levels.\n"
		"\n"
		"These may be followed by an optional numeric argument specifying a specific\n"
		"goal level to print, clear, or init. rl -t init is called automatically\n"
		"whenever Soar is reinitialized. However, rl -t clear is never called\n"
		"automatically.\n"
		"The format in which the trace is printed is designed to be used by the program\n"
		"dot, as part of the Graphviz suite. The command ctf rl.dot rl -t will print the\n"
		"trace for the top state to the file \"rl.dot\". (The default behavior for rl -\n"
		"t is to print the trace for the top state.)\n"
		"Here are some sample dot invocations for the top state:\n"
		"\n"
		"Option                     Description\n"
		"dot -Tps rl.dot -o rl.ps   ps2pdf rl.ps\n"
		"dot -Tsvg rl.dot -o rl.svg inkscape -f rl.svg -A rl.pdf\n"
		"\n"
		"The .svg format works better for large traces.\n"
		"\n"
		"See Also\n"
		"\n"
		"excise print trace\n"
	;
	docstrings["run"] = 
		"Begin Soar's execution cycle.\n"
		"\n"
		"Synopsis\n"
		"\n"
		"  run -[d|e|o|p][g][u|n][s] [count] [-i e|p|d|o]\n"
		"\n"
		"Options\n"
		"\n"
		"Option            Description\n"
		"-d, --decision    Run Soar for count decision cycles.\n"
		"-e, --elaboration Run Soar for count elaboration cycles.\n"
		"-o, --output      Run Soar until the nth time output is generated by the agent.\n"
		"                  Limited by the value of max-nil-output-cycles.\n"
		"-p, --phase       Run Soar by phases. A phase is either an input phase,\n"
		"                  proposal phase, decision phase, apply phase, or output phase.\n"
		"-s, --self        If other agents exist within the kernel, do not run them at\n"
		"                  this time.\n"
		"                  Sets a flag in the update event callback requesting that an\n"
		"-u, --update      environment updates. This is the default if --self is not\n"
		"                  specified.\n"
		"                  Sets a flag in the update event callback requesting that an\n"
		"-n, --noupdate    environment does not update. This is the default if --self is\n"
		"                  specified.\n"
		"count             A single integer which specifies the number of cycles to run\n"
		"                  Soar.\n"
		"                  Support round robin execution across agents at a finer grain\n"
		"-i, --interleave  than the run-size parameter. e = elaboration, p = phase, d =\n"
		"                  decision, o = output\n"
		"-g, --goal        Run agent until a goal retracts\n"
		"\n"
		"Deprecated Run Options:\n"
		"\n"
		"These may be reimplemented in the future.\n"
		"\n"
		"Option     Description\n"
		"--operator Run Soar until the nth time an operator is selected.\n"
		"--state    Run Soar until the nth time a state is selected.\n"
		"\n"
		"Description\n"
		"\n"
		"The run command starts the Soar execution cycle or continues any execution that\n"
		"was temporarily stopped. The default behavior of run, with no arguments, is to\n"
		"cause Soar to execute until it is halted or interrupted by an action of a\n"
		"production, or until an external interrupt is issued by the user. The run\n"
		"command can also specify that Soar should run only for a specific number of\n"
		"Soar cycles or phases (which may also be prematurely stopped by a production\n"
		"action or the stop-soar command). This is helpful for debugging sessions, where\n"
		"users may want to pay careful attention to the specific productions that are\n"
		"firing and retracting.\n"
		"The run command takes optional arguments: an integer, count, which specifies\n"
		"how many units to run; and a units flag indicating what steps or increments to\n"
		"use. If count is specified, but no units are specified, then Soar is run by\n"
		"decision cycles. If units are specified, but count is unpecified, then count\n"
		"defaults to '1'. If both are unspecified, Soar will run until either a halt is\n"
		"executed, an interrupt is received, or max stack depth is reached.\n"
		"If there are multiple Soar agents that exist in the same Soar process, then\n"
		"issuing a run command in any agent will cause all agents to run with the same\n"
		"set of parameters, unless the flag --self is specified, in which case only that\n"
		"agent will execute.\n"
		"If an environment is registered for the kernel's update event, then when the\n"
		"event it triggered, the environment will get information about how the run was\n"
		"executed. If a run was executed with the --update option, then then event sends\n"
		"a flag requesting that the environment actually update itself. If a run was\n"
		"executed with the --noupdate option, then the event sends a flag requesting\n"
		"that the environment not update itself. The --update option is the default when\n"
		"run is specified without the --self option is not specified. If the --self\n"
		"option is specified, then the --noupdate option is on by default. It is up to\n"
		"the environment to check for these flags and honor them.\n"
		"Some use cases include:\n"
		"\n"
		"Option              Description\n"
		"run --self          runs one agent but not the environment\n"
		"run --self --update runs one agent and the environment\n"
		"run                 runs all agents and the environment\n"
		"run --noupdate      runs all agents but not the environment\n"
		"\n"
		"Setting an interleave size\n"
		"\n"
		"When there are multiple agents running within the same process, it may be\n"
		"useful to keep agents more closely aligned in their execution cycle than the\n"
		"run increment (--elaboration, --phases, --decisions, --output) specifies. For\n"
		"instance, it may be necessary to keep agents in \"lock step\" at the phase level,\n"
		"even though the run command issued is for 5 decisions. Some use cases include:\n"
		"\n"
		"Option        Description\n"
		"run -d 5 -i p run the agent one phase and then move to the next agent, looping\n"
		"              over agents until they have run for 5 decision cycles\n"
		"              run the agent one decision cycle and then move to the next agent.\n"
		"run -o 3 -i d When an agent generates output for the 3rd time, it no longer\n"
		"              runs even if other agents continue.\n"
		"\n"
		"The interleave parameter must always be equal to or smaller than the specified\n"
		"run parameter.\n"
		"\n"
		"Note\n"
		"\n"
		"If Soar has been stopped due to a halt action, an init-soar command must be\n"
		"issued before Soar can be restarted with the run command.\n"
		"\n"
		"Default Aliases\n"
		"\n"
		"  d             run -d 1\n"
		"  e             run -e 1\n"
		"  step          run -d 1\n"
	;
	docstrings["save"] = 
		"Saves chunks, rete networks and percept streams.\n"
		"\n"
		"Synopsis\n"
		"\n"
		"  ======================================================\n"
		"  -            Save Sub-Commands and Options           -\n"
		"  ======================================================\n"
		"  save [? | help]\n"
		"  ------------------------------------------------------\n"
		"  save agent                           <filename>\n"
		"  save chunks                          <filename>\n"
		"  ------------------------------------------------------\n"
		"  save percepts                        --open <filename>\n"
		"  save percepts                        [--close --flush]\n"
		"  ------------------------------------------------------\n"
		"  save rete-network                    --save <filename>\n"
		"  ------------------------------------------------------\n"
		"  For a detailed explanation of sub-commands:  help save\n"
		"\n"
		"save agent\n"
		"\n"
		"The save agent command will write all procedural and semantic memory to disk,\n"
		"as well as many commonly used settings. This command creates a standard .soar\n"
		"text file, with semantic memory stored as a series of smem --add commands.\n"
		"\n"
		"save chunks\n"
		"\n"
		"The save chunks command will write all chunks in memory to disk. This command\n"
		"creates a standard .soar text file.\n"
		"\n"
		"save rete-network\n"
		"\n"
		"The save rete-network command saves the current Rete net to a file. The Rete\n"
		"net is Soar's internal representation of production memory; the conditions of\n"
		"productions are reordered and common substructures are shared across different\n"
		"productions. This command provides a fast method of saving and loading\n"
		"productions since a special format is used and no parsing is necessary. Rete-\n"
		"net files are portable across platforms that support Soar.\n"
		"Note that justifications cannot be present when saving the Rete net. Issuing a\n"
		"production_excise_-j before saving a Rete net will remove all justifications.\n"
		"If the filename contains a suffix of .Z, then the file is compressed\n"
		"automatically when it is saved and uncompressed when it is loaded. Compressed\n"
		"files may not be portable to another platform if that platform does not support\n"
		"the same uncompress utility.\n"
		"\n"
		"Usage:\n"
		"\n"
		"  save rete-network -s <filename>\n"
		"\n"
		"save percepts\n"
		"\n"
		"Store all incoming input wmes in a file for reloading later. Commands are\n"
		"recorded decision cycle by decision cycle. Use the command load_percepts to\n"
		"replay the sequence.\n"
		"Note that this command seeds the random number generator and writes the seed to\n"
		"the capture file.\n"
		"\n"
		"Options:\n"
		"\n"
		"Option      Description\n"
		"filename    Open filename and begin recording input.\n"
		"-o, --open  Writes captured input to file overwriting any existing data.\n"
		"-f, --flush Writes input to file as soon as it is encountered instead of\n"
		"            storing it in RAM and writing when capturing is turned off.\n"
		"-c, --close Stop capturing input and close the file, writing captured input\n"
		"            unless the flush option is given.\n"
		"\n"
		"Usage\n"
		"\n"
		"  save percepts -o <filename>\n"
		"  ...\n"
		"  save percepts -c\n"
		"\n"
		"Default Aliases\n"
		"\n"
		"  capture-input        save percepts\n"
		"\n"
		"See Also\n"
		"\n"
		"production soar load\n"
	;
	docstrings["smem"] = 
		"Controls the behavior of and displays information about semantic memory.\n"
		"\n"
		"Synopsis\n"
		"\n"
		"  =======================================================\n"
		"  -             Semantic Memory Sub-Commands            -\n"
		"  =======================================================\n"
		"  smem [? | help]                                           Print help screen\n"
		"  smem [--enable | --disable ]                              Turn smem on/off\n"
		"  smem [--get | --set]                 <option> [<value>]   Print or set a parameter\n"
		"  smem --add                        { (id ^attr value)* }   Add memory to smem\n"
		"  smem --backup                                <filename>   Save copy of database\n"
		"  smem --clear                                              Delete contents of smem\n"
		"  smem --export                        <filename> [<LTI>]   Save database to file\n"
		"  smem --init                                               Reinit smem store\n"
		"  smem --query                           {(cue)* [<num>]}   Query smem via given cue\n"
		"  smem --remove                 { (id [^attr [value]])* }   Remove smem structures\n"
		"  ------------------------ Printing ---------------------\n"
		"  print                                                 @   Print all smem contents\n"
		"  print                                             <LTI>   Print specific smem memory\n"
		"  smem --history                                    <LTI>   Print memory activation history\n"
		"  =======================================================\n"
		"  -        Semantic Memory Parameters  (use --set)      -\n"
		"  =======================================================\n"
		"  enabled                                             off\n"
		"  database                              [ MEMORY | file ]   Store database in memory or file\n"
		"  append                                               on   Append or overwrite after init\n"
		"  path                                                      Path to database on disk\n"
		"  ---------------------- Activation ---------------------\n"
		"  activation-mode    [ RECENCY | frequency | base-level ]\n"
		"  activate-on-query                          [ ON | off ]\n"
		"  base-decay                                          0.5   Decay amount for base-level activation\n"
		"  base-update-policy     [ STABLE | naive | incremental ]\n"
		"  base-incremental-threshes                            10   Integer > 0\n"
		"  thresh                                              100   Integer >= 0\n"
		"  base-inhibition                            [ on | OFF ]\n"
		"  ---------- Experimental Spreading Activation ----------\n"
		"  spreading                                  [ on | OFF ]\n"
		"  spreading-limit                                     300   integer > 0\n"
		"  spreading-depth-limit                                10   integer > 0\n"
		"  spreading-baseline                               0.0001   1 > decimal > 0\n"
		"  spreading-continue-probability                      0.9   1 > decimal > 0\n"
		"  spreading-loop-avoidance                   [ on | OFF ]\n"
		"  spreading-edge-updating                    [ on | OFF ]\n"
		"  spreading-wma-source                       [ on | OFF ]\n"
		"  spreading-edge-update-factor                       0.99   1 > decimal > 0\n"
		"  ------------- Database Optimization Settings ----------\n"
		"  lazy-commit                                          on   Delay writing store until exit\n"
		"  optimization                   [ safety | PERFORMANCE ]\n"
		"  cache-size                                        10000   Number of memory pages for SQLite cache\n"
		"  page-size                                            8k   Size of each memory page\n"
		"  ----------------- Timers and Statistics ---------------\n"
		"  timers                      [ OFF | one | two | three ]   How detailed timers should be\n"
		"  smem --timers                                 [<timer>]   Print summary or specifics\n"
		"  smem --stats                                   [<stat>]   Print summary or specifics\n"
		"                    ---------------------\n"
		"  Timers: smem_api, smem_hash, smem_init, smem_query,\n"
		"          smem_ncb_retrieval, three_activation\n"
		"          smem_storage, _total\n"
		"  Stats:  act_updates, db-lib-version, edges, mem-usage,\n"
		"          mem-high, nodes, queries, retrieves, stores\n"
		"  -------------------------------------------------------\n"
		"  For a detailed explanation of these settings:             help smem\n"
		"\n"
		"Summary Output\n"
		"\n"
		"With no arguments, smem will return a quick summary of key aspects of semantic\n"
		"memory.\n"
		"\n"
		"  ====================================================\n"
		"                Semantic Memory Summary\n"
		"  ====================================================\n"
		"  Enabled                                          off\n"
		"  Storage                                       Memory   (append after init)\n"
		"  ----------------------------------------------------\n"
		"  Nodes                                              2\n"
		"  Edges                                              1\n"
		"  Memory Usage                                  406784   bytes\n"
		"  ----------------------------------------------------\n"
		"  For a full list of smem's sub-commands and settings:  smem ?\n"
		"\n"
		"Options:\n"
		"\n"
		"Commands             Description\n"
		"-e, --enable, --on   Enable semantic memory.\n"
		"-d, --disable, --off Disable semantic memory.\n"
		"-g, --get            Print current parameter setting\n"
		"-s, --set            Set parameter value\n"
		"-c, --clear          Deletes all memories\n"
		"-i, --init           Deletes all memories if append is off\n"
		"-S, --stats          Print statistic summary or specific statistic\n"
		"-t, --timers         Print timer summary or specific statistic\n"
		"-a, --add            Add concepts to semantic memory\n"
		"-r, --remove         Remove concepts from semantic memory\n"
		"-q, --query          Print concepts in semantic store matching some cue\n"
		"-h, --history        Print activation history for some LTI\n"
		"-b, --backup         Creates a backup of the semantic database on disk\n"
		"\n"
		"Printing\n"
		"\n"
		"To print from semantic memory, the standard print command can be used, for\n"
		"example, to print a specific LTI:\n"
		"p @23\n"
		"To print the entire semantic store:\n"
		"p @\n"
		"Note that such print commands will honor the --depth parameter passed in.\n"
		"The command trace --smem displays additional trace information for semantic\n"
		"memory not controlled by this command.\n"
		"\n"
		"Parameters\n"
		"\n"
		"Due to the large number of parameters, the smem command uses the --get|--set\n"
		"<parameter> <value> convention rather than individual switches for each\n"
		"parameter. Running smem without any switches displays a summary of the\n"
		"parameter settings.\n"
		"\n"
		"Parameter Description                                 Possible values  Default\n"
		"append    Controls whether database is overwritten or on, off          off\n"
		"          appended when opening or re-initializing\n"
		"database  Database storage method                     file, memory     memory\n"
		"learning  Semantic memory enabled                     on, off          off\n"
		"path      Location of database file                   empty, some path empty\n"
		"\n"
		"The learning parameter turns the semantic memory module on or off. This is the\n"
		"same as using the enable and disable commands.\n"
		"The path parameter specifies the file system path the database is stored in.\n"
		"When path is set to a valid file system path and database mode is set to file,\n"
		"then the SQLite database is written to that path.\n"
		"The append parameter will determine whether all existing facts stored in a\n"
		"database on disk will be erased when semantic memory loads. Note that this\n"
		"affects semantic memory re-initialization also, i.e. if the append setting is\n"
		"off, all semantic facts stored to disk will be lost when a soar init is\n"
		"performed. For semantic memory, append mode is by default on.\n"
		"Note that changes to database, path and append will not have an effect until\n"
		"the database is used after an initialization. This happens either shortly after\n"
		"launch (on first use) or after a database initialization command is issued. To\n"
		"switch databases or database storage types while running, set your new\n"
		"parameters and then perform an smem --init command.\n"
		"\n"
		"Activation Parameters:\n"
		"\n"
		"Parameter          Description               Possible values           Default\n"
		"                   Sets the ordering bias    recency, frequency, base-\n"
		"activation-mode    for retrievals that match level                     recency\n"
		"                   more than one memory\n"
		"                   Determines if the results\n"
		"activate-on-query  of queries should be      on, off                   on\n"
		"                   activated\n"
		"                   Sets the decay parameter\n"
		"base-decay         for base-level activation > 0                       0.5\n"
		"                   computation\n"
		"                   Sets the policy for re-   stable, naive,\n"
		"base-update-policy computing base-level      incremental               stable\n"
		"                   activation\n"
		"                   Sets time deltas after\n"
		"base-incremental-  which base-level          1, 2, 3, ...              10\n"
		"threshes           activation is re-computed\n"
		"                   for old memories\n"
		"thresh             Threshold for activation  0, 1, ...                 100\n"
		"                   locality\n"
		"                   Sets whether or not base-\n"
		"base-inhibition    level activation has a    on, off                   off\n"
		"                   short-term inhibition\n"
		"                   factor.\n"
		"\n"
		"If activation-mode is base-level, three parameters control bias values. The\n"
		"base-decay parameter sets the free decay parameter in the base-level model.\n"
		"Note that we do implement the (Petrov, 2006) approximation, with a history size\n"
		"set as a compile-time parameter (default=10). The base-update-policy sets the\n"
		"frequency with which activation is recomputed. The default, stable, only\n"
		"recomputes activation when a memory is referenced (through storage or\n"
		"retrieval). The naive setting will update the entire candidate set of memories\n"
		"(defined as those that match the most constraining cue WME) during a retrieval,\n"
		"which has severe performance detriment and should be used for experimentation\n"
		"or those agents that require high-fidelity retrievals. The incremental policy\n"
		"updates a constant number of memories, those with last-access ages defined by\n"
		"the base-incremental-threshes set. The base-inhibition parameter switches an\n"
		"additional prohibition factor on or off.\n"
		"\n"
		"Performance Parameters:\n"
		"\n"
		"Parameter    Description                  Possible values           Default\n"
		"cache-size   Number of memory pages used  1, 2, ...                 10000\n"
		"             in the SQLite cache\n"
		"             Delay writing semantic store\n"
		"lazy-commit  changes to file until agent  on, off                   on\n"
		"             exits\n"
		"optimization Policy for committing data   safety, performance       performance\n"
		"             to disk\n"
		"page-size    Size of each memory page     1k, 2k, 4k, 8k, 16k, 32k, 8k\n"
		"             used in the SQLite cache     64k\n"
		"timers       Timer granularity            off, one, two, three      off\n"
		"\n"
		"When the database is stored to disk, the lazy-commit and optimization\n"
		"parameters control how often cached database changes are written to disk. These\n"
		"parameters trade off safety in the case of a program crash with database\n"
		"performance. When optimization is set to performance, the agent will have an\n"
		"exclusive lock on the database, meaning it cannot be opened concurrently by\n"
		"another SQLite process such as SQLiteMan. The lock can be relinquished by\n"
		"setting the database to memory or another database and issuing init-soar/smem -\n"
		"-init or by shutting down the Soar kernel.\n"
		"\n"
		"Statistics\n"
		"\n"
		"Semantic memory tracks statistics over the lifetime of the agent. These can be\n"
		"accessed using smem --stats <statistic>. Running smem --stats without a\n"
		"statistic will list the values of all statistics. Unlike timers, statistics\n"
		"will always be updated.\n"
		"Available statistics are:\n"
		"\n"
		"Name           Label              Description\n"
		"act_updates    Activation Updates Number of times memory activation has been\n"
		"                                  calculated\n"
		"db-lib-version SQLite Version     SQLite library version\n"
		"edges          Edges              Number of edges in the semantic store\n"
		"mem-usage      Memory Usage       Current SQLite memory usage in bytes\n"
		"mem-high       Memory Highwater   High SQLite memory usage watermark in bytes\n"
		"nodes          Nodes              Number of nodes in the semantic store\n"
		"queries        Queries            Number of times the query command has been\n"
		"                                  issued\n"
		"retrieves      Retrieves          Number of times the retrieve command has been\n"
		"                                  issued\n"
		"stores         Stores             Number of times the store command has been\n"
		"                                  issued\n"
		"\n"
		"Timers\n"
		"\n"
		"Semantic memory also has a set of internal timers that record the durations of\n"
		"certain operations. Because fine-grained timing can incur runtime costs,\n"
		"semantic memory timers are off by default. Timers of different levels of detail\n"
		"can be turned on by issuing smem --set timers <level>, where the levels can be\n"
		"off, one, two, or three, three being most detailed and resulting in all timers\n"
		"being turned on. Note that none of the semantic memory statistics nor timing\n"
		"information is reported by the stats command.\n"
		"All timer values are reported in seconds.\n"
		"Level one\n"
		"\n"
		"Timer  Description\n"
		"_total Total smem operations\n"
		"\n"
		"Level two\n"
		"\n"
		"Timer              Description\n"
		"smem_api           Agent command validation\n"
		"smem_hash          Hashing symbols\n"
		"smem_init          Semantic store initialization\n"
		"smem_ncb_retrieval Adding concepts (and children) to working memory\n"
		"smem_query         Cue-based queries\n"
		"smem_storage       Concept storage\n"
		"\n"
		"Level three\n"
		"\n"
		"Timer            Description\n"
		"three_activation Recency information maintenance\n"
		"\n"
		"smem --add\n"
		"\n"
		"Concepts can be manually added to the semantic store using the smem --add\n"
		"<concept> command. The format for specifying the concept is similar to that of\n"
		"adding WMEs to working memory on the RHS of productions. For example:\n"
		"\n"
		"  smem --add {\n"
		"     (<arithmetic> ^add10-facts <a01> <a02> <a03>)\n"
		"     (<a01> ^digit1 1 ^digit-10 11)\n"
		"     (<a02> ^digit1 2 ^digit-10 12)\n"
		"     (<a03> ^digit1 3 ^digit-10 13)\n"
		"  }\n"
		"\n"
		"Although not shown here, the common \"dot-notation\" format used in writing\n"
		"productions can also be used for this command. Unlike agent storage, manual\n"
		"storage is automatically recursive. Thus, the above example will add a new\n"
		"concept (represented by the temporary \"arithmetic\" variable) with three\n"
		"children. Each child will be its own concept with two constant attribute/value\n"
		"pairs.\n"
		"\n"
		"smem --remove\n"
		"\n"
		"Part or all of the information in the semantic store of some LTI can be\n"
		"manually removed from the semantic store using the\n"
		"\n"
		"  smem --remove <concept>\n"
		"\n"
		"command. The format for specifying what to remove is similar to that of adding\n"
		"WMEs to working memory on the RHS of productions. For example:\n"
		"\n"
		"  smem --remove {\n"
		"     (@34 ^good-attribute |gibberish value|)\n"
		"  }\n"
		"\n"
		"If good-attribute is multi-valued, then all values will remain in the store\n"
		"except |gibberish value|. If |gibberish value| is the only value, then good-\n"
		"attribute will also be removed. It is not possible to use the common \"dot-\n"
		"notation\" for this command. Manual removal is not recursive.\n"
		"Another example highlights the ability to remove all of the values for an\n"
		"attribute:\n"
		"\n"
		"  smem --remove {\n"
		"     (@34 ^bad-attribute)\n"
		"  }\n"
		"\n"
		"When a value is not given, all of the values for the given attribute are\n"
		"removed from the LTI in the semantic store.\n"
		"Also, it is possible to remove all augmentations of some LTI from the semantic\n"
		"store:\n"
		"\n"
		"  smem --remove {\n"
		"     (@34)\n"
		"  }\n"
		"\n"
		"This would remove all attributes and values of @34 from the semantic store. The\n"
		"LTI will remain in the store, but will lack augmentations.\n"
		"(Use the following at your own risk.) Optionally, the user can force removal\n"
		"even in the event of an error:\n"
		"\n"
		"  smem -r {(@34 ^bad-attribute ^bad-attribute-2)} force\n"
		"\n"
		"Suppose that LTI @34 did not contain bad-attribute. The above example would\n"
		"remove bad-attribute-2 even though it would indicate an error (having not found\n"
		"bad-attribute).\n"
		"\n"
		"smem --query\n"
		"\n"
		"Queries for LTIs in the semantic store that match some cue can be initialized\n"
		"external to an agent using the smem --query <cue> [<num>] command. The format\n"
		"for specifying the cue is similar to that of adding a new identifier to working\n"
		"memory in the RHS of a rule:\n"
		"\n"
		"  smem --query {\n"
		"      (<cue> ^attribute <wildcard> ^attribute-2 |constant|)\n"
		"  }\n"
		"\n"
		"Note that the root of the cue structure must be a variable and should be unused\n"
		"in the rest of the cue structure. This command is for testing and the full\n"
		"range of queries accessible to the agent are not yet available for the command.\n"
		"For example, math queries are not supported.\n"
		"The additional option of <num> will trigger the display of the top <num> most\n"
		"activated LTIs that matched the cue.\n"
		"The result of a manual query is either to print that no LTIs could be found or\n"
		"to print the information associated with LTIs that were found in the print\n"
		"<lti> format.\n"
		"\n"
		"smem --history\n"
		"\n"
		"When the activation-mode of a semantic store is set to base-level, some history\n"
		"of activation events is stored for each LTI. This history of when some LTI was\n"
		"activated can be displayed:\n"
		"\n"
		"          smem --history @34\n"
		"\n"
		"In the event that semantic memory is not using base-level activation, history\n"
		"will mimic print.\n"
		"\n"
		"Experimental Spreading Activation\n"
		"\n"
		"Parameter                Description                  Possible values Default\n"
		"spreading                Controls whether spreading   on, off         off\n"
		"                         activation is on or off.\n"
		"spreading-limit          Limits amount of spread from 0, 1, ...       300\n"
		"                         any LTI\n"
		"spreading-depth-limit    Limits depth of spread from  0, 1, ..., 10   10\n"
		"                         any LTI\n"
		"spreading-baseline       Gives minimum to spread      0, ..., 1       0.0001\n"
		"                         values.\n"
		"spreading-continue-      Gives 1 - (decay factor of   0, ..., 1       0.9\n"
		"probability              spread with distance)\n"
		"spreading-loop-avoidance Controls whether spread      on, off         off\n"
		"                         traversal avoids self-loops\n"
		"\n"
		"Spreading activation has been added as an additional mechanism for ranking LTIs\n"
		"in response to a query. Spreading activation is only compatible with base-level\n"
		"activation. activation-mode must be set to base-level in order to also use\n"
		"spreading. They are additive. Spreading activation serves to rank LTIs that are\n"
		"connected to those currently instanced in Working Memory more highly than those\n"
		"which are unconnected. Note that spreading should be turned on before running\n"
		"an agent. Also, be warned that an agent which loads a database with spreading\n"
		"activation active at the time of back-up currently has undefined behavior and\n"
		"will likely crash as spreading activation currently maintains state in the\n"
		"database.\n"
		"Spreading activation introduces additional parameters. spreading-limit is an\n"
		"absolute cap on the number of LTIs that can receive spread from a given\n"
		"instanced LTI. spreading-depth-limit is an absolute cap on the depth to which a\n"
		"Working Memory instance of some LTI can spread into the SMem network.\n"
		"spreading-baseline provides a minimum amount of spread that an element can\n"
		"receive. spreading-continue-probability sets the amount of spread that is\n"
		"passed on with greater depth. (It can also be thought of as 1-decay where decay\n"
		"is the loss of spread magnitude with depth.) spreading-loop-avoidance is a\n"
		"boolean parameter which controls whether or not any given spread traversal can\n"
		"loop back onto itself.\n"
		"Note that the default settings here are not necessarily appropriate for your\n"
		"application. For many applications, simply changing the structure of the\n"
		"network can yield wildly different query results even with the same spreading\n"
		"parameters.\n"
		"\n"
		"See Also\n"
		"\n"
		"print trace visualize\n"
	;
	docstrings["soar"] = 
		"Commands and settings related to running Soar\n"
		"\n"
		"Synopsis\n"
		"\n"
		"  ======= Soar General Commands and Settings =======\n"
		"  soar ?                                                 Print this help listing\n"
		"  soar init                                              Re-initializes Soar\n"
		"  soar stop [--self]                                     Stop Soar execution\n"
		"  soar version                                           Print version number\n"
		"  ------------------- Settings ----------------------\n"
		"  keep-all-top-oprefs                    [ on | OFF ]    Keep prefs for o-supported WMEs in top-state\n"
		"  max-elaborations                                100    Max elaborations per decision cycle\n"
		"  max-goal-depth                                   23    Halt at this goal stack depth\n"
		"  max-nil-output-cycles                            15    Impasse after this many nil outputs\n"
		"  max-dc-time                                       0    Interrupt after this much time\n"
		"  max-memory-usage                          100000000    Threshold for memory warning\n"
		"  max-gp                                        20000    Max rules gp can generate\n"
		"  stop-phase   [input|proposal|decision|APPLY|output]    Phase before which Soar will stop\n"
		"  tcl                                    [ on | OFF ]    Allow Tcl code in commands\n"
		"  timers                                 [ ON | off ]    Profile Soar\n"
		"  wait-snc                               [ on | OFF ]    Wait instead of impasse\n"
		"  -----------------------------------------------\n"
		"  To change a setting:                                   soar <setting>\n"
		"  [<value>]\n"
		"  For a detailed explanation of these settings:          help soar\n"
		"\n"
		"Summary View\n"
		"\n"
		"Using the soar command without any arguments will display a summary of Soar's\n"
		"current state of execution and which capabilities of Soar are enabled:\n"
		"\n"
		"  =======================================================\n"
		"                       Soar 9.6.0 Summary\n"
		"  =======================================================\n"
		"  Enabled:                         Core, EBC, SMem, EpMem\n"
		"  Disabled:                             SVS, RL, WMA, SSA\n"
		"  -------------------------------------------------------\n"
		"  Number of rules:                                     52\n"
		"  Decisions                                            20\n"
		"  Elaborations                                         61\n"
		"  -------------------------------------------------------\n"
		"  State stack                        S1, S21 ... S29, S33\n"
		"  Current number of states                              5\n"
		"  Next phase                                        apply\n"
		"  -------------------------------------------------------\n"
		"\n"
		"-------------------------------------------------------------------------------\n"
		"\n"
		"soar init\n"
		"\n"
		"The init command re-initializes Soar. It removes all elements from working\n"
		"memory, wiping out the goal stack, and resets all runtime statistics. The\n"
		"firing counts for all productions are reset to zero. The soar init command\n"
		"allows a Soar program that has been halted to be reset and start its execution\n"
		"from the beginning.\n"
		"soar init does not remove any productions from production memory; to do this,\n"
		"use the production_excise command. Note, however, that all justifications will\n"
		"be removed because they will no longer be supported.\n"
		"\n"
		"soar stop\n"
		"\n"
		"  soar stop [--self]\n"
		"\n"
		"The soar stop command stops any running Soar agents. It sets a flag in the Soar\n"
		"kernel so that Soar will stop running at a \"safe\" point and return control to\n"
		"the user. The --self option will stop only the soar agent where the command is\n"
		"issued. All other agents continue running as previously specified.\n"
		"This command is usually not issued at the command line prompt - a more common\n"
		"use of this command would be, for instance, as a side-effect of pressing a\n"
		"button on a Graphical User Interface (GUI).\n"
		"Note that if a graphical interface doesn't periodically do an \"update\"/flush\n"
		"the pending I/O, then it may not be possible to interrupt a Soar agent from the\n"
		"command line.\n"
		"\n"
		"soar version\n"
		"\n"
		"This command prints the version of Soar to the screen.\n"
		"-------------------------------------------------------------------------------\n"
		"\n"
		"Settings\n"
		"\n"
		"Invoke a sub-command with no arguments to query the current setting. Partial\n"
		"commands are accepted.\n"
		"\n"
		"Option                Valid Values Default\n"
		"keep-all-top-oprefs   on or off    off\n"
		"max-dc-time           >= 0         0\n"
		"max-elaborations      > 0          100\n"
		"max-goal-depth        > 0          23\n"
		"max-gp                > 0          20000\n"
		"max-memory-usage      > 0          100000000\n"
		"max-nil-output-cycles > 0          15\n"
		"stop-phase                         apply\n"
		"tcl                   on or off    off\n"
		"timers                on or off    on\n"
		"wait-snc              >= 1         1\n"
		"\n"
		"soar keep-all-top-oprefs\n"
		"\n"
		"Enabling keep-all-top-oprefs turns off an optimization that reduces memory\n"
		"usage by discarding any internal preferences for WMEs that already have top-\n"
		"level o-support. Turning this setting off allows those preferences to be\n"
		"examined during debugging.\n"
		"\n"
		"soar max-dc-time\n"
		"\n"
		"max-dc-time sets a maximum amount of time a decision cycle is permitted. After\n"
		"output phase, the elapsed decision cycle time is checked to see if it is\n"
		"greater than the old maximum, and the maximum dc time stat is updated (see\n"
		"stats). At this time, this threshold is also checked. If met or exceeded, Soar\n"
		"stops at the end of the current output phase with an interrupted state.\n"
		"\n"
		"soar max-elaborations\n"
		"\n"
		"max-elaborations sets and prints the maximum number of elaboration cycles\n"
		"allowed in a single decision cycle.\n"
		"If n is given, it must be a positive integer and is used to reset the number of\n"
		"allowed elaboration cycles. The default value is 100. max-elaborations with no\n"
		"arguments prints the current value.\n"
		"The elaboration phase will end after max-elaboration cycles have completed,\n"
		"even if there are more productions eligible to fire or retract; and Soar will\n"
		"proceed to the next phase after a warning message is printed to notify the\n"
		"user. This limits the total number of cycles of parallel production firing but\n"
		"does not limit the total number of productions that can fire during\n"
		"elaboration.\n"
		"This limit is included in Soar to prevent getting stuck in infinite loops (such\n"
		"as a production that repeatedly fires in one elaboration cycle and retracts in\n"
		"the next); if you see the warning message, it may be a signal that you have a\n"
		"bug your code. However some Soar programs are designed to require a large\n"
		"number of elaboration cycles, so rather than a bug, you may need to increase\n"
		"the value of max-elaborations.\n"
		"max-elaborations is checked during both the Propose Phase and the Apply Phase.\n"
		"If Soar runs more than the max-elaborations limit in either of these phases,\n"
		"Soar proceeds to the next phase (either Decision or Output) even if quiescence\n"
		"has not been reached.\n"
		"\n"
		"soar max-goal-depth\n"
		"\n"
		"The max-goal-depth command is used to limit the maximum depth of sub-states\n"
		"that an agent can subgoal to. The initial value of this variable is 100;\n"
		"allowable settings are any integer greater than 0. This limit is also included\n"
		"in Soar to prevent getting stuck in an infinite recursive loop, which may come\n"
		"about due to deliberate actions or via an agent bug, such as dropping\n"
		"inadvertently to state-no-change impasses.\n"
		"\n"
		"soar max-gp\n"
		"\n"
		"max-gp is used to limit the number of productions produced by a gp command. It\n"
		"is easy to write a gp rule that has a combinatorial explosion and hangs for a\n"
		"long time while those productions are added to memory. The max-gp setting\n"
		"bounds this.\n"
		"\n"
		"soar max-memory-usage\n"
		"\n"
		"The max-memory-usage setting is used to trigger the memory usage exceeded\n"
		"event. The initial value of this is 100MB (100,000,000); allowable settings are\n"
		"any integer greater than 0.\n"
		"NOTE: The code supporting this event is not enabled by default because the test\n"
		"can be computationally expensive and is needed only for specific embedded\n"
		"applications. Users may enable the test and event generation by uncommenting\n"
		"code in mem.cpp.\n"
		"\n"
		"soar max-nil-output-cycles\n"
		"\n"
		"max-nil-output-cycles sets and prints the maximum number of nil output cycles\n"
		"(output cycles that put nothing on the output link) allowed when running using\n"
		"run-til-output (run --output). If n is not given, this command prints the\n"
		"current number of nil-output-cycles allowed. If n is given, it must be a\n"
		"positive integer and is used to reset the maximum number of allowed nil output\n"
		"cycles.\n"
		"max-nil-output-cycles controls the maximum number of output cycles that\n"
		"generate no output allowed when a run --out command is issued. After this limit\n"
		"has been reached, Soar stops. The default initial setting of n is 15.\n"
		"\n"
		"soar stop-phase\n"
		"\n"
		"stop-phase allows the user to control which phase Soar stops in. When running\n"
		"by decision cycle it can be helpful to have agents stop at a particular point\n"
		"in its execution cycle. The precise definition is that \"running for n decisions\n"
		"and stopping before phase ph means to run until the decision cycle counter has\n"
		"increased by n and then stop when the next phase is ph\". The phase sequence (as\n"
		"of this writing) is: input, proposal, decision, apply, output. Stopping after\n"
		"one phase is exactly equivalent to stopping before the next phase.\n"
		"\n"
		"soar tcl\n"
		"\n"
		"Enabling the tcl setting augments Soar's prompt with Tcl scripting\n"
		"capabilities. In other words, it provides the ability to run Tcl code from any\n"
		"Soar command line by passing all Soar commands first through a Tcl interpreter\n"
		"for processing. (Each agent has its own Tcl interpreter.)\n"
		"This command provides Tcl capabilities to both local and remote clients,\n"
		"including the java-based debugger. It processes Tcl commands in both the Soar\n"
		"command line and any files sourced. Productions can make Tcl calls by writing\n"
		"(exec tcl | <Tcl code> |) clauses on the RHS of rules. Soar symbols and\n"
		"variables can be included in RHS item.\n"
		"Important Notes:\n"
		"\n"
		"* If you source a file that turns tcl on, you cannot use any Tcl code until the\n"
		"  source command returns.\n"
		"  If you'd like to have Tcl turned on automatically when Soar launches, add the\n"
		"  soar tcl on command to your settings.soar file in the main Soar directory.\n"
		"  This activates Tcl mode on initial launch, allowing you to immediately source\n"
		"  files that use Tcl code.\n"
		"* soar tcl off is currently not supported due to memory issues.\n"
		"* Only one RHS Tcl call will produce output.\n"
		"  Soar rhs commands write (and even something like echo) will always work. But\n"
		"  for Tcl commands that produce output, for example, a 'puts' command or a\n"
		"  custom Tcl proc that produces output as a side effect, only the last one will\n"
		"  display output. Note that all rhs Tcl calls do get executed, so they will do\n"
		"  what they are supposed to do, including perhaps writing output to a file. The\n"
		"  print output just doesn’t get redirected to the right place, despite being\n"
		"  produced. As a workaround, a user can make sure that there is only one Tcl\n"
		"  call which needs to produce output and that it comes after any other Tcl RHS\n"
		"  actions.\n"
		"* Does not support Tk code. Tk is a widget toolkit that many Tcl programs use\n"
		"  to provide a GUI, for example, the old Soar TSI debugger.\n"
		"* Tcl code that tries to do low-level Soar SML calls may or may not\n"
		"  work.Creating and deleting a kernel will certainly not work. But other things\n"
		"  like creating an agent may work fine. This caveat is inherent to the design\n"
		"  of Tcl as a plug-in without a main event loop.\n"
		"* Third-party Tcl code that requires a Tcl event loop may or may not work, for\n"
		"  example, the Tcl after command.\n"
		"\n"
		"soar timers\n"
		"\n"
		"This setting is used to control the timers that collect internal profiling\n"
		"information while Soar is running. With no arguments, this command prints out\n"
		"the current timer status. Timers are ENABLED by default. The default\n"
		"compilation flags for soar enable the basic timers and disable the detailed\n"
		"timers. The timers command can only enable or disable timers that have already\n"
		"been enabled with compiler directives. See the stats command for more info on\n"
		"the Soar timing system.\n"
		"\n"
		"soar wait-snc\n"
		"\n"
		"wait-snc controls an architectural wait state. On some systems, especially\n"
		"those that model expert knowledge, a state-no-change may represent a wait state\n"
		"rather than an impasse. The waitsnc command allows the user to switch to a mode\n"
		"where a state-no-change that would normally generate an impasse (and\n"
		"subgoaling), instead generates a wait state. At a wait state, the decision\n"
		"cycle will repeat (and the decision cycle count is incremented) but no state-\n"
		"no-change impasse (and therefore no substate) will be generated.\n"
		"-------------------------------------------------------------------------------\n"
		"\n"
		"Examples\n"
		"\n"
		"  soar init\n"
		"  soar stop -s\n"
		"  soar timers off\n"
		"  soar stop-phase output                 // stop before output phase\n"
		"  soar max-goal-depth 100\n"
		"  soar max-elaborations\n"
		"\n"
		"Default Aliases\n"
		"\n"
		"  init                             soar init\n"
		"  is                               soar init\n"
		"  init-soar                        soar init\n"
		"  interrupt                        soar stop\n"
		"  ss                               soar stop\n"
		"  stop                             soar stop\n"
		"  stop-soar                        soar stop\n"
		"  gp-max                           soar max-gp\n"
		"  max-dc-time                      soar max-dc-time\n"
		"  max-elaborations                 soar max-elaborations\n"
		"  max-goal-depth                   soar max-goal-depth\n"
		"  max-memory-usage                 soar max-memory-usage\n"
		"  max-nil-output-cycles            soar max-nil-output-cycles\n"
		"  set-stop-phase                   soar stop-phase\n"
		"  timers                           soar timers\n"
		"  version                          soar version\n"
		"  waitsnc                          soar wait-snc\n"
		"\n"
		"See Also\n"
		"\n"
		"production_excise run stats\n"
	;
	docstrings["sp"] = 
		"Define a Soar production.\n"
		"\n"
		"Synopsis\n"
		"\n"
		"  sp {production_body}\n"
		"\n"
		"Options\n"
		"\n"
		"Option          Description\n"
		"production_body A Soar production.\n"
		"\n"
		"Description\n"
		"\n"
		"The sp command creates a new production and loads it into production memory.\n"
		"production_body is a single argument parsed by the Soar kernel, so it should be\n"
		"enclosed in curly braces to avoid being parsed by other scripting languages\n"
		"that might be in the same process. The overall syntax of a rule is as follows:\n"
		"\n"
		"    name\n"
		"        [\"documentation-string\"]\n"
		"        [FLAG*]\n"
		"        LHS\n"
		"        -->\n"
		"        RHS\n"
		"\n"
		"The first element of a rule is its name. If given, the documentation-string\n"
		"must be enclosed in double quotes. Optional flags define the type of rule and\n"
		"the form of support its right-hand side assertions will receive. The specific\n"
		"flags are listed in a separate section below. The LHS defines the left-hand\n"
		"side of the production and specifies the conditions under which the rule can be\n"
		"fired. Its syntax is given in detail in a subsequent section. The --> symbol\n"
		"serves to separate the LHS and RHS portions. The RHS defines the right-hand\n"
		"side of the production and specifies the assertions to be made and the actions\n"
		"to be performed when the rule fires. The syntax of the allowable right-hand\n"
		"side actions are given in a later section. (See the Syntax of Soar Programs\n"
		"chapter of the manual for naming conventions and discussion of the design and\n"
		"coding of productions.)\n"
		"If the name of the new production is the same as an existing one, the old\n"
		"production will be overwritten (excised).\n"
		"Rules matching the following requirement are flagged upon being created/\n"
		"sourced: a rule is a Soar-RL rule if and only if its right hand side (RHS)\n"
		"consists of a single numeric preference and it is not a template rule (see\n"
		"FLAGs below). This format exists to ease technical requirements of identifying/\n"
		"updating Soar-RL rules, as well as to make it easy for the agent programmer to\n"
		"add/maintain RL capabilities within an agent. (See the Reinforcement Learning\n"
		"chapter of the manual for further details.)\n"
		"\n"
		"Rule Flags\n"
		"\n"
		"The optional flags are given below. Note that these switches are preceded by a\n"
		"colon instead of a dash -- this is a Soar parser convention.\n"
		"\n"
		"  :o-support      specifies that all the RHS actions are to be given\n"
		"                  o-support when the production fires\n"
		"\n"
		"  :i-support     specifies that all the RHS actions are only to be given\n"
		"                  i-support when the production fires\n"
		"\n"
		"  :default        specifies that this production is a default production\n"
		"                  (this matters for excise -task and trace task)\n"
		"\n"
		"  :chunk          specifies that this production is a chunk\n"
		"                  (this matters for learn trace)\n"
		"\n"
		"  :interrupt      specifies that Soar should stop running when this\n"
		"                  production matches but before it fires\n"
		"                  (this is a useful debugging tool)\n"
		"\n"
		"  :template       specifies that this production should be used to generate\n"
		"                  new reinforcement learning rules by filling in those\n"
		"                  variables that match constants in working memory\n"
		"\n"
		"Multiple flags may be used, but not both of o-support and no-support.\n"
		"Although you could force your productions to provide o-support or i-support by\n"
		"using these commands --- regardless of the structure of the conditions and\n"
		"actions of the production --- this is not proper coding style. The o-support\n"
		"and i-support flags are included to help with debugging, but should not be used\n"
		"in a standard Soar program.\n"
		"\n"
		"Examples\n"
		"\n"
		"  sp {blocks*create-problem-space\n"
		"       \"This creates the top-level space\"\n"
		"       (state <s1> ^superstate nil)\n"
		"       -->\n"
		"       (<s1> ^name solve-blocks-world ^problem-space <p1>)\n"
		"       (<p1> ^name blocks-world)\n"
		"  }\n"
		"\n"
		"See Also\n"
		"\n"
		"production chunk trace\n"
	;
	docstrings["stats"] = 
		"Print information on Soar's runtime statistics.\n"
		"\n"
		"Synopsis\n"
		"\n"
		"  stats [options]\n"
		"\n"
		"Options\n"
		"\n"
		"Option           Description\n"
		"-m, --memory     report usage for Soar's memory pools\n"
		"-l, --learning   report statistics about rules learned via explanation-based\n"
		"                 chunking\n"
		"-r, --rete       report statistics about the rete structure\n"
		"-s, --system     report the system (agent) statistics (default)\n"
		"-M, --max        report the per-cycle maximum statistics (decision cycle time,\n"
		"                 WM changes, production fires)\n"
		"-R, --reset      zero out the per-cycle maximum statistics reported by --max\n"
		"                 command\n"
		"-t, --track      begin tracking the per-cycle maximum statistics reported by --\n"
		"                 max for each cycle (instead of only the max value)\n"
		"-T, --stop-track stop and clear tracking of the per-cycle maximum statistics\n"
		"-c, --cycle      print out collected per-cycle maximum statistics saved by --\n"
		"                 track in human-readable form\n"
		"-C, --cycle-csv  print out collected per-cycle maximum statistics saved by --\n"
		"                 track in comma-separated form\n"
		"-S, --sort N     sort the tracked cycle stats by column number N, see table\n"
		"                 below\n"
		"\n"
		"--sort parameters:\n"
		"\n"
		"Option Description\n"
		"0      Use default sort\n"
		"1, -1  Sort by decision cycle (use negative for descending)\n"
		"2, -2  Sort by DC time (use negative for descending)\n"
		"3, -3  Sort by WM changes (use negative for descending)\n"
		"4, -4  Sort by production firings (use negative for descending)\n"
		"\n"
		"Description\n"
		"\n"
		"This command prints Soar internal statistics. The argument indicates the\n"
		"component of interest, --system is used by default.\n"
		"With the --system flag, the stats command lists a summary of run statistics,\n"
		"including the following:\n"
		"\n"
		"* Version --- The Soar version number, hostname, and date of the run.\n"
		"* Number of productions --- The total number of productions loaded in the\n"
		"  system, including all chunks built during problem solving and all default\n"
		"  productions.\n"
		"* Timing Information --- Might be quite detailed depending on the flags set at\n"
		"  compile time. See note on timers below.\n"
		"* Decision Cycles --- The total number of decision cycles in the run and the\n"
		"  average time-per-decision-cycle in milliseconds.\n"
		"* Elaboration cycles --- The total number of elaboration cycles that were\n"
		"  executed during the run, the average number of elaboration cycles per\n"
		"  decision cycle, and the average time-per-elaboration-cycle in milliseconds.\n"
		"  This is not the total number of production firings, as productions can fire\n"
		"  in parallel.\n"
		"* Production Firings --- The total number of productions that were fired.\n"
		"* Working Memory Changes --- This is the total number of changes to working\n"
		"  memory. This includes all additions and deletions from working memory. Also\n"
		"  prints the average match time.\n"
		"* Working Memory Size --- This gives the current, mean and maximum number of\n"
		"  working memory elements.\n"
		"\n"
		"The stats argument --memory provides information about memory usage and Soar's\n"
		"memory pools, which are used to allocate space for the various data structures\n"
		"used in Soar.\n"
		"The stats argument --learning provides information about rules learned through\n"
		"Soar's explanation-based chunking mechanism. This is the same output that chunk\n"
		"stats provides. For statistics about a specific rule learned, see the explain\n"
		"command.\n"
		"The stats argument --rete provides information about node usage in the Rete\n"
		"net, the large data structure used for efficient matching in Soar.\n"
		"The --max argument reports per-cycle maximum statistics for decision cycle\n"
		"time, working memory changes, and production fires. For example, if Soar runs\n"
		"for three cycles and there were 23 working memory changes in the first cycle,\n"
		"42 in the second, and 15 in the third, the --max argument would report the\n"
		"highest of these values (42) and what decision cycle that it occurred in (2nd).\n"
		"Statistics about the time spent executing the decision cycle and number of\n"
		"productions fired are also collected and reported by --max in this manner. --\n"
		"reset zeros out these statistics so that new maximums can be recorded for\n"
		"future runs. The numbers are also zeroed out with a call to init-soar.\n"
		"The --track argument starts tracking the same stats as the --max argument but\n"
		"records all data for each cycle instead of the maximum values. This data can be\n"
		"printed using the --cycle or --cycle-csv arguments. When printing the data with\n"
		"--cycle, it may be sorted using the --sort argument and a column integer. Use\n"
		"negative numbers for descending sort. Issue --stop-track to reset and clear\n"
		"this data.\n"
		"\n"
		"A Note on Timers\n"
		"\n"
		"The current implementation of Soar uses a number of timers to provide time-\n"
		"based statistics for use in the stats command calculations. These timers are:\n"
		"\n"
		"* total CPU time\n"
		"* total kernel time\n"
		"* phase kernel time (per phase)\n"
		"* phase callbacks time (per phase)\n"
		"* input function time\n"
		"* output function time\n"
		"\n"
		"Total CPU time is calculated from the time a decision cycle (or number of\n"
		"decision cycles) is initiated until stopped. Kernel time is the time spent in\n"
		"core Soar functions. In this case, kernel time is defined as the all functions\n"
		"other than the execution of callbacks and the input and output functions. The\n"
		"total kernel timer is only stopped for these functions. The phase timers (for\n"
		"the kernel and callbacks) track the execution time for individual phases of the\n"
		"decision cycle (i.e., input phase, preference phase, working memory phase,\n"
		"output phase, and decision phase). Because there is overhead associated with\n"
		"turning these timers on and off, the actual kernel time will always be greater\n"
		"than the derived kernel time (i.e., the sum of all the phase kernel timers).\n"
		"Similarly, the total CPU time will always be greater than the derived total\n"
		"(the sum of the other timers) because the overhead of turning these timers on\n"
		"and off is included in the total CPU time. In general, the times reported by\n"
		"the single timers should always be greater than than the corresponding derived\n"
		"time. Additionally, as execution time increases, the difference between these\n"
		"two values will also increase. For those concerned about the performance cost\n"
		"of the timers, all the run time timing calculations can be compiled out of the\n"
		"code by defining NO_TIMING_STUFF (in kernel.h) before compilation.\n"
		"\n"
		"Examples\n"
		"\n"
		"Track per-cycle stats then print them out using default sort:\n"
		"\n"
		"  stats --track\n"
		"  run\n"
		"  stop\n"
		"  stats --cycle\n"
		"\n"
		"Print out per-cycle stats sorting by decision cycle time\n"
		"\n"
		"  stats --cycle --sort 2\n"
		"\n"
		"Print out per-cycle stats sorting by firing counts, descending\n"
		"\n"
		"  stats --cycle --sort -4\n"
		"\n"
		"Save per-cycle stats to file stats.csv\n"
		"\n"
		"  ctf stats.csv stats --cycle-csv\n"
		"\n"
		"Default Aliases\n"
		"\n"
		"  st       stats\n"
		"\n"
		"See Also\n"
		"\n"
		"timers init-soar command-to-file\n"
	;
	docstrings["svs"] = 
		"Control the behavior of the Spatial Visual System\n"
		"\n"
		"Synopsis\n"
		"\n"
		"  svs <path> dir\n"
		"  svs <path> help\n"
		"  svs connect_viewer <port>\n"
		"  svs disconnect_viewer\n"
		"  svs filters\n"
		"  svs filters.<filter_name>\n"
		"  svs commands\n"
		"  svs commands.<command_name>\n"
		"  svs <state>.scene.world\n"
		"  svs <state>.scene.world.<path-to-node>\n"
		"  svs <state>.scene.properties\n"
		"  svs <state>.scene.sgel <sgel-command>\n"
		"  svs <state>.scene.draw on|off\n"
		"  svs <state>.scene.clear\n"
		"\n"
		"Paths\n"
		"\n"
		"SVS can be navigated by specifying a path after the svs command. This path\n"
		"mimicks a directory structure and is specified by dot notation.\n"
		"\n"
		"Path                      Argument Description\n"
		"connect_viewer            <port>   Connects to a svs_viewer listening on the\n"
		"                                   given port\n"
		"disconnect_viewer                  Disconnects from an active svs_viewer\n"
		"filters                            Prints out a list of all the filters\n"
		"filters.<filter_name>              Prints information about a specific filter\n"
		"commands                           Prints out a list of all the soar commands\n"
		"commands.<command_name>            Prints information about a specific command\n"
		"<state>.scene.world                Prints information about the world\n"
		"<state>.scene.<node-path>          Prints information about a specific node\n"
		"<state>.scene.properties           Prints pos/rot/scale/tag info about all\n"
		"                                   nodes\n"
		"<state>.scene.sgel        <sgel>   Sends an sgel command to the scene\n"
		"<state>.scene.draw        on       Causes this scene to be the one drawn on the\n"
		"                                   viewer\n"
		"<state>.scene.draw        off      Stops this scene from being drawn in the\n"
		"                                   viewer\n"
		"<state>.scene.clear                Removes all objects from the given scene\n"
		"\n"
		"Description\n"
		"\n"
		"Each path can be followed by help to print some help info, or followed by dir\n"
		"to see the children of that path. The <state> variable is the identifier for\n"
		"the substate you want to examine. For example, to do things to the topstate\n"
		"scene you would use svs S1.scene.\n"
		"\n"
		"Examples\n"
		"\n"
		"Print the full SVS directory structure\n"
		"\n"
		"  svs . dir\n"
		"\n"
		"Print help information about connect_viewer\n"
		"\n"
		"  svs connect_viewer help\n"
		"\n"
		"Print information about a distance filter\n"
		"\n"
		"  svs filters.distance\n"
		"\n"
		"Print all the nodes in the scene for substate S17\n"
		"\n"
		"  svs S17.scene.world dir\n"
		"\n"
		"Print information about the node wheel2 on car5\n"
		"\n"
		"  svs S1.scene.world.car5.wheel2\n"
		"\n"
		"Add a new node to the scene using SGEL\n"
		"\n"
		"  svs S1.scene.sgel add ball3 world ball .5 position 1 1 1\n"
	;
	docstrings["trace"] = 
		"Control the run-time tracing of Soar.\n"
		"\n"
		"Synopsis\n"
		"\n"
		"  ============================================================\n"
		"                      Soar Trace Messages\n"
		"  ============================================================\n"
		"  ------------------------- Level 1 --------------------------\n"
		"  Operator decisions and states                             on     -d\n"
		"  ------------------------- Level 2 --------------------------\n"
		"  Phases                                                   off     -p\n"
		"  State removals caused by GDS violation                   off     -g\n"
		"  ------------------ Level 3: Rule firings -------------------\n"
		"  Default rules                                            off     -D\n"
		"  User rules                                               off     -u\n"
		"  Chunks                                                   off     -c\n"
		"  Justifications                                           off     -j\n"
		"  Templates                                                off     -T\n"
		"  Firings inhibited by higher-level firings                off     -W\n"
		"  ------------------------- Level 4 --------------------------\n"
		"  WME additions and removals                               off     -w\n"
		"  ------------------------- Level 5 --------------------------\n"
		"  Preferences                                              off     -r\n"
		"  ---------------- Additional Trace Messages -----------------\n"
		"  Chunking dependency analysis                             off     -b\n"
		"  Goal dependency set changes                              off     -G\n"
		"  Episodic memory recording and queries                    off     -e\n"
		"  Numeric preference calculations                          off     -i\n"
		"  Learning Level                                           off     -L 0-2\n"
		"  Reinforcement learning value updates                     off     -R\n"
		"  Semantic memory additions                                off     -s\n"
		"  Working memory activation and forgetting                 off     -a\n"
		"\n"
		"  WME Detail Level                                        none     -n, -t, -f\n"
		"\n"
		"Trace Levels\n"
		"\n"
		"  trace 0-5\n"
		"\n"
		"Use of the --level (-l) flag is optional but recommended.\n"
		"\n"
		"Option Description\n"
		"0      trace nothing; equivalent to -N\n"
		"1      trace decisions; equivalent to -d\n"
		"2      trace phases, gds, and decisions; equivalent to -dpg\n"
		"3      trace productions, phases, and decisions; equivalent to -dpgP\n"
		"4      trace wmes, productions, phases, and decisions; equivalent to -dpgPw\n"
		"5      trace preferences, wmes, productions, phases, and decisions; equivalent\n"
		"       to -dpgPwr\n"
		"\n"
		"It is important to note that trace level 0 turns off ALL trace options,\n"
		"including backtracing, indifferent selection and learning. However, the other\n"
		"trace levels do not change these settings. That is, if any of these settings is\n"
		"changed from its default, it will retain its new setting until it is either\n"
		"explicitly changed again or the trace level is set to 0.\n"
		"\n"
		"Options\n"
		"\n"
		"  trace [options]\n"
		"\n"
		"Option Flag        Argument to Option       Description\n"
		"                                            This flag is optional but\n"
		"                   0 to 5 (see Trace Levels recommended. Set a specific\n"
		"-l, --level        below)                   trace level using an\n"
		"                                            integer 0 to 5, this is an\n"
		"                                            inclusive operation\n"
		"                                            Turns off all printing\n"
		"-N, --none         No argument              about Soar's internals,\n"
		"                                            equivalent to --level 0\n"
		"                                            Print backtracing\n"
		"-b, --backtracing  remove (optional)        information when a chunk or\n"
		"                                            justification is created\n"
		"                                            Controls whether state and\n"
		"-d, --decisions    remove (optional)        operator decisions are\n"
		"                                            printed as they are made\n"
		"                                            Print episodic retrieval\n"
		"-e, --epmem        remove (optional)        traces and IDs of newly\n"
		"                                            encoded episodes\n"
		"                                            Controls printing of\n"
		"-g, --gds          remove (optional)        warnings when a state is\n"
		"                                            removed due to the GDS\n"
		"                                            Controls printing of\n"
		"-G, --gds-wmes     remove (optional)        warnings about wme changes\n"
		"                                            to GDS\n"
		"-i, --indifferent-                          Print scores for tied\n"
		"selection          remove (optional)        operators in random\n"
		"                                            indifferent selection mode\n"
		"                                            Controls whether decisions\n"
		"-p, --phases       remove (optional)        cycle phase names are\n"
		"                                            printed as Soar executes\n"
		"                                            Controls whether the\n"
		"                                            preferences generated by\n"
		"-r, --preferences  remove (optional)        the traced productions are\n"
		"                                            printed when those\n"
		"                                            productions fire or retract\n"
		"                                            Controls whether the names\n"
		"-P, --productions  remove (optional)        of productions are printed\n"
		"                                            as they fire and retract,\n"
		"                                            equivalent to -Dujc\n"
		"-R, --rl           remove (optional)        Print RL debugging output\n"
		"-s, --smem         remove (optional)        Print log of semantic\n"
		"                                            memory storage events\n"
		"                                            Controls the printing of\n"
		"                                            working memory elements\n"
		"-w, --wmes         remove (optional)        that are added and deleted\n"
		"                                            as productions are fired\n"
		"                                            and retracted.\n"
		"-a, --wma          remove (optional)        Print log of working memory\n"
		"                                            activation events\n"
		"                                            Print assertions of rule\n"
		"-A, --assertions   remove (optional)        instantiations and the\n"
		"                                            preferences they generate.\n"
		"\n"
		"When appropriate, a specific option may be turned off using the remove\n"
		"argument. This argument has a numeric alias; you can use 0 for remove. A mix of\n"
		"formats is acceptable, even in the same command line.\n"
		"\n"
		"Tracing Productions\n"
		"\n"
		"By default, the names of the productions are printed as each production fires\n"
		"and retracts (at trace levels 3 and higher). However, it may be more helpful to\n"
		"trace only a specific type of production. The tracing of firings and\n"
		"retractions of productions can be limited to only certain types by the use of\n"
		"the following flags:\n"
		"\n"
		"Option Flag          Argument to Option Description\n"
		"-D, --default        remove (optional)  Control only default-productions as\n"
		"                                        they fire and retract\n"
		"-u, --user           remove (optional)  Control only user-productions as they\n"
		"                                        fire and retract\n"
		"-c, --chunks         remove (optional)  Control only chunks as they fire and\n"
		"                                        retract\n"
		"-j, --justifications remove (optional)  Control only justifications as they\n"
		"                                        fire and retract\n"
		"-T, --template       remote (optional)  Soar-RL template firing trace\n"
		"\n"
		"Note: The production_watch command is used to trace individual productions\n"
		"specified by name rather than trace a type of productions, such as --user.\n"
		"Additionally, when tracing productions, users may set the level of detail to be\n"
		"displayed for WMEs that are added or retracted as productions fire and retract.\n"
		"Note that detailed information about WMEs will be printed only for productions\n"
		"that are being traced.\n"
		"\n"
		"Option Flag    Description\n"
		"-n, --nowmes   When tracing productions, do not print any information about\n"
		"               matching wmes\n"
		"-t, --timetags When tracing productions, print only the timetags for matching\n"
		"               wmes\n"
		"-f, --fullwmes When tracing productions, print the full matching wmes\n"
		"\n"
		"Tracing Learning\n"
		"\n"
		"Option Flag    Argument to Option            Description\n"
		"               noprint, print, or fullprint  Controls the printing of chunks/\n"
		"-L, --learning (see table below)             justifications as they are\n"
		"                                             created\n"
		"\n"
		"As Soar is running, it may create justifications and chunks which are added to\n"
		"production memory. The trace command allows users to monitor when chunks and\n"
		"justifications are created by specifying one of the following arguments to the\n"
		"--learning command:\n"
		"\n"
		"Argument  Alias Effect\n"
		"noprint   0     Print nothing about new chunks or justifications (default)\n"
		"print     1     Print the names of new chunks and justifications when created\n"
		"fullprint 2     Print entire chunks and justifications when created\n"
		"\n"
		"Description\n"
		"\n"
		"The trace command controls the amount of information that is printed out as\n"
		"Soar runs. The basic functionality of this command is to trace various levels\n"
		"of information about Soar's internal workings. The higher the level, the more\n"
		"information is printed as Soar runs. At the lowest setting, 0 (--none), nothing\n"
		"is printed. The levels are cumulative, so that each successive level prints the\n"
		"information from the previous level as well as some additional information. The\n"
		"default setting for the level is 1, (--decisions).\n"
		"The numerical arguments inclusively turn on all levels up to the number\n"
		"specified. To use numerical arguments to turn off a level, specify a number\n"
		"which is less than the level to be turned off. For instance, to turn off\n"
		"tracing of productions, specify --level 2 (or 1 or 0). Numerical arguments are\n"
		"provided for shorthand convenience. For more detailed control over the trace\n"
		"settings, the named arguments should be used.\n"
		"With no arguments, this command prints information about the current trace\n"
		"status, i.e., the values of each parameter.\n"
		"For the named arguments, including the named argument turns on only that\n"
		"setting. To turn off a specific setting, follow the named argument with remove\n"
		"or 0.\n"
		"The named argument --productions is shorthand for the four arguments --default,\n"
		"--user, --justifications, and --chunks.\n"
		"\n"
		"Examples\n"
		"\n"
		"The most common uses of trace are by using the numeric arguments which indicate\n"
		"trace levels. To turn off all printing of Soar internals, do any one of the\n"
		"following (not all possibilities listed):\n"
		"\n"
		"  trace --level 0\n"
		"  trace -l 0\n"
		"  trace -N\n"
		"\n"
		"Note: You can turn off printing at an even lower level using the output\n"
		"command.\n"
		"Although the --level flag is optional, its use is recommended:\n"
		"\n"
		"  trace --level 5   ## OK\n"
		"  trace 5           ## OK, avoid\n"
		"\n"
		"Be careful of where the level is on the command line, for example, if you want\n"
		"level 2 and preferences:\n"
		"\n"
		"  trace -r -l 2 ## Incorrect: -r flag ignored, level 2 parsed after it and\n"
		"  overrides the setting\n"
		"  trace -r 2    ## Syntax error: 0 or remove expected as optional argument to -\n"
		"  r\n"
		"  trace -r -l 2 ## Incorrect: -r flag ignored, level 2 parsed after it and\n"
		"  overrides the setting\n"
		"  trace 2 -r    ## OK, avoid\n"
		"  trace -l 2 -r ## OK\n"
		"\n"
		"To turn on printing of decisions, phases and productions, do any one of the\n"
		"following (not all possibilities listed):\n"
		"\n"
		"  trace --level 3\n"
		"  trace -l 3\n"
		"  trace --decisions --phases --productions\n"
		"  trace -d -p -P\n"
		"\n"
		"Individual options can be changed as well. To turn on printing of decisions and\n"
		"WMEs, but not phases and productions, do any one of the following (not all\n"
		"possibilities listed):\n"
		"\n"
		"  trace --level 1 --wmes\n"
		"  trace -l 1 -w\n"
		"  trace --decisions --wmes\n"
		"  trace -d --wmes\n"
		"  trace -w --decisions\n"
		"  trace -w -d\n"
		"\n"
		"To turn on printing of decisions, productions and WMEs, and turns phases off,\n"
		"do any one of the following (not all possibilities listed):\n"
		"\n"
		"  trace --level 4 --phases remove\n"
		"  trace -l 4 -p remove\n"
		"  trace -l 4 -p 0\n"
		"  trace -d -P -w -p remove\n"
		"\n"
		"To trace the firing and retraction of decisions and only user productions, do\n"
		"any one of the following (not all possibilities listed):\n"
		"\n"
		"  trace -l 1 -u\n"
		"  trace -d -u\n"
		"\n"
		"To trace decisions, phases and all productions except user productions and\n"
		"justifications, and to see full WMEs, do any one of the following (not all\n"
		"possibilities listed):\n"
		"\n"
		"  trace --decisions --phases --productions --user remove --justifications\n"
		"  remove --fullwmes\n"
		"  trace -d -p -P -f -u remove -j 0\n"
		"  trace -f -l 3 -u 0 -j 0\n"
		"\n"
		"Default Aliases\n"
		"\n"
		"  v           trace -A\n"
		"  w           trace\n"
		"  watch       trace\n"
		"\n"
		"See Also\n"
		"\n"
		"epmem production output print run wm\n"
	;
	docstrings["visualize"] = 
		"Creates visualizations of Soar's memory systems or processing.\n"
		"\n"
		"Synopsis\n"
		"\n"
		"  ======= Visualization Commands and Settings =======\n"
		"  visualize ?                                           Print this help listing\n"
		"  visualize [wm | smem | epmem] [id] [depth]            Visualize from memory system\n"
		"  visualize [ identity_graph | ebc_analysis]            Visualize EBC explainer analysis\n"
		"  ------------------ Presentation -------------------\n"
		"  rule-format                          [ name | FULL]   Print all conditions and\n"
		"                                                        actions or just the rule name\n"
		"  memory-format                      [ node | RECORD]   Print memories as records\n"
		"                                                        or just simple nodes\n"
		"  line-style                                 polyline   GraphViz line style that will be used\n"
		"  separate-states                        [ ON | off ]   Whether to create links\n"
		"                                                        between goal states\n"
		"  architectural-wmes                     [ on | OFF ]   Whether to include WMEs\n"
		"                                                        created by the Soar architecture\n"
		"  color-identities                       [ on | OFF ]   Color identities in visualization\n"
		"  use-joined-identities                  [ ON | off ]   Color using final joined identities\n"
		"  ------------------ File Handling ------------------\n"
		"  file-name                                  soar_viz\n"
		"  use-same-file                          [ on | OFF ]   Whether to create new files each time\n"
		"  generate-image                         [ ON | off ]   Whether an image should be created\n"
		"  image-type                                      svg   Image type that will be generated\n"
		"  ------------------ Post Actions -------------------\n"
		"  viewer-launch                          [ ON | off ]   Launch image in viewer\n"
		"  editor-launch                          [ on | OFF ]   Open data file in editor\n"
		"  print-debug                            [ on | OFF ]   Print data file to screen\n"
		"                                                        for debugging\n"
		"\n"
		"Description\n"
		"\n"
		"The visualize command will generate graphical representations of either Soar\n"
		"memory structure or the analysis that explanation-based chunking performed to\n"
		"learn a rule.\n"
		"This command can be instructed to automatically launch a viewer to see the\n"
		"visual representation. If you have an editor that can open graphviz files, you\n"
		"can have Soar launch that automatically as well. (Such editors allow you to\n"
		"move things around and lay out the components of the visualization exactly as\n"
		"you want them.)\n"
		"\n"
		"Visualizing Memory\n"
		"\n"
		"visualize [wm | smem | epmem] [id] [depth]\n"
		"The first argument is the memory system that you want to visualize.\n"
		"The optional id argument allows you to specify either a root identifier from\n"
		"which to start working memory or semantic memory visualizations, or an episode\n"
		"ID for episodic memory visualization.\n"
		"The depth argument specifies how many levels of augmentation that will be\n"
		"printed.\n"
		"\n"
		"Visualizing How a Rule was Learned\n"
		"\n"
		"visualize [ identity_graph | ebc_analysis]\n"
		"visualize identity_graph will create a visualization of how the final\n"
		"identities used in a learned rule were determined. This shows all identities\n"
		"involved and how the identity analysis joined them based on the problem-solving\n"
		"that occurred.\n"
		"visualize ebc_analysis will create a visualization of the chunk that was\n"
		"learned and all rules that fired in a substate that contributed to a rule being\n"
		"learned. In addition to all of the dependencies between rules that fired, this\n"
		"visualization also shows which conditions in the instantiations tested\n"
		"knowledge in the superstate and hence contributed to a conditions in the final\n"
		"learned rule.\n"
		"\n"
		"Presentation Settings\n"
		"\n"
		"rule-format: This setting only applies to visualizing EBC processing. The full\n"
		"format will print all conditions and actions of the rule. The name format will\n"
		"only print a simple object with the rule name.\n"
		"memory-format: This setting only applies to visualizing memory systems. The\n"
		"node format will print a single graphical object for every symbol, using a\n"
		"circle for identifiers and a square for constants. The record format will print\n"
		"a database-style record for each identifier with all of its augmentations as\n"
		"fields. Links to other identifiers appear as arrows.\n"
		"line-style is a parameter that is passed to Graphviz and affects how lines are\n"
		"drawn between objects. See the Graphviz documentation for legal values.\n"
		"separate-states is a parameter that determines whether a link to a state symbol\n"
		"is drawn. When this setting is on, Soar will not connect states and instead\n"
		"will represent it as a constant. This setting only applies to visualizing\n"
		"memory systems.\n"
		"architectural-wmes is a parameter that determines whether working memory\n"
		"elements created by the architecture, for example I/O and the various memory\n"
		"sub-system links, will be included in the visualization. This setting only\n"
		"applies to visualizing memory systems.\n"
		"\n"
		"File Handling Settings\n"
		"\n"
		"file-name specifies the base file name that Soar will use when creating both\n"
		"graphviz data files and images. You can specify a path as well, for example\n"
		"\"visualization/soar_viz\", but make sure the directory exists first!\n"
		"use-same-file tells the visualizer to always overwrite the same files for each\n"
		"visualization. When off, Soar will create a new visualization each time by\n"
		"using the base file name and adding a new number to it each time. Note that\n"
		"this command does not yet handle file creation as robustly as it could. If the\n"
		"file already exists, it will simply overwrite it rather than looking for a new\n"
		"file name.\n"
		"generate-image specifies whether the visualizer should render the graphviz file\n"
		"into an image. This setting is overridden if the viewer-launch setting is\n"
		"enabled.\n"
		"image-type specifies what kind of image that visualizer should create. Graphviz\n"
		"is capable of rendering to a staggering number of different image types. The\n"
		"default that the visualizer uses is SVG, which is a vector-based format that\n"
		"can be scaled without loss of clarity. For other legal formats, see the\n"
		"Graphviz or DOT documentation.\n"
		"\n"
		"Post Action Settings\n"
		"\n"
		"After the data and image files are generated, the visualizer can automatically\n"
		"launch an external program to view or edit the output.\n"
		"viewer-launch specifies whether to launch an image viewer. Most web browser can\n"
		"view SVG files.\n"
		"editor-launch specifies whether to launch whatever program is associated with\n"
		".gv files. For example, on OSX, the program OmniGraffle can be used to great\n"
		"effect.\n"
		"print-debug specifies whether to print the raw Graphviz output to the screen.\n"
		"If you are having problems, you may want to use this setting to see what it is\n"
		"generating for your agent.\n"
		"Note that your operating system chooses which program to launch based on the\n"
		"file type. This feature has not been tested extensively on other platforms.\n"
		"Certain systems may not allow Soar to launch an external program.\n"
		"\n"
		"See Also\n"
		"\n"
		"explain epmem smem chunk\n"
	;
	docstrings["wm"] = 
		"Commands and settings related to working memory and working memory activation.\n"
		"There are four sub-commands: add, remove, activation, and watch.\n"
		"\n"
		"Synopsis\n"
		"\n"
		"  =========================================================\n"
		"  -               WM Sub-Commands and Options             -\n"
		"  =========================================================\n"
		"  wm              [? | help]\n"
		"  ---------------------------------------------------------\n"
		"  wm add          <id> [^]<attribute> <value> [+]\n"
		"  wm remove       <timetag>\n"
		"  ---------------------------------------------------------\n"
		"  wm activation   --get <parameter>\n"
		"                  --set <parameter>                 <value>\n"
		"                        activation             [ on | OFF ]\n"
		"                        petrov-approx          [ on | OFF ]\n"
		"                        forgetting             [ on | OFF ]\n"
		"                        fake-forgetting        [ on | OFF ]\n"
		"                        forget-wme                      all  [all, lti]\n"
		"                        decay-rate                     -0.5  [0 to 1]\n"
		"                        decay-thresh                     -2  [0 to infinity]\n"
		"                        max-pow-cache                    10  MB\n"
		"                        timers                          off  [off, one]\n"
		"                  --history <timetag>\n"
		"                  --stats                                    Print forget stats\n"
		"                  --timers [<timer>]                         Print timing results\n"
		"                    <timer> = wma_forgetting or wma_history\n"
		"  ---------------------------------------------------------\n"
		"  wm watch        --add-filter    --type <t>  pattern\n"
		"                  --remove-filter --type <t>  pattern\n"
		"                  --list-filter  [--type <t>]\n"
		"                  --reset-filter [--type <t>]\n"
		"                                <t> = adds, removes or both\n"
		"  ---------------------------------------------------------\n"
		"\n"
		"  For a detailed explanation of sub-commands:       help wm\n"
		"\n"
		"wm activation\n"
		"\n"
		"The wm activation command changes the behavior of and displays information\n"
		"about working memory activation.\n"
		"To get the activation of individual WMEs, use print -i. To get the reference\n"
		"history of an individual WME, use wm activation -h|--history<timetag>. For\n"
		"example:\n"
		"\n"
		"  print --internal s1\n"
		"  (4000016: S1 ^ct 1000000 [3.6])\n"
		"  (4: S1 ^epmem E1 [1])\n"
		"  (11: S1 ^io I1 [1])\n"
		"  (20: S1 ^max 1000000 [3.4])\n"
		"  (18: S1 ^name ct [3.4])\n"
		"  (4000018: S1 ^operator O1000001 [1] +)\n"
		"  (4000019: S1 ^operator O1000001 [1])\n"
		"  (3: S1 ^reward-link R1 [1])\n"
		"  (8: S1 ^smem S2 [1])\n"
		"  (2: S1 ^superstate nil [1])\n"
		"  (14: S1 ^top-state S1 [1])\n"
		"  (1: S1 ^type state [1])\n"
		"\n"
		"The bracketed values are activation. To get the history of an individual\n"
		"element:\n"
		"\n"
		"  wm activation --history 18\n"
		"  history (60/5999999, first @ d1):\n"
		"   6 @ d1000000 (-1)\n"
		"   6 @ d999999 (-2)\n"
		"   6 @ d999998 (-3)\n"
		"   6 @ d999997 (-4)\n"
		"   6 @ d999996 (-5)\n"
		"   6 @ d999995 (-6)\n"
		"   6 @ d999994 (-7)\n"
		"   6 @ d999993 (-8)\n"
		"   6 @ d999992 (-9)\n"
		"   6 @ d999991 (-10)\n"
		"\n"
		"  considering WME for decay @ d1019615\n"
		"\n"
		"This shows the last 60 references (of 5999999 in total, where the first\n"
		"occurred at decision cycle 1). For each reference, it says how many references\n"
		"occurred in the cycle (such as 6 at decision 1000000, which was one cycle ago\n"
		"at the time of executing this command). Note that references during the current\n"
		"cycle will not be reflected in this command (or computed activation value)\n"
		"until the end of output phase. If forgetting is on, this command will also\n"
		"display the cycle during which the WME will be considered for decay. Even if\n"
		"the WME is not referenced until then, this is not necessarily the cycle at\n"
		"which the WME will be forgotten. However, it is guaranteed that the WME will\n"
		"not be forgotten before this cycle.\n"
		"\n"
		"Options:\n"
		"\n"
		"Option        Description\n"
		"-g, --get     Print current parameter setting\n"
		"-s, --set     Set parameter value\n"
		"-S, --stats   Print statistic summary or specific statistic\n"
		"-t, --timers  Print timer summary or specific timer\n"
		"-h, --history Print reference history of a WME\n"
		"\n"
		"Parameters:\n"
		"\n"
		"The activation command uses the --get|--set <parameter> <value> convention\n"
		"rather than individual switches for each parameter. Running wm activation\n"
		"without any switches displays a summary of the parameter settings.\n"
		"\n"
		"Parameter     Description                               Possible values Default\n"
		"activation    Enable working memory activation          on, off         off\n"
		"decay-rate    WME decay factor                          [0, 1]          0.5\n"
		"decay-thresh  Forgetting threshold                      (0, inf)        2.0\n"
		"forgetting    Enable removal of WMEs with low           on, off         off\n"
		"              activation values\n"
		"forget-wme    If lti only remove WMEs with a long-term  all, lti        all\n"
		"              id\n"
		"max-pow-cache Maximum size, in MB, for the internal pow 1, 2, ...       10\n"
		"              cache\n"
		"petrov-approx Enables the (Petrov 2006) long-tail       on, off         off\n"
		"              approximation\n"
		"timers        Timer granularity                         off, one        off\n"
		"\n"
		"The decay-rate and decay-thresh parameters are entered as positive decimals,\n"
		"but are internally converted to, and printed out as, negative.\n"
		"The petrov-approx may provide additional validity to the activation value, but\n"
		"comes at a significant computational cost, as the model includes unbounded\n"
		"positive exponential computations, which cannot be reasonably cached.\n"
		"When activation is enabled, the system produces a cache of results of calls to\n"
		"the pow function, as these can be expensive during runtime. The size of the\n"
		"cache is based upon three run-time parameters (decay-rate, decay-thresh, and\n"
		"max-pow-cache), and one compile time parameter, WMA_REFERENCES_PER_DECISION\n"
		"(default value of 50), which estimates the maximum number of times a WME will\n"
		"be referenced during a decision. The cache is composed of double variables\n"
		"(i.e. 64-bits, currently) and the number of cache items is computed as follows:\n"
		"e^((decay_thresh - ln(max_refs)) / decay_rate)\n"
		"With the current default parameter values, this will incur about 1.04MB of\n"
		"memory. Holding the decay-rate constant, reasonable changes to decay-thresh\n"
		"(i.e. +/- 5) does not greatly change this value. However, small changes to\n"
		"decay-rate will dramatically change this profile. For instance, keeping\n"
		"everything else constant, a decay-thresh of 0.3 requires ~2.7GB and 0.2\n"
		"requires ~50TB. Thus, the max-pow-cache parameter serves to allow you to\n"
		"control the space vs. time tradeoff by capping the maximum amount of memory\n"
		"used by this cache. If max-pow-cache is much smaller than the result of the\n"
		"equation above, you may experience somewhat degraded performance due to\n"
		"relatively frequent system calls to pow.\n"
		"If forget-wme is lti and forgetting is on, only those WMEs whose id is a long-\n"
		"term identifier at the decision of forgetting will be removed from working\n"
		"memory. If, for instance, the id is stored to semantic memory after the\n"
		"decision of forgetting, the WME will not be removed till some time after the\n"
		"next WME reference (such as testing/creation by a rule).\n"
		"\n"
		"Statistics\n"
		"\n"
		"Working memory activation tracks statistics over the lifetime of the agent.\n"
		"These can be accessed using wm activation --stats <statistic>. Running wm\n"
		"activation --stats without a statistic will list the values of all statistics.\n"
		"Unlike timers, statistics will always be updated.\n"
		"Available statistics are:\n"
		"\n"
		"Name           Label          Description\n"
		"forgotten-wmes Forgotten WMEs Number of WMEs removed from working memory due to\n"
		"                              forgetting\n"
		"\n"
		"Timers\n"
		"\n"
		"Working memory activation also has a set of internal timers that record the\n"
		"durations of certain operations. Because fine-grained timing can incur runtime\n"
		"costs, working memory activation timers are off by default. Timers of different\n"
		"levels of detail can be turned on by issuing wm activation --set timers\n"
		"<level>, where the levels can be off or one, one being most detailed and\n"
		"resulting in all timers being turned on. Note that none of the working memory\n"
		"activation statistics nor timing information is reported by the stats command.\n"
		"All timer values are reported in seconds.\n"
		"Timer Levels:\n"
		"\n"
		"Option         Description\n"
		"wma_forgetting Time to process forgetting operations each cycle\n"
		"wma_history    Time to consolidate reference histories each cycle\n"
		"\n"
		"-------------------------------------------------------------------------------\n"
		"\n"
		"wm add\n"
		"\n"
		"Manually add an element to working memory.\n"
		"\n"
		"  wm add id [^]attribute value [+]\n"
		"\n"
		"Options:\n"
		"\n"
		"Option    Description\n"
		"id        Must be an existing identifier.\n"
		"^         Leading ^ on attribute is optional.\n"
		"attribute Attribute can be any Soar symbol. Use * to have Soar create a new\n"
		"          identifier.\n"
		"value     Value can be any soar symbol. Use * to have Soar create a new\n"
		"          identifier.\n"
		"+         If the optional preference is specified, its value must be +\n"
		"          (acceptable).\n"
		"\n"
		"Description\n"
		"\n"
		"Manually add an element to working memory. wm add is often used by an input\n"
		"function to update Soar's information about the state of the external world.\n"
		"wm add adds a new wme with the given id, attribute, value and optional\n"
		"preference. The given id must be an existing identifier. The attribute and\n"
		"value fields can be any Soar symbol. If * is given in the attribute or value\n"
		"field, Soar creates a new identifier (symbol) for that field. If the preference\n"
		"is given, it can only have the value + to indicate that an acceptable\n"
		"preference should be created for this WME.\n"
		"Note that because the id must already exist in working memory, the WME that you\n"
		"are adding will be attached (directly or indirectly) to the top-level state. As\n"
		"with other WME's, any WME added via a call to add-wme will automatically be\n"
		"removed from working memory once it is no longer attached to the top-level\n"
		"state.\n"
		"\n"
		"Examples\n"
		"\n"
		"This example adds the attribute/value pair ^message-status received to the\n"
		"identifier (symbol) S1:\n"
		"\n"
		"  wm add S1 ^message-status received\n"
		"\n"
		"This example adds an attribute/value pair with an acceptable preference to the\n"
		"identifier (symbol) Z2. The attribute is message and the value is a unique\n"
		"identifier generated by Soar. Note that since the ^ is optional, it has been\n"
		"left off in this case.\n"
		"\n"
		"  wm add Z2 message * +\n"
		"\n"
		"Warnings\n"
		"\n"
		"Be careful how you use this command. It may have weird side effects (possibly\n"
		"even including system crashes). For example, the chunking mechanism can't\n"
		"backtrace through WMEs created via wm add nor will such WMEs ever be removed\n"
		"through Soar's garbage collection. Manually removing context/impasse WMEs may\n"
		"have unexpected side effects.\n"
		"-------------------------------------------------------------------------------\n"
		"\n"
		"wm remove\n"
		"\n"
		"Manually remove an element from working memory.\n"
		"\n"
		"  wm remove timetag\n"
		"\n"
		"Options:\n"
		"\n"
		"Option  Description\n"
		"timetag A positive integer matching the timetag of an existing working memory\n"
		"        element.\n"
		"\n"
		"Description\n"
		"\n"
		"The wm remove command removes the working memory element with the given\n"
		"timetag. This command is provided primarily for use in Soar input functions;\n"
		"although there is no programming enforcement, wm remove should only be called\n"
		"from registered input functions to delete working memory elements on Soar's\n"
		"input link.\n"
		"Beware of weird side effects, including system crashes.\n"
		"\n"
		"Warnings\n"
		"\n"
		"wm remove should never be called from the RHS of a production: if you try to\n"
		"match a WME on the LHS of a production, and then remove the matched WME on the\n"
		"RHS, Soar will crash.\n"
		"If used other than by input and output functions interfaced with Soar, this\n"
		"command may have weird side effects (possibly even including system crashes).\n"
		"Removing input WMEs or context/impasse WMEs may have unexpected side effects.\n"
		"You've been warned.\n"
		"-------------------------------------------------------------------------------\n"
		"\n"
		"wm watch\n"
		"\n"
		"Print information about WMEs matching a certain pattern as they are added and\n"
		"removed.\n"
		"\n"
		"  wm watch -[a|r]  -t <type>  >pattern>\n"
		"  wm watch -[l|R] [-t <type>]\n"
		"\n"
		"Options:\n"
		"\n"
		"Option              Description\n"
		"-a, --add-filter    Add a filter to print wmes that meet the type and pattern\n"
		"                    criteria.\n"
		"-r, --remove-filter Delete filters for printing wmes that match the type and\n"
		"                    pattern criteria.\n"
		"-l, --list-filter   List the filters of this type currently in use. Does not\n"
		"                    use the pattern argument.\n"
		"-R, --reset-filter  Delete all filters of this type. Does not use pattern arg.\n"
		"-t, --type          Follow with a type of wme filter, see below.\n"
		"\n"
		"Watch Patterns:\n"
		"\n"
		"The pattern is an id-attribute-value triplet:\n"
		"\n"
		"  id attribute value\n"
		"\n"
		"Note that * can be used in place of the id, attribute or value as a wildcard\n"
		"that matches any string. Note that braces are not used anymore.\n"
		"\n"
		"Watch Types\n"
		"\n"
		"When using the -t flag, it must be followed by one of the following:\n"
		"\n"
		"Option  Description\n"
		"adds    Print info when a wme is added.\n"
		"removes Print info when a wme is retracted.\n"
		"both    Print info when a wme is added or retracted.\n"
		"\n"
		"When issuing a -R or -l, the -t flag is optional. Its absence is equivalent to\n"
		"-t both.\n"
		"\n"
		"Description\n"
		"\n"
		"This commands allows users to improve state tracing by issuing filter-options\n"
		"that are applied when watching WMEs. Users can selectively define which object-\n"
		"attribute-value triplets are monitored and whether they are monitored for\n"
		"addition, removal or both, as they go in and out of working memory.\n"
		"\n"
		"Examples\n"
		"\n"
		"Users can watch an attribute of a particular object (as long as that object\n"
		"already exists):\n"
		"\n"
		"  soar> wm watch --add-filter -t both D1 speed *\n"
		"\n"
		"or print WMEs that retract in a specific state (provided the state already\n"
		"exists):\n"
		"\n"
		"  soar> wm watch --add-filter -t removes S3 * *\n"
		"\n"
		"or watch any relationship between objects:\n"
		"\n"
		"  soar> wm watch --add-filter -t both * ontop *\n"
		"\n"
		"-------------------------------------------------------------------------------\n"
		"\n"
		"Default Aliases\n"
		"\n"
		"  add-wme       wm add\n"
		"  aw            wm add\n"
		"  remove-wme    wm remove\n"
		"  rw            wm remove\n"
		"  watch-wmes    wm watch\n"
		"  wma           wm activation\n"
		"\n"
		"See Also\n"
		"\n"
		"print trace\n"
	;
}
