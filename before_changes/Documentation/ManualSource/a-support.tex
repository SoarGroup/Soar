% ----------------------------------------------------------------------------
\typeout{--------------- appendix: calculation of o-SUPPORT -----------------}
\chapter{The Calculation of O-Support}
\label{SUPPORT}
\index{support}
\index{i-support}
\index{o-support}
\index{persistence}

This appendix provides a description of when a preference is given O-support by an instantiation (a preference that is not given O-support will have I-support). Soar has four possible procedures for deciding support, which can be selected among with the o-support-mode command (see page \pageref{o-support-mode}). However, only o-support modes 3 \& 4 can be considered current to Soar 8, and o-support mode 4 should be considered an improved version of mode 3.   The default o-support mode is mode 4.

In O-support modes 3 \& 4, support is given production by production; that is, all preferences generated by the RHS of a single instantiated production will have the same support. 


In both modes, a production must meet the following two requirements to create o-supported preferences:
\begin{enumerate}
\item The RHS has no operator proposals, i.e. nothing of the form \begin{verbatim}(<s> ^operator <o> +) \end{verbatim}
\item The LHS has a condition that tests the current operator, i.e. something of the form
\footnote{Sometimes, o-support mode 3 does not notice that this condition is true. This is a bug, which is unlikely to be fixed, since users are encouraged to use mode 4.}
\begin{verbatim}(<s> ^operator <o>)\end{verbatim}
\comment{this is only true if mode 3's checks are improved}
\end{enumerate}



In condition 1, the variable \soar{<s>} must be bound to a state identifier.
In condition 2, the variable \soar{<s>} must be bound to the lowest state identifier. That is to say, each (positive) condition on the LHS takes the form \soar{(id \carat attr value)}, some of these id's match state identifiers, and the system looks for the deepest matched state identifier. The tested current operator must be on this state. For example, in the production-

\begin{verbatim}
sp {elaborate*state*operator*name
  (state <s> ^superstate <s1>)
  (<s1> ^operator <o>)
  (<o> ^name <name>)
-->
  (<s> ^name something)}
\end{verbatim}


the RHS action gets i-support. Of course, the state bound to \soar{<s>} is destroyed when \soar{(<s1> \carat operator <o>)} retracts, so o-support would make little difference. On the other hand, the production- 

\begin{verbatim}
sp {operator*superstate*application
   (state <s> ^superstate <s1>)
   (<s> ^operator <o>)
   (<o> ^name <name>)
 -->
   (<s1> ^sub-operator-name <name>)}
\end{verbatim}

gives o-support to its RHS action, which remains after the substate bound to \soar{<s>} is destroyed. 


There is a third condition that determines support, and it is in this condition that modes 3 \& 4 differ. An extension of condition 1 is that operator augmentations should always receive i-support. Soar has been written to recognize augmentations directly off the operator (ie, \soar{(<o> \carat augmentation value)}), and to attempt to give them i-support. However, there was some confusion about what to do about a production that simultaneously tests an operator, doesn't propose an operator, adds an operator augmentation, and adds a non-operator augmentation, such as-

\begin{verbatim}
sp {operator*augmentation*application
  (state <s> ^task test-support
  	      ^operator <o>)
-->
   (<o> ^new augmentation)
   (<s> ^new augmentation)}
\end{verbatim}


In o-support mode 3, both RHS actions receive o-support; in o-support mode 4, both receive i-support. In either case, Soar will print a warning on firing this production, because this is considered bad coding style.

\nocomment{Support calculations are done at run time, as each production is fired. Could these decisions be done at compile time? Much of the decision is based on the structure of the production, which could be analyzed once as the production was loaded or chunked. However, it may be impossible to guarantee that a variable will be bound to a state id just by examining production syntax. Another issue is whether the state tested in condition 2 is the lowest state - this potentially could differ from instantiation to instantiation. For instance the operator*augmentation*application production above could match against multiple states in the state stack. 

 
%-----------------------------------------------------------
\section{Possible problems with implementation of modes 3 \& 4}

\begin{enumerate}
\item Default mode is actually o-support mode 3. Do we not want 4 to be default?
\item There is still the bug Andy pointed out. In condition 1, the variable \soar{<s>} is \textit{supposed} to be bound to a state variable, but the code does not actually check for this.
\item There is one additional, strange difference between modes 3 \& 4. In condition 3, the \soar{id} of each RHS action is tested to see if it is the id of the operator. This id is represented either as a symbol or as a rete location. Mode 4 tests the id both as a symbol and as a rete location, while mode 3 does only the symbol test. The rete test should be added to mode 3.
\end{enumerate}


\section{O-support modes 1 \& 2}

In o-support modes 1 \& 2, there are some of the same calculations as in 3 \& 4 when a production is matched (which occurs when a wme is added to the rete). In particular, if it is an operator proposal, it is set as IE\_PRODS. Otherwise, if it tests the current operator, it is set as PE\_PRODS, without testing for operator  elaborations. The match is placed on the appropriate dll, according to IE\_PRODS or PE\_PRODS.

Later, when the production is instantiated and the new preferences are built, there are no support calculations for 3 \& 4. But 1 \& 2 have support calculations. I suppose that the purpose of the earlier support calculations is that it places the production on the proper list to be fired during apply or propose,that is, whether it is an IE\_PROD or a PE\_PROD.

During this instantiation process, the function calculate\_support\_for\_instantiation\_preferences() is called to redo support IF the variable need\_to\_do\_support\_calculations is set to TRUE. This variable can be true only when-

\begin{enumerate}
\item  called from chunk\_instantiation OR
\item  \#ifndef SOAR\_8\_ONLY
SOAR\_8\_ONLY is a compile option, which is not defined by default. I think that its purpose is that, when defined, there is no run-time option to switch out of Soar 8. This allows a significant portion of code to be left out. Check out function Soar\_Operand2. 
\end{enumerate}


Mode 2 computes support in what is called 'Doug Pearson's way', which is described as-

 \begin{verbatim}
 For a particular preference p=(id ^attr ...) on the RHS of an
   instantiation [LHS,RHS]:

   RULE #1 (Context pref's): If id is the match state and attr="operator", 
   then p does NOT get o-support.  This rule overrides all other rules.

   RULE #2 (O-A support):  If LHS includes (match-state ^operator ...),
   then p gets o-support.

   RULE #3 (O-M support):  If LHS includes (match-state ^operator ... +),
   then p gets o-support.

   RULE #4 (O-C support): If RHS creates (match-state ^operator ... +/!),
   and p is in TC(RHS-operators, RHS), then p gets o-support.

   Here "TC" means transitive closure; the starting points for the TC are 
   all operators the RHS creates an acceptable/require preference for (i.e., 
   if the RHS includes (match-state ^operator such-and-such +/!), then 
   "such-and-such" is one of the starting points for the TC).  The TC
   is computed only through the preferences created by the RHS, not
   through any other existing preferences or WMEs.

   If none of rules 1-4 apply, then p does NOT get o-support.

   Note that rules 1 through 3 can be handled in linear time (linear in 
   the size of the LHS and RHS); rule 4 can be handled in time quadratic 
   in the size of the RHS (and typical behavior will probably be linear).
   
   
   What is 'match state'? The match goal for the instantiation.
   Match goal - (a match goal is associated with an instantiation).
   Look through instantiated LHS conditions.
   Find the lowest goal state matched to one of the condition's ids.
 \end{verbatim}  
   
O-support mode 1 computes Doug's support and compares it to the poor cousin of mode 3 \& 4 support calculations, ie calculation without checking for operator elaboration. It prints any differences it finds.

}
   
   
 \nocomment{
   
   
   
   
   
   
   

3. the RHS has no direct elaborations of the current operator, ie no actions of the form 
(<o> ^augmentation value).
However, an indirect elaboration such as
   (<o> ^name <d>)
   -->
   (<d> ^augmentation value)
will not prevent o-support.


In mode 3, an instantiation will generate o-supported preferences iff
1. the RHS has no operator proposals (nothing of the form (<s> ^operator <o> +))
2. the LHS has a condition that tests the current operator (something of the form 
(<s> ^operator <o>))
3. 


Operator proposal - a production whose RHS has action (<s> ^operator <o> +))
Operator test - 
	LHS has condition of the form (<s> ^operator <o>)
Operator elaboration -
	o_support_mode 3:
		
	o_support_mode 4:
	

o_support_mode 4: 
1. if an operator proposal - i-support
2. if not an operator test - i-support
3. if an operator test with no elaborations - o-support
4. if an operator test with some elaborations and some non-elaboration, non-function RHS action - i-support (warns)
5. if an operator test with only elaborations - i-support

o_support_mode 3:
1. if an operator proposal - i-support
2. if not an operator test - i-support
3. if an operator test with no elaborations - o-support
4. if an operator test with some elaborations and some non-elaboration, non-function RHS action - o-support (warns)
5. if an operator test with only elaborations - i-support


o_support_mode 0:
1. if an operator proposal - i-support
2. if test operator - o-support
3. else - i-support

}

