;;;; -*-Lisp-*-
;;;; **************************************************************************
;;;; * Build Game: Core Rules                                                 *
;;;; * Transfer Learning in Integrated Cognitive Systems Project              *
;;;; *                                                                        *
;;;; * David J. Stracuzzi                                                     *
;;;; * Arizona State University                                               *
;;;; * Completed: June 20, 2007                                               *
;;;; * Revised:   July  6, 2007                                               *
;;;; **************************************************************************
;;;;
;;;; This file contains the core game description for BUILD.  Rules, facts and 
;;;; persistants for specific game instances appear in other files. Appending
;;;; the file for a game instance to this file will produce a complete, 
;;;; playable game description.
;;;;
;;;; Basic Assumptions and Rules:
;;;; 1)  Environment is two dimensional, with origin in lower left corner.
;;;;
;;;; 2)  All primitive objects are rectangular or square. 
;;;;
;;;; 3)  The weight and strength (ability to support weight) of a primitive
;;;;     depends on its size and material. To assure consistancy, the initial
;;;;     weight of primitives should be set by selecting a "weight factor" for
;;;;     for each material, and then multiplying that factor by the area of
;;;;     the primitive.  Likewise, the strength of a primitive is determined
;;;;     by multiplying the specified "strength factor" by the width of the
;;;;     primitive.
;;;;
;;;; 4)  Braces and reinforcements increase object weight additively, and
;;;;     increase object strength multiplicitively. An object may be braced
;;;;     multiple times, but reinforced only once. There is only one type of
;;;;     brace available for any given material, but there may be multiple
;;;;     types of reinforcement available.
;;;;
;;;; 5)  Braces and reinforcements are not manipulable objects. The agent
;;;;     has a fixed number of each available at the start of the game.
;;;;
;;;; 6)  Any primitive object bearing weight > strength causes collapse.
;;;;
;;;; 7)  The weight of a primitive, P1, and the objects supported by P1 is 
;;;;     distributed evenly among the primitives that support P1.
;;;;
;;;; 8)  Compound objects are formed from sets of connected objects.
;;;;
;;;; 9)  Compounds form strict heirarchies. Only objects (primitive or 
;;;;     compound) that are not already a members of another compound may
;;;;     be added to, or used to start, a compound.
;;;;
;;;; 10) Compounds are permanent (cannot be broken).
;;;;
;;;; 11) Any primitive object (including members of compounds) not directly 
;;;;     supported by another object will cause collapse.
;;;;
;;;; Actions:
;;;; * (add-to-compound ?compound ?object)
;;;;     Effects: 
;;;;     * ?object becomes a member of ?compound
;;;;     * The object-location and object-size of ?compound may change 
;;;;     Requirements:
;;;;     * ?compound already exists
;;;;     * ?compound is not a member of ?object's compound hierarchy
;;;;     * ?object is not a member of any other compound
;;;;     * Some member of ?object (or ?object itself if primitive) is
;;;;       touching some member of ?compound 
;;;;
;;;; * (brace ?object1 ?object2 ?brace-type)
;;;;     Effects: 
;;;;     * The joint between ?object1 and ?object2 is braced by ?brace-type
;;;;     * The object-size (weight) of ?object1 and ?object2 each increase
;;;;       by 1/2 the weight of ?brace-type
;;;;     * The weight of any compound above ?object1 and ?object2 in the 
;;;;       hierarchy increases by the weight of ?brace-type
;;;;     * The number of ?brace-type available is decreased by one
;;;;     * The strength of ?object1 and ?object2 are multiplied by the 
;;;;       strength of ?brace-type
;;;;     Requirements:
;;;;     * ?object1 and ?object are members of the same compound
;;;;     * ?object1 and ?object2 are primitives of the same material
;;;;     * ?brace-type is an appropriate material for bracing ?object1
;;;;       and ?object2
;;;;     * ?brace-type has count greater than 0
;;;;     * ?object1 and ?object2 form a joint (L-shaped or T-shaped)
;;;;     * ?object1 and ?object2 have not already been braced
;;;;
;;;; * (make-new-compound ?object)
;;;;     Effects:
;;;;     * A new compound object is created, with unique identifier
;;;;     * ?object is a member of the new compound
;;;;     * The new compound has the same location and size as ?object
;;;;     Requirements
;;;;     * ?object is an existing object (primitive or compound)
;;;;     * ?object is not a member of any other compound
;;;;
;;;; * (nudge ?object ?side)
;;;;     Effects:
;;;;     * ?object moves one unit toward ?side
;;;;     Requirements
;;;;     * ?object must weigh less than "max-movable-weight"
;;;;     * Nothing is stacked on top of ?object
;;;;     * ?object is not a member of any compound
;;;;     * ?object does not intersect any other primitive object once moved
;;;;     * ?side must be "left" or "right"
;;;;
;;;; * (place-adjacent ?object1 ?object2 ?side)
;;;;     Effects:
;;;;     * ?object2 is placed adjacent to (touching) ?object1's ?side.
;;;;       If ?side=top, then ?object2 is centered on top of ?object1 
;;;;       (failure if it won't fit).  If ?side=left or right, then the
;;;;       lowest available support is selected such that ?object1 and ?
;;;;       object2 touch (failure if none exists). ?side=bottom not allowed.
;;;;     * ?object2's location is changed
;;;;     * If ?object2 is compound, the locations of all members of the 
;;;;       compound hierarchy are appropriately updated
;;;;     Requirements:
;;;;     * ?object1 and ?object2 are not members of any compound
;;;;     * Nothing is stacked on top of ?object2
;;;;     * ?object2 must weigh less than "max-movable-weight"
;;;;     * There is some object available to support ?object2
;;;;     * ?object2's new location is different from the old
;;;;     * ?object2 does not intersect any other primitive once moved
;;;;
;;;; * (reinforce ?object ?reinforcement-type)
;;;;     Effects:
;;;;     * ?object is reinforced with ?reinforcement-type
;;;;     * ?object's weight increases by weight of ?reinforcement-type
;;;;     * The weight of any compound above ?object in the hierarchy
;;;;       increases by the weight of ?reinforcement-type
;;;;     * ?object's strength is multiplied by that of ?reinforcement-type
;;;;     Requirements:
;;;;     * ?reinforcement-type is an appropriate material for ?object
;;;;     * ?object has not already been reinforced
;;;;     * ?reinforcement-type has count greater than 0
;;;;
;;;; * (rotate ?object)
;;;;     Effects:
;;;;     * The width and height dimensions of ?object are exchanged
;;;;     Requirements:
;;;;     * ?object is primitive
;;;;     * ?object is not of type "ground"
;;;;     * ?object is not a member of any compound
;;;;     * ?object does not intersect any primitive after rotation
;;;;
;;;; Persistants:
;;;;   (braced ?object1 ?object2 ?brace-type)
;;;;   (current-identifier ?id)
;;;;   (member ?compound ?object)
;;;;   (object ?object ?type)
;;;;   (object-location ?object ?x ?y)
;;;;   (object-size ?object ?width ?height ?weight)
;;;;   (reinforced ?object ?reinforcement-type)

;;; ---------------------------------------------------------------------------
;;; FACTS: Domain facts. These remain fixed across all game instances.

(role agent)

(next-identifier id1 id2)
(next-identifier id2 id3)
(next-identifier id3 id4)
(next-identifier id4 id5)
(next-identifier id5 id6)
(next-identifier id6 id7)
(next-identifier id7 id8)
(next-identifier id8 id9)
(next-identifier id9 id10)
(next-identifier id10 id11)
(next-identifier id11 id12)
(next-identifier id12 id13)
(next-identifier id13 id14)
(next-identifier id14 id15)
(next-identifier id15 id16)
(next-identifier id16 id17)
(next-identifier id17 id18)
(next-identifier id18 id19)
(next-identifier id19 id20)

(orientation horizontal)
(orientation vertical)

(power 2 0 1)
(power 2 1 2)
(power 2 2 4)
(power 2 3 8)
(power 2 4 16)
(power 2 5 32)

(power 3 0 1)
(power 3 1 3)
(power 3 2 9)
(power 3 3 27)
(power 3 4 81)
(power 3 5 243)

(power 4 0 1)
(power 4 1 4)
(power 4 2 16)
(power 4 3 64)
(power 4 4 256)
(power 4 5 768)

(side bottom)
(side left)
(side right)
(side top)

;;; ---------------------------------------------------------------------------
;;; ENTAILMENTS: Relations that must be logically derived from persistants.

;;; Action predicates: these are true if ?agent performed the given action
;;; in the current time step (i.e. (does agent ...) is true).   Some of
;;; these have several cases, including versions that apply when the object
;;; acted upon is a member of a larger compound that must be updated in some
;;; manner.
(<= (action-add-to-compound agent ?compound)
    (does agent (add-to-compound ?compound ?object)))

(<= (action-brace agent ?brace-type)
    (does agent (brace ?object1 ?object2 ?brace-type)))

(<= (action-brace agent ?object1)
    (does agent (brace ?object1 ?object2 ?brace-type)))

(<= (action-brace agent ?object2)
    (does agent (brace ?object1 ?object2 ?brace-type)))

(<= (action-brace agent ?compound)
    (does agent (brace ?object1 ?object2 ?brace-type))
    (is-recursive-member-of-compound ?compound ?object1))

(<= (action-brace agent ?compound)
    (does agent (brace ?object1 ?object2 ?brace-type))
    (is-recursive-member-of-compound ?compound ?object2))

(<= (action-make-new-compound agent)
    (does agent (make-new-compound ?object)))

(<= (action-nudge agent ?object)
    (does agent (nudge ?object ?side)))

(<= (action-nudge agent ?object)
    (does agent (nudge ?compound ?side))
    (is-recursive-member-of-compound ?compound ?object))

(<= (action-place-adjacent agent ?object2)
    (does agent (place-adjacent ?object1 ?object2 ?side)))

(<= (action-place-adjacent agent ?object)
    (does agent (place-adjacent ?object1 ?compound ?side))
    (is-recursive-member-of-compound ?compound ?object))

(<= (action-reinforce agent ?reinforcement-type)
    (does agent (reinforce ?object ?reinforcement-type)))

(<= (action-reinforce agent ?object)
    (does agent (reinforce ?object ?reinforcement-type)))

(<= (action-reinforce agent ?object)
    (does agent (reinforce ?member ?reinforcement-type))
    (is-recursive-member-of-compound ?object ?member))

(<= (action-rotate agent ?object)
    (does agent (rotate ?object)))

;;; Compute whether two objects are adjacent (touching) on ?object1's ?side.
;;; Cases:
;;; 1) ?object1 and ?object2 are both compound. Must find at least one member
;;;    primitive from each that is touching the other.
;;; 2) ?object1 is primitve, ?object2 is compound. Find one member primitive
;;;    of ?object2 that is touching ?object1.
;;; 3) ?object1 is compound, ?object2 is primitive. Similar to 2).
;;; 4) ?object1 and ?object2 both primitive, ?object2 below ?object1.
;;; 5) ?object1 and ?object2 both primitive, ?object2 left of ?object1.
;;; 6) ?object1 and ?object2 both primitive, ?object2 right of ?object1.
;;; 7) ?object1 and ?object2 both primitive, ?object2 on top of ?object1.
(<= (adjacent ?object1 ?object2 ?side)
	(true (object ?object1 compound))
    (true (object ?object2 compound))
    (not (is-recursive-member-of-compound ?object1 ?object2))
    (is-recursive-member-of-compound ?object1 ?primitive1)
    (primitive-object ?primitive1)
    (adjacent ?primitive1 ?object2 ?side))

(<= (adjacent ?primitive1 ?object2 ?side)
    (true (object ?object2 compound))
    (primitive-object ?primitive1)
    (not (is-recursive-member-of-compound ?object2 ?primitive1))
    (is-recursive-member-of-compound ?object2 ?primitive2)
    (primitive-object ?primitive2)
    (adjacent ?primitive1 ?primitive2 ?side))

(<= (adjacent ?object1 ?primitive2 ?side)
	(true (object ?object1 compound))
    (primitive-object ?primitive2)
    (not (is-recursive-member-of-compound ?object1 ?primitive2))
    (is-recursive-member-of-compound ?object1 ?primitive1)
    (primitive-object ?primitive1)
    (adjacent ?primitive1 ?primitive2 ?side))

(<= (adjacent ?primitive1 ?primitive2 bottom)
    (primitive-object ?primitive1)
    (primitive-object ?primitive2)
    (object-coordinates ?primitive1 ?x11 ?shared ?x12 ?y12)
    (object-coordinates ?primitive2 ?x21 ?y21 ?x22 ?shared)
    (> ?x12 ?x21)
    (> ?x22 ?x11))

(<= (adjacent ?primitive1 ?primitive2 left)
    (primitive-object ?primitive1)
    (primitive-object ?primitive2)
    (object-coordinates ?primitive1 ?shared ?y11 ?x12 ?y12)
    (object-coordinates ?primitive2 ?x21 ?y21 ?shared ?y22)
    (> ?y12 ?y21)
    (> ?y22 ?y11))

(<= (adjacent ?primitive1 ?primitive2 right)
    (primitive-object ?primitive1)
    (primitive-object ?primitive2)
    (object-coordinates ?primitive1 ?x11 ?y11 ?shared ?y12)
    (object-coordinates ?primitive2 ?shared ?y21 ?x22 ?y22)
    (> ?y12 ?y21)
    (> ?y22 ?y11))

(<= (adjacent ?primitive1 ?primitive2 top)
    (primitive-object ?primitive1)
    (primitive-object ?primitive2)
    (object-coordinates ?primitive1 ?x11 ?y11 ?x12 ?shared)
    (object-coordinates ?primitive2 ?x21 ?shared ?x22 ?y22)
    (> ?x12 ?x21)
    (> ?x22 ?x11))

;;; Compute whether two objects are adjacent on any side.
(<= (adjacent-on-any-side ?object1 ?object2)
    (true (object ?object1 compound))
    (true (object ?object2 ?type2))
    (side ?side)
    (adjacent ?object1 ?object2 ?side)
    ;; manual mod
    (distinct ?object1 ?object2)
    (distinct ?type2 ground)
    (not (material-is-brace-type ?type2))
    (not (material-is-reinforcement-type ?type2))
    ;;(not (is-member-of-any-compound ?object2))
	(not (true (member ?anycompound ?object2)))
    (not (is-recursive-member-of-compound ?object2 ?object1))
    )

;;; Determine the number of objects adjacent to primitive ?object's ?side.
(<= (adjacent-primitive-count ?object ?side ?number)
    (leftmost-adjacent-primitive ?object ?leftmost ?side)
    (adjacent-primitive-count-recursive ?object ?leftmost ?side ?number))

;;; Determine the number of primitive objects adjacent to ?object's ?side
;;;  that are located right of ?left (including ?left).
;; manual mod
;;(<= (adjacent-primitive-count-recursive ?object ?left ?side ?number)
(<= (adjacent-primitive-count-recursive ?object ?left bottom ?number)
    (leftmost-adjacent-primitive-to-right ?object ?left ?next bottom)
    (adjacent-primitive-count-recursive ?object ?next bottom ?n)
    (+ ?n 1 ?number)
	;; manual mod
	(adjacent ?object ?left bottom)
	)

;; manual mod
;;(<= (adjacent-primitive-count-recursive ?object ?left ?side 1)
(<= (adjacent-primitive-count-recursive ?object ?left bottom 1)
    (primitive-object ?object)
    (primitive-object ?left)
    ;;(side ?side)
    (not (adjacent-primitive-to-right ?object ?left bottom))
     ;; manual mod
    (distinct ?object ?left)
	(adjacent ?object ?left bottom)
    )

;;; Determine if any primitive is adjacent to ?object's ?side to the 
;;; right of ?left
(<= (adjacent-primitive-to-right ?object ?left ?side)
    (adjacent ?object ?left ?side)
    (adjacent ?object ?right ?side)
    (true (object-location ?left ?left-x ?left-y))
    (true (object-location ?right ?right-x ?right-y))
    (> ?right-x ?left-x)
	;; manual mod
	(adjacent ?object ?left ?side)
	)
	

;;; Compute whether any object is adjacent to ?object1's ?side
;;; manual mod
;;(<= (adjacent-to-any-object ?object1 ?side)
;;    (true (object ?object1 ?type1))
;;    (true (object ?object2 ?type2))
;;    (side ?side)
;;    (adjacent ?object1 ?object2 ?side)
;;    )

;;; Compute whether two objects are aligned on one side
;;; (e.g. left sides have the same x-coordinate)
;;(<= (aligned ?object1 ?object2 bottom)
;;    (object-coordinates ?object1 ?x11 ?bottom ?x12 ?y12)
;;    (object-coordinates ?object2 ?x21 ?bottom ?x22 ?y22)
    ;; manual mod
;;    (adjacent ?object1 ?object2 bottom)
 ;;   )

(<= (aligned ?object1 ?object2 left)
    (object-coordinates ?object1 ?left ?y11 ?x12 ?y12)
    (object-coordinates ?object2 ?left ?y21 ?x22 ?y22)
    ;; manual mod
    (adjacent ?object1 ?object2 bottom)
    )

(<= (aligned ?object1 ?object2 right)
    (object-coordinates ?object1 ?x11 ?y11 ?right ?y12)
    (object-coordinates ?object2 ?x21 ?y21 ?right ?y22)
    ;; manual mod
    (adjacent ?object1 ?object2 bottom)
    )

;;(<= (aligned ?object1 ?object2 top)
;;    (object-coordinates ?object1 ?x11 ?y11 ?x12 ?top)
;;    (object-coordinates ?object2 ?x21 ?y21 ?x22 ?top)
;;    ;; manual mod
;;    (adjacent ?object1 ?object2 bottom)
;;    )

;;; Determine if any action is available to the agent.
(<= (available-action)
    (can-add-to-compound ?compound ?object))

(<= (available-action)
    (can-brace ?object1 ?object2 ?brace-type))

(<= (available-action)
    (can-make-new-compound ?object))

(<= (available-action)
    (can-nudge ?object ?side))

(<= (available-action)
    (can-place-adjacent ?object1 ?object2 ?side))

(<= (available-action)
    (can-reinforce ?object ?reinforcement-type))

(<= (available-action)
    (can-rotate ?object))

;;; Determine the number of objects to which ?object is braced. Cases:
;;; 1) ?object not braced
;;; 2) ?object vertically oriented, and has one brace 
;;; 3) ?object vertically oriented, and has two braces (>2 impossible for vert)
;;; 4) ?object horizontally oriented, and has at least one brace
(<= (brace-count ?object 0)
    (true (object ?object ?type))
    (not (braced-object ?object)))

(<= (brace-count ?object 1)
    (object-orientation ?object vertical)
    (braced-object ?object)
    (not (braced-twice ?object)))

(<= (brace-count ?object 2)
    (object-orientation ?object vertical)
    (braced-twice ?object))

(<= (brace-count ?object ?number)
    (object-orientation ?object horizontal)
    (leftmost-brace ?object ?leftmost)
    (brace-count-recursive ?object ?leftmost ?number))

;;; Determine the number of objects to which ?object is braced 
;;; to the right of ?left (including ?left)
(<= (brace-count-recursive ?object ?left 1)
    (braced-joint ?object ?left)
    (not (brace-to-right ?object ?left)))

(<= (brace-count-recursive ?object ?left ?number)
    (leftmost-brace-to-right ?object ?left ?next)
    (brace-count-recursive ?object ?next ?n)
    (+ ?n 1 ?number))

;;; Determine the strength multiplier for a braced object. Cases:
;;; 1) ?object is braceable
;;; 2) ?object is not braceable
(<= (brace-strength-factor ?object ?factor)
    (true (object ?object ?obj-type))
    (brace-type ?brace-type ?obj-type ?brace-strength ?brace-weight)
    (brace-count ?object ?n)
    (power ?brace-strength ?n ?factor))

(<= (brace-strength-factor ?object 1)
    (true (object ?object ?obj-type))
    (not (material-is-braceable ?obj-type)))

;;; Determine if there exists an object braced to ?object to the right of ?left
(<= (brace-to-right ?object ?left)
    (braced-joint ?object ?left)
    (braced-joint ?object ?right)
    (true (object-location ?left ?left-x ?left-y))
    (true (object-location ?right ?right-x ?right-y))
    (> ?right-x ?left-x))

;;; Compute whether ?object1 and ?object2 have been braced (any type).
(<= (braced-joint ?object1 ?object2)
    (true (braced ?object1 ?object2 ?brace-type)))

(<= (braced-joint ?object1 ?object2)
    (true (braced ?object2 ?object1 ?brace-type)))

;;; Determine whether ?object has been braced
(<= (braced-object ?object)
    (true (braced ?object ?object2 ?brace-type)))

(<= (braced-object ?object)
    (true (braced ?object1 ?object ?brace-type)))

;;; Determine whether ?object has been braced twice
(<= (braced-twice ?object)
    (braced-joint ?object ?object2)
    (braced-joint ?object ?object3)
    (distinct ?object2 ?object3))

;;; Determine if ?bridge extends across the open space between the objects
;;; ?left and ?right. Requirements include:
;;; 1) The top of ?left and ?right is at the same height
;;; 2) ?left is to the left of ?right and there is space between the two
;;; 3) Every cell between ?left and ?right at the same height as their tops
;;;    has a support that is a member of ?bridge (the bridge deck)
(<= (bridge ?bridge ?left ?right)
    (object-coordinates ?left ?x11 ?y11 ?x12 ?y)
    (object-coordinates ?right ?x21 ?y21 ?x22 ?y)
    (> ?x21 ?x12)
    (- ?x21 1 ?end-x)
    (bridge-segment ?bridge ?x12 ?end-x ?y))

;;; Determine if, for every cell between ?start-x and ?end-x at height ?y, 
;;; there is a support that is a member of ?bridge. Cases:
;;; 1) Base: ?start-x > ?end-x
;;; 2) General: A primitive object ?support has top at ?y, is clear on top, 
;;;    and ?start-x is between ?support's left and right sides
(<= (bridge-segment ?bridge ?start-x ?end-x ?y)
    (true (object ?bridge ?type))
    (number ?y)
    (> ?start-x ?end-x))

(<= (bridge-segment ?bridge ?start-x ?end-x ?y)
    (primitive-object ?support)
    (is-recursive-member-of-compound ?bridge ?support)
    (object-coordinates ?support ?x1 ?y1 ?x2 ?y)
    (true (object-size ?support ?width ?height ?weight))
    (>= ?start-x ?x1)
    (> ?x2 ?start-x)
    (+ ?start-x ?width ?next-x)
    (clear ?support top)
    (bridge-segment ?bridge ?next-x ?end-x ?y))

;;; Determine if ?object may be added to ?compound. Legal if:
;;; 1) ?compound is an existing compound
;;; 2) ?compound and ?object are different
;;; 2) ?compound is not a recursive sub-compound of ?object
;;; 3) ?object is not a member of any other compound
;;; 4) ?object is adjacent to (touching) some primitive member of ?compound
(<= (can-add-to-compound ?compound ?object)
    (true (object ?compound compound))
    (true (object ?object ?type))
    (distinct ?compound ?object)
    (distinct ?type ground)
    (not (material-is-brace-type ?type))
    (not (material-is-reinforcement-type ?type))
    ;;(not (is-member-of-any-compound ?object))
	(not (true (member ?anycompound ?object)))
    (not (is-recursive-member-of-compound ?object ?compound))
    (adjacent-on-any-side ?compound ?object))

;;; Determine if the joint between ?object1 and ?object2 may be braced 
;;; with ?brace. Legal if:
;;; 1) ?object1 and ?object2 are in the same compound
;;; 2) ?object1 and ?object2 are primitives of same material
;;; 3) ?brace-type is an appropriate material for bracing given objects
;;; 4) There is at least one ?brace-type available
;;; 5) ?object1 and ?object2 form a joint (L-shape or T-shape)
;;; 6) ?object1 and ?object2 have not already been braced
(<= (can-brace ?object1 ?object2 ?brace-type)
    (same-compound ?compound ?object1 ?object2)
    (same-primitive-material ?material ?object1 ?object2)
    (brace-type ?brace-type ?material ?brace-strength ?brace-weight)
    (true (count ?brace-type ?count))
    (> ?count 0)
    (joint ?object1 ?object2)
    (not (braced-joint ?object1 ?object2)))

;;; Determine if a new compound may be made from ?object. Legal if:
;;; 1) ?object is any existing object
;;; 2) ?object is not a member of any existing compound
(<= (can-make-new-compound ?object)
    (true (object ?object ?type))
    (distinct ?type ground)
    (distinct ?type compound)
    (not (material-is-brace-type ?type))
    (not (material-is-reinforcement-type ?type))
    ;;(not (is-member-of-any-compound ?object))
	(not (true (member ?anycompound ?object)))
	)

;;; Determine if ?object can be nudged toward ?side. Legal if:
;;; 1) ?object weighs less than WMAX
;;; 2) nothing is stacked on top of ?object
;;; 3) ?object is not in any compound
;;; 4) ?object does not intersect any other object once moved
;;; 5) ?object is supported once moved
(<= (can-nudge ?object ?side)
    (movable ?object)
    (clear ?object top)
    ;;(not (is-member-of-any-compound ?object))
	(not (true (member ?anycompound ?object)))
    (coordinates-after-nudge ?object ?side ?x1 ?y1 ?x2 ?y2)
    (not (region-intersected-by-object ?object ?x1 ?y1 ?x2 ?y2))
    (support-for-nudge ?object ?support ?side))

;;; Move ?object2 adjacent to (touching) ?object1's ?side. Legal if:
;;; 1) ?object1 and ?object2 are different
;;; 2) ?object1 and ?object2 are not in any compound
;;; 3) nothing is stacked on top of ?object2
;;; 4) ?object2 weighs less than WMAX
;;; 5) there is some object available to support ?object2
;;; 6) ?object2's new location is different from the old location
;;; 7) ?object2 does not intersect any other object once moved
(<= (can-place-adjacent ?object1 ?object2 ?side)
    (true (object ?object1 ?object1-type))
    (true (object ?object2 ?object2-type))
    (distinct ?object1 ?object2)
    ;;(not (is-member-of-any-compound ?object1))
    ;;(not (is-member-of-any-compound ?object2))
	(not (true (member ?anycompound ?object1)))
	(not (true (member ?anycompound ?object2)))
    (clear ?object2 top)
    (movable ?object2)
    (coordinates-after-place ?object1 ?object2 ?side ?x1 ?y1 ?x2 ?y2)
    (not (object-coordinates ?object2 ?x1 ?y1 ?x2 ?y2))
    (not (region-intersected-by-object ?object2 ?x1 ?y1 ?x2 ?y2))
	;; manual mod
	;;(clear ?object1 ?side) ;; actually don't need to be entirely clear
	)

;;; Reinforce ?object with ?reinforcement. Legal if:
;;; 1) ?reinforcement-type can be used on ?object
;;; 2) ?object has not already been reinforced
;;; 3) There is at least 1 ?reinforcement-type available
(<= (can-reinforce ?object ?reinforcement-type)
    (true (object ?object ?object-type))
    (reinforcement-type ?reinforcement-type ?object-type ?strength ?weight)
    (not (reinforced-object ?object))
    (true (count ?reinforcement-type ?count))
    (> ?count 0))

;;; Determine if an object may be rotated. True if:
;;; 1) ?object is primitive
;;; 2) ?object is not of type "ground"
;;; 3) Nothing is on top of ?object
;;; 4) ?object is not a member of any compound
;;; 5) ?object does not intersect any primitive after rotation
(<= (can-rotate ?object)
    (coordinates-after-rotate ?object ?x1 ?y1 ?x2 ?y2)
    (not (region-intersected-by-object ?object ?x1 ?y1 ?x2 ?y2)))

;;manual mod
(<= (coordinates-after-rotate ?object ?x1 ?y1 ?x2 ?y2)
	(true (object ?object ?type))
    (true (object-location ?object ?x1 ?y1))
    (true (object-size ?object ?width ?height ?weight))
    ;; manual mod
    (distinct ?width ?height)
    (material-type ?type ?strength);; preventing compound
    (distinct ?type ground)
	(movable ?object)
    (clear ?object top)
	;; manual mod
	(distinct ?type compound)
	(+ ?x1 ?height ?x2)
    (+ ?y1 ?width ?y2)
	;;(not (is-member-of-any-compound ?object))
	(not (true (member ?anycompound ?object)))
)


;;; Determine if ?object is clear of other objects on ?side 
(<= (clear ?object ?side)
    (true (object ?object ?type))
    (side ?side)
    ;;(not (adjacent-to-any-object ?object ?side)))
	(not (adjacent ?object ?anyobject ?side)))

;;; Determine if any ?object causes the current structure to collapse. Cases:
;;; 1) ?object is supporting too much weight and is crushed
;;; 2) ?object is not supported by any other object, and falls
(<= collapsed
    (crushed ?object))

(<= collapsed
    (unsupported ?object))

;;; Determine whether the members of ?compound form a column. Requirements:
;;; 1) ?compound is a compound (primitives are not columns)
;;; 2) ?compound is vertically oriented
;;; 3) All members of ?compound have the same width
;;; 4) All members of ?compound have the same x-coordinate
(<= (column ?compound)
    (true (object ?compound compound))
    (object-orientation ?compound vertical)
    (not (members-have-different-width ?compound))
    (not (members-have-different-x-coordinate ?compound)))

;;; Determine new coordinates for ?compound when ?object is added.
(<= (coordinates-after-add ?compound ?object ?x1 ?y1 ?x2 ?y2)
    ;;(can-add-to-compound ?compound ?object)
    (does agent (add-to-compound ?compound ?object))
    (object-coordinates ?compound ?cx1 ?cy1 ?cx2 ?cy2)
    (object-coordinates ?object ?ox1 ?oy1 ?ox2 ?oy2)
    (- ?cx1 ?ox1 ?test-x1)
    (- ?cx2 ?ox2 ?test-x2)
    (- ?cy1 ?oy1 ?test-y1)
    (- ?cy2 ?oy2 ?test-y2)
    (if-gt0-then-else-x1 ?test-x1 ?ox1 ?cx1 ?x1)
    (if-gt0-then-else-x2 ?test-x2 ?cx2 ?ox2 ?x2)
    (if-gt0-then-else-y1 ?test-y1 ?oy1 ?cy1 ?y1)
    (if-gt0-then-else-y2 ?test-y2 ?cy2 ?oy2 ?y2))

;;; Determines new coordinates for ?object when pushed toward ?side. Cases:
;;; 1) ?side = left
;;; 2) ?side = right
(<= (coordinates-after-nudge ?object left ?x1 ?y1 ?x2 ?y2)
    (object-coordinates ?object ?ox1 ?y1 ?ox2 ?y2)
    (- ?ox1 1 ?x1)
    (- ?ox2 1 ?x2)
	;; manual mode
	(true (object ?object ?type))
	(distinct ?type ground)
	(movable ?object)
    ;; this is for primitive nudge
	(clear ?object top)
	;;(not (is-member-of-any-compound ?object))
	(not (true (member ?anycompound ?object)))
	)



(<= (coordinates-after-nudge ?object right ?x1 ?y1 ?x2 ?y2)
    (object-coordinates ?object ?ox1 ?y1 ?ox2 ?y2)
    (+ ?ox1 1 ?x1)
    (+ ?ox2 1 ?x2)
	;; manual mode
	(true (object ?object ?type))
	(distinct ?type ground)
	(movable ?object)
	;; this is for primitive nudge
    (clear ?object top)
	;;(not (is-member-of-any-compound ?object))
	(not (true (member ?anycompound ?object)))
	)


(<= (coordinates-after-nudge ?object left ?x1 ?y1 ?x2 ?y2)
    (object-coordinates ?object ?ox1 ?y1 ?ox2 ?y2)
    (- ?ox1 1 ?x1)
    (- ?ox2 1 ?x2)
	;; manual mode
	(true (object ?object ?type))
	(distinct ?type ground)
	(movable ?object)
    ;; this is for resursive nudge within a compound
	(true (object ?compound compound))
	;;(not (is-member-of-any-compound ?compound))
	(not (true (member ?anycompound ?compound)))
	(is-recursive-member-of-compound ?compound ?object)
	(does agent (nudge ?compound left))
	(clear ?compound top)
	)

(<= (coordinates-after-nudge ?object right ?x1 ?y1 ?x2 ?y2)
    (object-coordinates ?object ?ox1 ?y1 ?ox2 ?y2)
    (+ ?ox1 1 ?x1)
    (+ ?ox2 1 ?x2)
	;; manual mode
	(true (object ?object ?type))
	(distinct ?type ground)
	(movable ?object)
    ;; this is for resursive nudge within a compound
	(true (object ?compound compound))
	;;(not (is-member-of-any-compound ?compound))
	(not (true (member ?anycompound ?compound)))
	(is-recursive-member-of-compound ?compound ?object)
	(does agent (nudge ?compound right))
	(clear ?compound top)
	)

;;; Determines potential coordinates for ?object2 on ?object1's ?side. Cases:
;;; 1) ?side = left
;;; 2) ?side = right
;;; 3) ?side = top
(<= (coordinates-after-place ?object1 ?object2 left ?x1 ?y1 ?x2 ?y2)
    (true (object-location ?object1 ?x2 ?oy1))
    (true (object-size ?object2 ?width2 ?height2 ?weight2))
    (support-for-place ?object1 ?object2 ?support left)
    (object-coordinates ?support ?sx1 ?sy1 ?sx2 ?y1)
    (- ?x2 ?width2 ?x1)
    (+ ?y1 ?height2 ?y2)
    ;;manual mod
    (movable ?object2)
	(distinct ?type2 ground)
    (clear ?object2 top)
    (distinct ?object1 ?object2)
	(not (is-recursive-member-of-compound ?object2 ?object1))
	;;(not (is-member-of-any-compound ?object2))
	(not (true (member ?anycompound ?object2)))
    (distinct ?object1 ?support)
    (distinct ?object2 ?support)
    )

(<= (coordinates-after-place ?object1 ?object2 right ?x1 ?y1 ?x2 ?y2)
    (primitive-object ?support)
    (support-for-place ?object1 ?object2 ?support right)
    (object-coordinates ?support ?sx1 ?sy1 ?sx2 ?y1)
    (object-coordinates ?object1 ?ox1 ?oy1 ?x1 ?oy2)
    (true (object-size ?object2 ?width2 ?height2 ?weight2))
    (+ ?x1 ?width2 ?x2)
    (+ ?y1 ?height2 ?y2)
    ;; manual mod
    (movable ?object2)
	(distinct ?type2 ground)
    (clear ?object2 top)
    (distinct ?object1 ?object2)
	(not (is-recursive-member-of-compound ?object2 ?object1))
	;;(not (is-member-of-any-compound ?object2))
	(not (true (member ?anycompound ?object2)))
    (distinct ?object1 ?support)
    (distinct ?object2 ?support)
    )

(<= (coordinates-after-place ?object1 ?object2 top ?x11 ?y12 ?x22 ?y22)
    (true (object-size ?object1 ?width1 ?height1 ?weight1))
    (true (object-size ?object2 ?width2 ?height2 ?weight2))
    (object-coordinates ?object1 ?x11 ?y11 ?x12 ?y12)
    (+ ?x11 ?width2 ?x22)
    (+ ?y12 ?height2 ?y22)
   ;; (/ ?width1 2 ?tmp1)
   ;; (/ ?width2 2 ?tmp2)
   ;; (round ?tmp1 ?half-width1)
   ;; (round ?tmp2 ?half-width2)
   ;; (+ ?x11 ?half-width1 ?centerx)
   ;; (- ?centerx ?half-width2 ?x21)
   ;; (+ ?x21 ?width2 ?x22)
   ;; (+ ?y21 ?height2 ?y22)
    ;; manual mod
    (movable ?object2)
	(distinct ?type2 ground)
	(not (is-recursive-member-of-compound ?object2 ?object1))
	;;(not (is-member-of-any-compound ?object2))
	(not (true (member ?anycompound ?object2)))
    (clear ?object1 top)
    (clear ?object2 top)
    (distinct ?object1 ?object2)
    )

;;; Determine if ?object is crushed by the objects resting on it.
(<= (crushed ?object)
    (strength ?object ?strength)
    (supported-weight ?object ?weight)
    (> ?weight ?strength))

;;; A simple terinary operator: determine if ?test is greater than 0, 
;;; if so, then ?result (4th arg) takes value of ?then, otherwise ?result
;;; takes value of ?else.  
;;(<= (if-gt0-then-else ?test ?then ?else ?then)
;;    (number ?then)
;;    (number ?else)
;;    (> ?test 0))

;;(<= (if-gt0-then-else ?test ?then ?else ?else)
;;    (number ?then)
;;    (number ?else)
;;    (>= 0 ?test))

;; 1-1
(<= (if-gt0-then-else-x1 ?test-x1 ?ox1 ?cx1 ?ox1)
    ;;(can-add-to-compound ?compound ?object)
    (does agent (add-to-compound ?compound ?object))
    (object-coordinates ?compound ?cx1 ?cy1 ?cx2 ?cy2)
    (object-coordinates ?object ?ox1 ?oy1 ?ox2 ?oy2)
    (- ?cx1 ?ox1 ?test-x1)
    (> ?test-x1 0))
;; 1-2
(<= (if-gt0-then-else-x1 ?test-x1 ?ox1 ?cx1 ?cx1)
    ;;(can-add-to-compound ?compound ?object)
    (does agent (add-to-compound ?compound ?object))
    (object-coordinates ?compound ?cx1 ?cy1 ?cx2 ?cy2)
    (object-coordinates ?object ?ox1 ?oy1 ?ox2 ?oy2)
    (- ?cx1 ?ox1 ?test-x1)
    (>= 0 ?test-x1))

;; 2-1
(<= (if-gt0-then-else-x2 ?test-x2 ?cx2 ?ox2 ?cx2)
    ;;(can-add-to-compound ?compound ?object)
    (does agent (add-to-compound ?compound ?object))
    (object-coordinates ?compound ?cx1 ?cy1 ?cx2 ?cy2)
    (object-coordinates ?object ?ox1 ?oy1 ?ox2 ?oy2)
    (- ?cx2 ?ox2 ?test-x2)
    (> ?test-x2 0))
;; 2-2
(<= (if-gt0-then-else-x2 ?test-x2 ?cx2 ?ox2 ?ox2)
    ;;(can-add-to-compound ?compound ?object)
    (does agent (add-to-compound ?compound ?object))
    (object-coordinates ?compound ?cx1 ?cy1 ?cx2 ?cy2)
    (object-coordinates ?object ?ox1 ?oy1 ?ox2 ?oy2)
    (- ?cx2 ?ox2 ?test-x2)
    (>= 0 ?test-x2))
;; 3-1
(<= (if-gt0-then-else-y1 ?test-y1 ?oy1 ?cy1 ?oy1)
    ;;(can-add-to-compound ?compound ?object)
    (does agent (add-to-compound ?compound ?object))
    (object-coordinates ?compound ?cx1 ?cy1 ?cx2 ?cy2)
    (object-coordinates ?object ?ox1 ?oy1 ?ox2 ?oy2)
    (- ?cy1 ?oy1 ?test-y1)
    (> ?test-y1 0))
;; 3-2
(<= (if-gt0-then-else-y1 ?test-y1 ?oy1 ?cy1 ?cy1)
    ;;(can-add-to-compound ?compound ?object)
    (does agent (add-to-compound ?compound ?object))
    (object-coordinates ?compound ?cx1 ?cy1 ?cx2 ?cy2)
    (object-coordinates ?object ?ox1 ?oy1 ?ox2 ?oy2)
    (- ?cy1 ?oy1 ?test-y1)
    (>= 0 ?test-y1))

;; 4-1
(<= (if-gt0-then-else-y2 ?test-y2 ?cy2 ?oy2 ?cy2)
    ;;(can-add-to-compound ?compound ?object)
    (does agent (add-to-compound ?compound ?object))
    (object-coordinates ?compound ?cx1 ?cy1 ?cx2 ?cy2)
    (object-coordinates ?object ?ox1 ?oy1 ?ox2 ?oy2)
    (- ?cy2 ?oy2 ?test-y2)
    (> ?test-y2 0))
;;4-2
(<= (if-gt0-then-else-y2 ?test-y2 ?cy2 ?oy2 ?oy2)
    ;;(can-add-to-compound ?compound ?object)
    (does agent (add-to-compound ?compound ?object))
    (object-coordinates ?compound ?cx1 ?cy1 ?cx2 ?cy2)
    (object-coordinates ?object ?ox1 ?oy1 ?ox2 ?oy2)
    (- ?cy2 ?oy2 ?test-y2)
    (>= 0 ?test-y2))

    
;;; Determine if ?object is a member of any compound
(<= (is-member-of-any-compound ?object)
    (true (member ?compound ?object)))

;;; Determine if ?object is a member of ?compound.  Strictly speaking, this
;;; should be unnecessary, but GDL requires that any variable used as an 
;;; argument in a recursive predicate must also be used in a non-recursive
;;; predicate, where (true ...) does not satisfy the requirement. This 
;;; rule is used to satisfy that requirement.
(<= (is-member-of-compound ?compound ?object)
    (true (member ?compound ?object)))

;;; Determine if ?object is a nested member of ?compound. Cases:
;;; 1) ?object is a direct member of ?compound
;;; 2) ?object is a nested member of ?compound
(<= (is-recursive-member-of-compound ?compound ?object)
    (true (member ?compound ?object)))

(<= (is-recursive-member-of-compound ?compound ?object)
    (is-member-of-compound ?compound ?intermediate)
    (is-recursive-member-of-compound ?intermediate ?object))

;;; Determine if ?object1 and ?object2 form an L- or T-shaped joint. 
(<= (joint ?object1 ?object2)
    (L-joint ?object1 ?object2))

(<= (joint ?object1 ?object2)
    (T-joint ?object1 ?object2))

;;; L-joint case 1:
;;; * ?object1 has same left x-coordinate as ?object2
;;; * ?object1 has vertical orientation (height > width)
;;; * ?object2 has horizontal orientation (width > height) 
;;; * ?object1 is on ?object2
;;; * ?object2 is wider than ?object1
(<= (L-joint ?object1 ?object2)
    (aligned ?object1 ?object2 left)
    (object-orientation ?object1 vertical)
    (object-orientation ?object2 horizontal)
    (adjacent ?object1 ?object2 bottom)
    (wider ?object2 ?object1))

;;; L-joint case 2:
;;; * ?object1 has same right x-coordinate as ?object2
;;; * ?object1 has vertical orientation (height > width)
;;; * ?object2 has horizontal orientation (width > height) 
;;; * ?object1 is on ?object2
;;; * ?object2 is wider than ?object1
(<= (L-joint ?object1 ?object2)
    (aligned ?object1 ?object2 right)
    (object-orientation ?object1 vertical)
    (object-orientation ?object2 horizontal)
    (adjacent ?object1 ?object2 bottom)
    (wider ?object2 ?object1))

;;; L-joint case 3:
;;; * ?object1 has same left x-coordinate as ?object2
;;; * ?object1 has horizontal orientation (width > height) 
;;; * ?object2 has vertical orientation (height > width)
;;; * ?object1 is on ?object2
;;; * ?object1 is wider than ?object2
(<= (L-joint ?object1 ?object2)
    (aligned ?object1 ?object2 left)
    (object-orientation ?object1 horizontal)
    (object-orientation ?object2 vertical)
    (adjacent ?object1 ?object2 bottom)
    (wider ?object1 ?object2))

;;; L-joint case 4:
;;; * ?object1 has same right x-coordinate as ?object2
;;; * ?object1 has horizontal orientation (width > height) 
;;; * ?object2 has vertical orientation (height > width)
;;; * ?object1 is on ?object2
;;; * ?object2 is wider than ?object1
(<= (L-joint ?object1 ?object2)
    (aligned ?object1 ?object2 right)
    (object-orientation ?object1 horizontal)
    (object-orientation ?object2 vertical)
    (adjacent ?object1 ?object2 bottom)
    (wider ?object1 ?object2))

;;; T-joint case 1:
;;; * ?object2 left x-coordinate is greater than ?object1 left x-coordinate
;;; * ?object2 right x-coordinate is less than ?object1 right x-coordinate
;;; * ?object1 has horizontal orientation (width > height)
;;; * ?object2 has vertical orientation (height > width)
;;; * ?object1 is on ?object2
(<= (T-joint ?object1 ?object2)
    (object-coordinates ?object1 ?x11 ?y11 ?x12 ?y12)
    (object-coordinates ?object2 ?x21 ?y21 ?x22 ?y22)
    (> ?x21 ?x11)
    (> ?x12 ?x22)
    (object-orientation ?object1 horizontal)
    (object-orientation ?object2 vertical)
    (adjacent ?object1 ?object2 bottom))

;;; T-joint case 2:
;;; * ?object1 left x-coordinate is greater than ?object2 left x-coordinate
;;; * ?object1 right x-coordinate is less than ?object2 right x-coordinate
;;; * ?object1 has vertical orientation (height > width)
;;; * ?object2 has horizontal orientation (width > height)
;;; * ?object1 is on ?object2
(<= (T-joint ?object1 ?object2)
    (object-coordinates ?object1 ?x11 ?y11 ?x12 ?y12)
    (object-coordinates ?object2 ?x21 ?y21 ?x22 ?y22)
    (> ?x11 ?x21)
    (> ?x22 ?x12)
    (object-orientation ?object1 vertical)
    (object-orientation ?object2 horizontal)
    (adjacent ?object1 ?object2 bottom))

;;; Determine if there exists some primitive object adjacent to 
;;; ?object1's ?side that is further left than ?object2
(<= (left-further-adjacent-primitive ?object1 ?object2 ?side)
    (adjacent ?object1 ?other ?side)
    (true (object-location ?object2 ?obj2-x ?obj2-y))
    (true (object-location ?other ?other-x ?other-y))
    (> ?obj2-x ?other-x)
	(adjacent ?object1 ?object2 bottom)
	)

;;; Determine if there exists some object braced to ?object1 that is further
;;; left than ?object2
(<= (left-further-brace ?object1 ?object2)
    (braced-joint ?object1 ?other)
    (true (object-location ?object2 ?obj2-x ?obj2-y))
    (true (object-location ?other ?other-x ?other-y))
    (> ?obj2-x ?other-x))

;;; Determine if there exists some primitive object adjacent to 
;;; ?object1's ?side that is left of ?right and right of ?object2
(<= (left-further-adjacent-primitive-to-right ?object1 ?object2 ?right ?side)
    (adjacent ?object1 ?other ?side)
    (true (object-location ?object2 ?obj2-x ?obj2-y))
    (true (object-location ?right ?right-x ?right-y))
    (true (object-location ?other ?other-x ?other-y))
    (> ?other-x ?obj2-x)
    (> ?right-x ?other-x)
	(adjacent ?object1 ?object2 bottom)
	)

;;; Determine if there exists some object braced to ?object1 that is
;;; left of ?right and right of ?object2
(<= (left-further-brace-to-right ?object1 ?object2 ?right)
    (braced-joint ?object1 ?other)
    (true (object-location ?object2 ?obj2-x ?obj2-y))
    (true (object-location ?right ?right-x ?right-y))
    (true (object-location ?other ?other-x ?other-y))
    (> ?other-x ?obj2-x)
    (> ?right-x ?other-x))

;;; Determine if ?leftmost is the leftmost primitive adjacent to 
;;; ?object's ?side.
(<= (leftmost-adjacent-primitive ?object ?leftmost ?side)
    (adjacent ?object ?leftmost ?side)
    (primitive-object ?leftmost)
    (not (left-further-adjacent-primitive ?object ?leftmost ?side)))

;;; Determine if ?leftmost is adjacent to ?object1's ?side and is
;;; the leftmost object to the right of ?object2.
(<= (leftmost-adjacent-primitive-to-right ?object1 ?object2 ?leftmost ?side)
    (adjacent ?object1 ?object2 ?side)
    (adjacent ?object1 ?leftmost ?side)
    (primitive-object ?leftmost)
    (true (object-location ?object2 ?obj2-x ?obj2-y))
    (true (object-location ?leftmost ?left-x ?left-y))
    (> ?left-x ?obj2-x)
    (not (left-further-adjacent-primitive-to-right ?object1 ?object2
						   ?leftmost ?side)))

;;; Determine if ?leftmost is the leftmost object to which ?object is braced
(<= (leftmost-brace ?object ?leftmost)
    (braced-joint ?object ?leftmost)
    (not (left-further-brace ?object ?leftmost)))

;;; Determine if ?leftmost is braced to ?object1 and is the leftmost 
;;; braced object to the right of ?object2
(<= (leftmost-brace-to-right ?object1 ?object2 ?leftmost)
    (braced-joint ?object1 ?object2)
    (braced-joint ?object1 ?leftmost)
    (true (object-location ?object2 ?obj2-x ?obj2-y))
    (true (object-location ?leftmost ?left-x ?left-y))
    (> ?left-x ?obj2-x)
    (not (left-further-brace-to-right ?object1 ?object2 ?leftmost)))


;;; Determine if ?material is a type of brace.
(<= (material-is-brace-type ?material)
    (brace-type ?material ?braceable-material ?strength ?weight))

;;; Determine if ?material is braceable
(<= (material-is-braceable ?material)
    (brace-type ?brace-type ?material ?strength ?weight))

;;; Determine if ?material is a type of reinforcement
(<= (material-is-reinforcement-type ?material)
    (reinforcement-type ?material ?reinforceable-material ?strength ?weight))

;;; Determine whether any two members of ?compound have differing widths
(<= (members-have-different-x-coordinate ?compound)
    (true (member ?compound ?member1))
    (true (object-size ?member1 ?width1 ?height1 ?weight1))
    (true (member ?compound ?member2))
    (true (object-size ?member2 ?width2 ?height2 ?weight2))
    (distinct ?width1 ?width2))

;;; Determine whether any two members of ?compound have differing x-coordinates.
(<= (members-have-different-width ?compound)
    (true (member ?compound ?member1))
    (true (object-location ?member1 ?x1 ?y1))
    (true (member ?compound ?member2))
    (true (object-location ?member2 ?x2 ?y2))
    (distinct ?x1 ?x2))

;;; Determine if an object is movable (weight < WMAX).
(<= (movable ?object)
    (true (object-size ?object ?width ?height ?weight))
    (max-movable-weight ?max)
    (> ?max ?weight))

;;; Determine if ?var is numeric.
;;(<= (number ?var)
;;    (+ ?var 0 ?var))

;;; Determine the location of the lower-left and upper-right corners of ?object
(<= (object-coordinates ?object ?x1 ?y1 ?x2 ?y2)
    (true (object-location ?object ?x1 ?y1))
    (true (object-size ?object ?width ?height ?weight))
    (+ ?x1 ?width ?x2)
    (+ ?y1 ?height ?y2))

;;; Compute whether ?object intersects the region (?x11 ?y11 ?x12 ?y12).
;;; Cases:
;;; 1) ?object is primitive
;;; 2) ?object is compound
;;(<= (object-intersects-region ?object ?x11 ?y11 ?x12 ?y12)
;;    (primitive-object ?object)
;;    (object-coordinates ?object ?x21 ?y21 ?x22 ?y22)
;;    (> ?x22 ?x11)
;;    (> ?x12 ?x21)
;;    (> ?y22 ?y11)
;;    (> ?y12 ?y21))

;;(<= (object-intersects-region ?object ?x11 ?y11 ?x12 ?y12)
;;    (true (object ?object compound))
;;    (is-member-of-compound ?object ?member)
;;    (object-intersects-region ?member ?x11 ?y11 ?x12 ?y12))

(<= (object-intersects-region ?object ?x11 ?y11 ?x12 ?y12)
    (primitive-object ?object)
    (soar-hack-regions-to-check-for-intersection ?x11 ?y11 ?x12 ?y12)
    (object-coordinates ?object ?x21 ?y21 ?x22 ?y22)
    (> ?x22 ?x11)
    (> ?x12 ?x21)
    (> ?y22 ?y11)
    (> ?y12 ?y21))

;; manual mod, don't need this at all!
;;(<= (object-intersects-region ?object ?x11 ?y11 ?x12 ?y12)
;;    (true (object ?object compound))
;;    (soar-hack-regions-to-check-for-intersection ?x11 ?y11 ?x12 ?y12)
;;    (is-member-of-compound ?object ?member)
;;    (object-intersects-region ?member ?x11 ?y11 ?x12 ?y12))


;; restricted condition for object-intersects-region
(<= (soar-hack-regions-to-check-for-intersection ?x1 ?y1 ?x2 ?y2)
    (coordinates-after-place ?object1 ?object2 ?side ?x1 ?y1 ?x2 ?y2))

;; restricted condition for object-intersects-region
(<= (soar-hack-regions-to-check-for-intersection ?x1 ?y1 ?x2 ?y2)
    (coordinates-after-nudge ?object ?side ?x1 ?y1 ?x2 ?y2)
	;; there are recursive nudge, only need to check for the outermost compound
	(not (is-member-of-compound ?anycompound ?object2))
	)

;; restricted condition for object-intersects-region
(<= (soar-hack-regions-to-check-for-intersection ?x1 ?y1 ?x2 ?y2)
    (coordinates-after-rotate ?object ?x1 ?y1 ?x2 ?y2))

;; The above are manually added restricted conditions for object-intersects-region with bound variables.
;; they may be duplicate, and causes exploding trouble!

;;; Determine the orientation of ?object
(<= (object-orientation ?object horizontal)
    (true (object-size ?object ?width ?height ?weight))
    (> ?width ?height))

(<= (object-orientation ?object vertical)
    (true (object-size ?object ?width ?height ?weight))
    (> ?height ?width))

;;; Determine if some member of ?compound, other than ?top, has the same
;;; upper y-coordinate as ?compound
(<= (other-member-at-top ?compound ?top)
    (object-coordinates ?compound ?cx1 ?cy1 ?cx2 ?y2)
    (true (member ?compound ?top))
    (true (member ?compound ?other))
    (distinct ?top ?other)
    (object-coordinates ?other ?ox1 ?oy1 ?ox2 ?y2))

;;; Deterime whether ?object is a primitive
(<= (primitive-object ?object)
    (true (object ?object ?type))
    (material-type ?type ?strength))

;;; Determine if the members of ?compound form a pyramid. Requirements:
;;; 1) exactly one member at top of compound
;;; 2) height of compound at least double height of a member
;;; 3) member at top must meet conditions of (pryamid-recursive ...)
(<= (pryamid ?compound)
    (object-coordinates ?compound ?cx1 ?cy1 ?cx2 ?y2)
    (true (member ?compound ?top))
    (object-coordinates ?top ?tx1 ?ty1 ?tx2 ?y2)
    (not (other-member-at-top ?compound ?top))
    (true (object-size ?compound ?c-width ?c-height ?c-weight))
    (true (object-size ?top ?t-width ?t-height ?t-weight))
    (* ?t-height 2 ?min-height)
    (>= ?c-height ?min-height)
    (pyramid-recursive ?compound ?top))

;;; Determine if ?top is part of a pyramid formed by ?compound. 
;;; Base case requirements:
;;; 1) The bottom of ?top has the same y-coordinate as the bottom of ?compound
;;; Recursive case requirements:
;;; 1) ?top has exactly two supports
;;; 2) both supports are members of ?compoumd
;;; 3) the supports are adjacent to each other
;;; 4) both supports have the same width and height as ?top
;;; 5) both supports meet the conditions of (pyramid-recursive ...)
(<= (pyramid-recursive ?compound ?top)
    (true (object-location ?compound ?cx ?y))
    (true (object-location ?top ?tx ?y)))

(<= (pryamid-recursive ?compound ?top)
    (adjacent-primitive-count ?top bottom 2)
    (true (member ?compound ?support1))
    (adjacent ?top ?support1 bottom)
    (true (member ?compound ?support2))
    (adjacent ?top ?support2 bottom)
    (adjacent ?support1 ?support2 ?side)
    (true (object-size ?top ?width ?height ?t-weight))
    (true (object-size ?support1 ?width ?height ?s1-weight))
    (true (object-size ?support2 ?width ?height ?s2-weight))
    (pyramid-recursive ?compound ?support1)
    (pyramid-recursive ?compound ?support2))

;;; Determine if any object ?intersecting intersects the given 
;;; rectangular region. ?intersecting must be different from ?object
(<= (region-intersected-by-object ?object ?x11 ?y11 ?x12 ?y12 ?intersecting)
    (true (object ?object ?type))
    (object-intersects-region ?intersecting ?x11 ?y11 ?x12 ?y12)
    (distinct ?object ?intersecting)
	(not (is-recursive-member-of-compound ?object ?intersecting))
	;; manual mode
	;; object is the intended moving object, so ...
	(clear ?object top)
	;;(not (is-member-of-any-compound ?object))
	(not (true (member ?anycompound ?object)))
	(distinct ?type ground)
	)

;;; Determine if ?object is a primitive that has been reinforced.
(<= (reinforced-object ?object)
    (true (reinforced ?object ?reinforcement)))

;;; Determine if ?object1 and ?object2 are in the same compound
(<= (same-compound ?compound ?object1 ?object2)
    (true (member ?compound ?object1))
    (true (member ?compound ?object2))
    ;; manual mod
    (distinct ?objec1 ?object2)
    )

;;; Determine if ?object1 and ?object2 are of same primitive material
(<= (same-primitive-material ?material ?object1 ?object2)
    (true (object ?object1 ?material))
    (true (object ?object2 ?material))
    (distinct ?material compound)
    ;; manual mod
    (distinct ?object1 ?object2)
    )

;;; Computes the value of ?strength for primitive ?object. Cases:
;;; 1) ?object is not reinforced (0 or more braces)
;;; 2) ?object is reinforced (0 braces)
;;(<= (strength ?object ?strength)
;;    (true (object ?object ?type))
;;    (true (object-size ?object ?width ?height ?weight))
;;    (not (reinforced-object ?object))
;;    (material-type ?type ?material-strength)
;;    (* ?width ?material-strength ?obj-strength)
;;    (brace-strength-factor ?object ?brace-factor)
;;    (* ?obj-strength ?brace-factor ?strength))

(<= (strength ?object ?strength)
    (true (object ?object ?obj-type))
    (true (object-size ?object ?width ?height ?weight))
    (true (reinforced ?object ?reinforcement-type))
    (material-type ?obj-type ?material-strength)
    (reinforcement-type ?reinforcement-type ?obj-type ?r-strength ?r-weight)
    (* ?width ?material-strength ?obj-strength)
    (* ?obj-strength ?r-strength ?strength))

;;; Determine if ?support will touch ?object's ?side when ?object is nudged
(<= (support-for-nudge ?object ?support left)
    (object-coordinates ?object ?old-x1 ?y1 ?old-x2 ?y2)
    (object-coordinates ?support ?sx1 ?sy1 ?sx2 ?y1)
    (- ?old-x1 1 ?new-x1)
    (- ?old-x2 1 ?new-x2)
    (> ?new-x2 ?sx1)
    (> ?sx2 ?new-x1)
    ;; manual mod
    (movable ?object)
    (clear ?object top)
    ;;(not (is-member-of-any-compound ?object))
	(not (true (member ?anycompound ?object)))
    )

(<= (support-for-nudge ?object ?support right)
    (object-coordinates ?object ?old-x1 ?y1 ?old-x2 ?y2)
    (object-coordinates ?support ?sx1 ?sy1 ?sx2 ?y1)
    (+ ?old-x1 1 ?new-x1)
    (+ ?old-x2 1 ?new-x2)
    (> ?new-x2 ?sx1)
    (> ?sx2 ?new-x1)
    ;; manual mod
    (movable ?object)
    (clear ?object top)
    ;;(not (is-member-of-any-compound ?object))
	(not (true (member ?anycompound ?object)))
    )

;;; Determine if ?object2 will touch ?object1's ?side when placed on ?support.
(<= (support-for-place ?object1 ?object2 ?support left)
    (true (object-size ?object2 ?width2 ?height2 ?weight2))
    (object-coordinates ?object1 ?x1 ?y1 ?x2 ?y2)
    (object-coordinates ?support ?sx1 ?sy1 ?sx2 ?sy2)
    (- ?x1 ?width2 ?minx)
    (- ?y1 ?height2 ?miny)
    (> ?x1 ?sx1)
    (> ?sx2 ?minx)
    (> ?sy2 ?miny)
    (> ?y2 ?sy2)
	;; manual mod
    (movable ?object2)
    (clear ?object2 top)
	(not (true (member ?anycompound ?object2)))
	(not (is-recursive-member-of-compound ?object2 ?object1))
    (distinct ?object1 ?object2)
    (distinct ?object1 ?support)
    (distinct ?object2 ?support)
	
	;; manual mod - avoid duplicate supports
	(not (same-support-to-right ?object1 ?object2 ?support left))
	;;(distinct ?support c1)
	)

(<= (support-for-place ?object1 ?object2 ?support right)
    (true (object-size ?object2 ?width2 ?height2 ?weight2))
    (object-coordinates ?object1 ?x1 ?y1 ?x2 ?y2)
    (object-coordinates ?support ?sx1 ?sy1 ?sx2 ?sy2)
    (+ ?x2 ?width2 ?maxx)
    (- ?y1 ?height2 ?miny)
    (> ?maxx ?sx1)
    (> ?sx2 ?x2)
    (> ?sy2 ?miny)
    (> ?y2 ?sy2)
	;; manual mod
    (movable ?object2)
    (clear ?object2 top)
	(not (true (member ?anycompound ?object2)))
	(not (is-recursive-member-of-compound ?object2 ?object1))
    (distinct ?object1 ?object2)
    (distinct ?object1 ?support)
    (distinct ?object2 ?support)
	
	;; manual mod - avoid duplicate supports
	(not (same-support-to-right ?object1 ?object2 ?support right))
	;;(distinct ?support c3)
	
	)

;; manual mod
;;;; the following 3 rules are important to make soar run
;; leftmost support for the same height - avoid duplicate, which may explode elaboration
;; Soar duplicate structure causes trouble in this case
(<= (redundant-support-for-place ?object1 ?object2 ?support left)
    (true (object-size ?object2 ?width2 ?height2 ?weight2))
    (object-coordinates ?object1 ?x1 ?y1 ?x2 ?y2)
    (object-coordinates ?support ?sx1 ?sy1 ?sx2 ?sy2)
    (- ?x1 ?width2 ?minx)
    (- ?y1 ?height2 ?miny)
    (> ?x1 ?sx1)
    (> ?sx2 ?minx)
    (> ?sy2 ?miny)
    (> ?y2 ?sy2)
	;; manual mod
    (movable ?object2)
    (clear ?object2 top)
	(not (true (member ?anycompound ?object2)))
	(not (is-recursive-member-of-compound ?object2 ?object1))
    (distinct ?object1 ?object2)
    (distinct ?object1 ?support)
    (distinct ?object2 ?support)
	)

(<= (redundant-support-for-place ?object1 ?object2 ?support right)
    (true (object-size ?object2 ?width2 ?height2 ?weight2))
    (object-coordinates ?object1 ?x1 ?y1 ?x2 ?y2)
    (object-coordinates ?support ?sx1 ?sy1 ?sx2 ?sy2)
    (+ ?x2 ?width2 ?maxx)
    (- ?y1 ?height2 ?miny)
    (> ?maxx ?sx1)
    (> ?sx2 ?x2)
    (> ?sy2 ?miny)
    (> ?y2 ?sy2)
	;; manual mod
    (movable ?object2)
    (clear ?object2 top)
	(not (true (member ?anycompound ?object2)))
	(not (is-recursive-member-of-compound ?object2 ?object1))
    (distinct ?object1 ?object2)
    (distinct ?object1 ?support)
    (distinct ?object2 ?support)
	)

(<= (same-support-to-right ?object1 ?object2 ?support ?side) ;; side = left/right
	(redundant-support-for-place ?object1 ?object2 ?support ?side)
	(redundant-support-for-place ?object1 ?object2 ?another-support ?side)
	(distinct ?support ?another-support)
	(object-coordinates ?support ?sx1 ?sy1 ?sx2 ?sy2)
	(object-coordinates ?another-support ?asx1 ?asy1 ?asx2 ?sy2)
	(< ?sx1 ?asx1)
)
;;;; the above 3 rules are important to make soar run

;;; Calculate the amount of weight supported by ?object
(<= (supported-weight ?object ?weight)
    (leftmost-adjacent-primitive ?object ?leftmost top)
    (supported-weight-recursive ?object ?leftmost ?weight))

(<= (supported-weight ?object 0)
    (clear ?object top))

;;; Calculate the amount of weight supported by ?object from objects
;;; to the right of ?left (including ?left)
(<= (supported-weight-recursive ?object ?left ?weight)
    (leftmost-adjacent-primitive-to-right ?object ?left ?next top)
    (supported-weight-recursive ?object ?next ?wt)
    (weight-contribution ?left ?left-wt)
    (+ ?wt ?left-wt ?weight))

(<= (supported-weight-recursive ?object ?left ?weight)
    (primitive-object ?object)
    (primitive-object ?left)
    (not (adjacent-primitive-to-right ?object ?left top))
    (weight-contribution ?left ?weight))

;;; Determine if ?object1 is taller than ?object2
(<= (taller ?object1 ?object2)
    (true (object-size ?object1 ?width1 ?height1 ?weight1))
    (true (object-size ?object2 ?width2 ?height2 ?weight2))
    (> ?height1 ?height2))

;;; Determine whether ?object is unsupported (nothing below it). This
;;; ignores objects of type GROUND, which are usually not supported.
(<= (unsupported ?object)
    (true (object ?object ?type))
    (distinct ?type ground)
    ;;(not (adjacent-to-any-object ?object bottom)))
	(not (adjacent ?object ?anyobject bottom)))

;;; Calculate the amount of weight that ?object contributes to each 
;;; object below it
(<= (weight-contribution ?object ?weight)
    (weight-of-stack ?object ?stack-wt)
    (adjacent-primitive-count ?object bottom ?number)
    (/ ?stack-wt ?number ?temp)
    (round ?temp ?weight))

;;; Calculate the total weight that ?object exerts collectively 
;;; on the objects below it
(<= (weight-of-stack ?object ?weight)
    (true (object-size ?object ?obj-wid ?obj-ht ?obj-wt))
    (supported-weight ?object ?supported-wt)
    (+ ?obj-wt ?supported-wt ?weight))

;;; Determine if ?object1 is wider than ?object2
(<= (wider ?object1 ?object2)
    (true (object-size ?object1 ?width1 ?height1 ?weight1))
    (true (object-size ?object2 ?width2 ?height2 ?weight2))
    (> ?width1 ?width2)
    ;; manual mod
    (adjacent ?object1 ?object2 ?side)
    (distinct ?side left)
    (distinct ?side right)

    )

;;; ---------------------------------------------------------------------------
;;; LEGAL AXIOMS

;;; Add ?object to ?compound.
(<= (legal agent (add-to-compound ?compound ?object))
    (can-add-to-compound ?compound ?object))

;;; Brace joint between ?object1 and ?object2 with ?brace-type.
(<= (legal agent (brace ?object1 ?object2 ?brace-type))
    (can-brace ?object1 ?object2 ?brace-type))

;;; Make a new compound object with ?object.
(<= (legal agent (make-new-compound ?object))
    (can-make-new-compound ?object))

;;; Move ?object one cell in the specified direnction
(<= (legal agent (nudge ?object ?side))
    (can-nudge ?object ?side))

;;; Move ?object2 adjacent to (touching) ?object1's ?side.
(<= (legal agent (place-adjacent ?object1 ?object2 ?side))
    (can-place-adjacent ?object1 ?object2 ?side))

;;; Reinforce ?object with ?reinforcement-type
(<= (legal agent (reinforce ?object ?reinforcement-type))
    (can-reinforce ?object ?reinforcement-type))

;;; Rotate a primitive object.
(<= (legal agent (rotate ?object))
    (can-rotate ?object))


;;; ---------------------------------------------------------------------------
;;; NEXT AXIOMS

;;; Add object to existing compound: 
;;; 1) Declare object membership in compound
;;; 2) Update compound location
;;; 3) Update compound size
(<= (next (member ?compound ?object))
    (does agent (add-to-compound ?compound ?object)))

(<= (next (object-location ?compound ?x ?y))
    (does agent (add-to-compound ?compound ?object))
    (coordinates-after-add ?compound ?object ?x ?y ?x2 ?y2))


(<= (next (object-size ?compound ?width ?height ?weight))
    (does agent (add-to-compound ?compound ?object))
    (dimensions-after-add ?compound ?object ?width ?height)
    (true (object-size ?compound ?old-width ?old-height ?old-weight))
    (true (object-size ?object ?obj-width ?obj-height ?obj-weight))
    (+ ?old-weight ?obj-weight ?weight))

(<= (dimensions-after-add ?compound ?object ?width ?height)
    (does agent (add-to-compound ?compound ?object))
    (coordinates-after-add ?compound ?object ?x1 ?y1 ?x2 ?y2)
    (- ?x2 ?x1 ?width)
    (- ?y2 ?y1 ?height))

;;; Brace the joint between two objects:
;;; 1) Declare the brace
;;; 2) Update compound weight for every compound of which both objects 
;;;    are a recursive member.
;;; 3) Update the primitive weight for ?object1 by 1/2 of brace weight
;;; 4) Update the primitive weight for ?object1 by 1/2 of brace weight
;;; 5) Reduce count of ?brace-type by one
(<= (next (braced ?object1 ?object2 ?brace-type))
    (does agent (brace ?object1 ?object2 ?brace-type)))

(<= (next (object-size ?compound ?width ?height ?weight))
    (does agent (brace ?object1 ?object2 ?brace-type))
    (is-recursive-member-of-compound ?compound ?object1)
    (is-recursive-member-of-compound ?compound ?object2)
    (true (object-size ?compound ?width ?height ?c-weight))
    (true (object ?object1 ?obj-type))
    (brace-type ?brace-type ?obj-type ?b-strength ?b-weight)
    (+ ?c-weight ?b-weight ?weight))

(<= (next (object-size ?object1 ?width ?height ?weight))
    (does agent (brace ?object1 ?object2 ?brace-type))
    (true (object ?object1 ?obj-type))
    (true (object-size ?object1 ?width ?height ?obj-weight))
    (brace-type ?brace-type ?obj-type ?b-strength ?b-weight)
    (/ ?b-weight 2 ?half-bwt)
    (+ ?obj-weight ?half-bwt ?weight))

(<= (next (object-size ?object2 ?width ?height ?weight))
    (does agent (brace ?object1 ?object2 ?brace-type))
    (true (object ?object2 ?obj-type))
    (true (object-size ?object2 ?width ?height ?obj-weight))
    (brace-type ?brace-type ?obj-type ?b-strength ?b-weight)
    (/ ?b-weight 2 ?half-bwt)
    (+ ?obj-weight ?half-bwt ?weight))

(<= (next (count ?brace-type ?new-count))
    (does agent (brace ?object1 ?object2 ?brace-type))
    (true (count ?brace-type ?old-count))
    (- ?old-count 1 ?new-count))

;;; Make a new compound object: 5 steps.
;;; 1) Declare the compound
;;; 2) Declare object membership in compound
;;; 3) Initialize compound location
;;; 4) Initialize compound size
;;; 5) Update current-identifier
(<= (next (object ?identifier compound))
    (does agent (make-new-compound ?object))
    (true (current-identifier ?identifier)))

(<= (next (member ?identifier ?object))
    (does agent (make-new-compound ?object))
    (true (current-identifier ?identifier)))

(<= (next (object-location ?identifier ?x ?y))
    (does agent (make-new-compound ?object))
    (true (object-location ?object ?x ?y))
    (true (current-identifier ?identifier)))

(<= (next (object-size ?identifier ?width ?height ?weight))
    (does agent (make-new-compound ?object))
    (true (object-size ?object ?width ?height ?weight))
    (true (current-identifier ?identifier)))

(<= (next (current-identifier ?id))
    (does agent (make-new-compound ?object))
    (true (current-identifier ?old-id))
    (next-identifier ?old-id ?id))

;;; Move an object one cell in a given direction.
;;; 1) Update the location of the nudged object (primitive or compound)
;;; 2) If object is compound, then update all nested members
(<= (next (object-location ?object ?x ?y))
    (does agent (nudge ?object ?side))
    (coordinates-after-nudge ?object ?side ?x ?y ?x2 ?y2))

(<= (next (object-location ?object ?x ?y))
    (does agent (nudge ?compound ?side))
    (true (object ?compound compound))
    (is-recursive-member-of-compound ?compound ?object)
    (coordinates-after-nudge ?object ?side ?x ?y ?x2 ?y2))

;;; Move one object adjacent to another on a specified side:
;;; 1) Update the location of moved object (primitive or compound)
;;; 2) If object is compound, then update all nested members
(<= (next (object-location ?object2 ?x ?y))
    (does agent (place-adjacent ?object1 ?object2 ?side))
    (coordinates-after-place ?object1 ?object2 ?side ?x ?y ?x2 ?y2)
    (not (region-intersected-by-object ?object2 ?x ?y ?x2 ?y2)))


(<= (next (object-location ?member ?x ?y))
    (does agent (place-adjacent ?object1 ?object2 ?side))
    (true (object ?object2 compound))
    (distance-object-moved ?object2 ?dist-x ?dist-y)
    (is-recursive-member-of-compound ?object2 ?member)
    (true (object-location ?member ?old-x ?old-y))
    (+ ?old-x ?dist-x ?x)
    (+ ?old-y ?dist-y ?y))

(<= (distance-object-moved ?object ?x-dist ?y-dist)
    (does agent (place-adjacent ?target ?object ?side))
    (true (object-location ?object ?old-x ?old-y))
    (coordinates-after-place ?target ?object ?side ?new-x ?new-y ?x2 ?y2)
    (not (region-intersected-by-object ?object ?new-x ?new-y ?x2 ?y2))
    (- ?new-x ?old-x ?x-dist)
    (- ?new-y ?old-y ?y-dist))    


;;; Reinforce primitive ?object with ?material: 
;;; 1) Declare reinforcement
;;; 2) Update object size (weight) of primitive ?object
;;; 3) Update object size (weight) of all compounds of which ?object 
;;;    is a recursive member.
;;; 4) Reduce count of ?reinforcement-type by one
(<= (next (reinforced ?object ?reinforcement-type))
    (does agent (reinforce ?object ?reinforcement-type)))

(<= (next (object-size ?object ?width ?height ?weight))
    (does agent (reinforce ?object ?reinforcement-type))
    (true (object ?object ?obj-type))
    (true (object-size ?object ?width ?height ?obj-weight))
    (reinforcement-type ?reinforcement-type ?obj-type ?r-strength ?r-weight)
    (+ ?obj-weight ?r-weight ?weight))

(<= (next (object-size ?compound ?width ?height ?weight))
    (does agent (reinforce ?object ?reinforcement-type))
    (true (object ?object ?obj-type))
    (true (object-size ?compound ?width ?height ?comp-weight))
    (is-recursive-member-of-compound ?compound ?object)
    (reinforcement-type ?reinforcement-type ?obj-type ?r-strength ?r-weight)
    (+ ?comp-weight ?r-weight ?weight))

(<= (next (count ?reinforcement-type ?new-count))
    (does agent (reinforce ?object ?reinforcement-type))
    (true (count ?reinforcement-type ?old-count))
    (- ?old-count 1 ?new-count))

;;; Rotate a primitive object (switches width and height)
(<= (next (object-size ?object ?height ?width ?weight))
    (does agent (rotate ?object))
    (true (object-size ?object ?width ?height ?weight)))

;;; Advance time one step
(<= (next (time ?t))
    (true (time ?oldt))
    (+ ?oldt 1 ?t))


;;; ---------------------------------------------------------------------------
;;; FRAME AXIOMS (NEXT)

;;; Carry all brace declarations into next state
(<= (next (braced ?object1 ?object2 ?material))
    (true (braced ?object1 ?object2 ?material)))

;;; Carry the brace count forward if the given brace-type was not used.
(<= (next (count ?brace-type ?count))
    (true (count ?brace-type ?count))
    (brace-type ?brace-type ?obj-type ?brace-strength ?brace-weight)
    (not (action-brace agent ?brace-type)))

;;; Carry the reinforcement count forward if the given reinforcement-type
;;; was not used.
(<= (next (count ?reinforcement-type ?count))
    (true (count ?reinforcement-type ?count))
    (reinforcement-type ?reinforcement-type ?obj-type ?r-strength ?r-weight)
    (not (action-reinforce agent ?reinforcement-type)))

;;; Carry current identifier into next state if the agent does not
;;; make a new compound in the current time step
(<= (next (current-identifier ?id))
    (true (current-identifier ?id))
    (not (action-make-new-compound agent)))

;;; Carry all membership declarations into next state
(<= (next (member ?compound ?object))
    (true (member ?compound ?object)))

;;; All object declarations always get carried into the next state.
(<= (next (object ?object ?type))
    (true (object ?object ?type)))

;;; Most (object-location ...) declarations get carried into the next state,
;;; but some get modified.  Cases:
;;; 1) ?object is compound, nothing was added, and was not moved directly 
;;;    or indirectly (via larger compound)
;;; 2) ?object is primitive, and was not moved directly or indirectly 
;;;    (via compound)
(<= (next (object-location ?object ?x ?y))
    (true (object ?object compound))
    (true (object-location ?object ?x ?y))
    (not (action-add-to-compound agent ?object))
    (not (action-nudge agent ?object))
    (not (action-place-adjacent agent ?object)))

(<= (next (object-location ?object ?x ?y))
    (true (object ?object ?type))
    (true (object-location ?object ?x ?y))
    (material-type ?type ?strength)
    (not (action-nudge agent ?object))
    (not (action-place-adjacent agent ?object)))

;;; Most (object-size ...) declarations get carried into the next state,
;;; but some get modified.  Cases:
;;; 1) ?object is compound, has no subcomponent that was braced or reinforced,
;;;    and no new object was added
;;; 2) ?object is primitive, was not braced or reinforced, and was not rotated
(<= (next (object-size ?object ?width ?height ?weight))
    (true (object ?object compound))
    (true (object-size ?object ?width ?height ?weight))
    (not (action-add-to-compound agent ?object))
    (not (action-brace agent ?object))
    (not (action-reinforce agent ?object)))

(<= (next (object-size ?object ?width ?height ?weight))
    (true (object ?object ?type))
    (true (object-size ?object ?width ?height ?weight))
    (distinct ?type compound)
    (not (material-is-brace-type ?type))
    (not (material-is-reinforcement-type ?type))
    (not (action-brace agent ?object))
    (not (action-reinforce agent ?object))
    (not (action-rotate agent ?object)))

;;; Carry all reinforcement declarations into next state
(<= (next (reinforced ?object ?material))
    (true (reinforced ?object ?material)))
