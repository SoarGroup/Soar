;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Wargame Template
;;;  - Uses built-in math functions
;;;  - Functionally identical to mm-r03-composition-1-target.kif
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ROLE Relations
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(role soldier)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; INIT Relations
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Specifies where objects start on board, where lower left is (1,1).

(init (location    soldier 2 2))
(init (location terrorist1 7 7))
(init (location terrorist2 3 6))
(init (location       gun1 7 3))
(init (location       gun2 3 1))
(init (location    grenade 7 2))
(init (location       flag 8 8))

;;; Specifies how many hit-points a character starts the game with.

(init (health    soldier 1))
(init (health terrorist1 1))
(init (health terrorist2 2))

;;; blocked[North,East] implies there is a wall to the [North,East] of a cell.

(init (blockedNorth 2 7))
(init (blockedNorth 5 7))
(init (blockedNorth 6 7))
(init (blockedNorth 7 6))
(init (blockedNorth 2 5))
(init (blockedNorth 3 5))
(init (blockedNorth 4 5))
(init (blockedNorth 8 5))
(init (blockedNorth 2 2))
(init (blockedNorth 3 2))
(init (blockedNorth 3 2))
(init (blockedNorth 6 2))
(init (blockedNorth 7 2))
(init (blockedNorth 8 2))

(init (blockedEast 1 7))
(init (blockedEast 6 7))
(init (blockedEast 7 6))
(init (blockedEast 1 5))
(init (blockedEast 1 4))
(init (blockedEast 1 3))
(init (blockedEast 3 1))

;;; The global time clock.	
	
(init (time 1))
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; LEGAL Relations
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; It is always legal for the soldier to stand still.

(<= (legal soldier noop))

;;; The soldier may step in any of the cardinal directions so long as a wall 
;;;  does not block the way.

(<= (legal soldier (step ?dir))
    (true (location soldier ?x ?y))
    (not (stepBlocked ?dir ?x ?y))
    (nSteps 1 ?dir ?x ?y ?xAny ?yAny))

;;; The soldier may heal himself if he is holding a healing type item.

(<= (legal soldier heal)
    (true (holding soldier ?item))
    (type ?item healingItem))

;;; The soldier may shoot in any of the cardinal directions if he is holding
;;;  a line-of-sight type weapon.

(<= (legal soldier (shoot ?dir))
    (true (holding soldier ?item))
    (type ?item losItem)
    (direction ?dir))

;;; The soldier may throw in any of the cardinal directions if he is holding
;;;  a area-of-effect type item.

(<= (legal soldier (throw ?dir ?dist))
    (true (holding soldier ?item))
    (type ?item aoeItem)
    (legalThrowDist ?dist)
    (true (location soldier ?x ?y))
    (nSteps ?dist ?dir ?x ?y ?xAny ?yAny))
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; NEXT Relations
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; blocked[North,East] is persistent. It is a fluent only for the sake of 
;;;  showing up as XML when a stylesheet is used.

(<= (next (blockedNorth ?x ?y))
    (true (blockedNorth ?x ?y)))
(<= (next (blockedEast  ?x ?y))
    (true (blockedEast  ?x ?y)))

;;; Also here for stylesheet convenience.  True of any cell that the soldier
;;;  attacks.

(<= (next (blastZone ?x ?y))
    (attacks ?x ?y soldier))
	
;;; Location for animate-type objects is updated by the intendedLocation axiom.
	
(<= (next (location ?character ?x ?y))
    (type ?character animate)
    (intendedLocation ?character ?x ?y))

;;; Item-type objects remain where they are until the soldier walks on top of
;;;  them.

(<= (next (location ?object ?xO ?yO))
    (type ?object item)
    (true (location ?object ?xO ?yO))
    (intendedLocation soldier ?xE ?yE)
    (distinctCell ?xE ?yE ?xO ?yO))

;;; Should the soldier walk on top of an item-type object, it will move into his
;;;  inventory where it will remain until it is used.

(<= (next (holding soldier ?object))
    (type ?object item)
    (true (location ?object ?xO ?yO))
    (intendedLocation soldier ?xE ?yE)
    (not (distinctCell ?xE ?yE ?xO ?yO)))
(<= (next (holding soldier ?item))
    (true (holding soldier ?item))
    (not (uses soldier ?item)))

;;; Character health is modified based on how much it is 
;;;  [incremented,decremented] per step.

(<= (next (health ?character ?h2))
    (true (health ?character ?h1))
    (healthIncrement ?character ?hInc)
    (healthDecrement ?character ?hDec)
    (- ?hInc ?hDec ?deltaH)
    (+ ?h1 ?deltaH ?h2))
	
;;; Time ticks one second per step.	
	
(<= (next (time ?tNext))
    (true (time ?tCurrent))
    (+ ?tCurrent 1 ?tNext))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; TERMINAL Relations
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; The game is over if time runs out, the soldier has his health reduced to
;;;  zero, or places the flag in his inventory.

(<= terminal
    timeOut)
(<= terminal
    (dead soldier))
(<= terminal
    (true (holding soldier flag)))
 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; GOAL Relations
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Goals are computed according to the following table:
;;;
;;; Dead? TimeOut? HasFlag? Goal
;;; ----------------------------
;;;    0        0        0     0   
;;;    0        0        1   100
;;;    0        1        0    50 
;;;    0        1        1   100
;;;    1        0        0     0
;;;    1        0        1     0
;;;    1        1        0     0
;;;    1        1        1     0

(<= (goal soldier 0)
    (dead soldier))
(<= (goal soldier 0)
    (not timeOut)
    (not (dead soldier))
    (not (true (holding soldier flag))))

(<= (goal soldier 50)
    timeOut
    (not (dead soldier))
    (not (true (holding soldier flag))))

(<= (goal soldier 100)
    (not (dead soldier))
    (true (holding soldier flag)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; View Definitions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; A single step ?dir from cell (?x,?y) is blocked if a wall interupts that 
;;;  step.

(<= (stepBlocked N ?x ?y)
    (true (blockedNorth ?x ?y)))
(<= (stepBlocked S ?x2 ?y2)
    (nSteps 1 N ?x1 ?y1 ?x2 ?y2)
    (true (blockedNorth ?x1 ?y1)))
(<= (stepBlocked E ?x ?y)
    (true (blockedEast ?x ?y)))
(<= (stepBlocked W ?x2 ?y2)
    (nSteps 1 E ?x1 ?y1 ?x2 ?y2)
    (true (blockedEast ?x1 ?y1)))

;;; A path of an arbitrary number ?n steps ?dir from cell (?x, ?y) is blocked 
;;;  if a wall interupts any of the steps along that path.

(<= (pathBlocked ?dir ?x1 ?y1 ?x3 ?y3)
    (index ?n)
    (nSteps ?n ?dir ?x1 ?y1 ?x3 ?y3)
    (index ?m)
    (< ?m ?n)
    (nSteps ?m ?dir ?x1 ?y1 ?x2 ?y2)
    (stepBlocked ?dir ?x2 ?y2))    

;;; nSteps computes the cell found ?n steps ?dir of cell (?x,?y) within the
;;;  confines of an 8 x 8 grid.

(<= (nSteps ?n N ?x ?y1 ?x ?y2)
    (cell ?x ?y1)
    (+ ?y1 ?n ?y2)
    (index ?y2))
(<= (nSteps ?n S ?x ?y1 ?x ?y2)	
    (cell ?x ?y1)
    (- ?y1 ?n ?y2)
    (index ?y2))
(<= (nSteps ?n E ?x1 ?y ?x2 ?y)
    (cell ?x1 ?y)
    (+ ?x1 ?n ?x2)
    (index ?x2))
(<= (nSteps ?n W ?x1 ?y ?x2 ?y)
    (cell ?x1 ?y)
    (- ?x1 ?n ?x2)
    (index ?x2))

;;; Two cells are vertically related [north,south] of each other if the first is
;;;  [higher,lower] than the second.

(<= (verticalRelation N ?x1 ?y1 ?x2 ?y2)
    (cell ?x1 ?y1)
    (cell ?x2 ?y2)
    (> ?y1 ?y2))
(<= (verticalRelation S ?x1 ?y1 ?x2 ?y2)
    (cell ?x1 ?y1)
    (cell ?x2 ?y2)
    (< ?y1 ?y2))

;;; Two cells are horizontall related [east,west] of each other if the first is
;;;  [right,left] of the second.

(<= (horizontalRelation E ?x1 ?y1 ?x2 ?y2)
    (cell ?x1 ?y1)
    (cell ?x2 ?y2)
    (> ?x1 ?x2))
(<= (horizontalRelation W ?x1 ?y1 ?x2 ?y2)
    (cell ?x1 ?y1)
    (cell ?x2 ?y2)
    (< ?x1 ?x2))	
	
;;; Defines the legal distances that an object may be thrown (0, 1, or 2 cells)
	
(<= (legalThrowDist 0))
(<= (legalThrowDist 1))
(<= (legalThrowDist 2))

;;; Every item (with the exception of the flag) is used if the soldier performs
;;;  the action that it enables.

(<= (uses soldier ?item)
    (type ?item healingItem)
    (does soldier heal))
(<= (uses soldier ?item)
    (type ?item losItem)
    (does soldier (shoot ?dir)))
(<= (uses soldier ?item)
    (type ?item aoeItem)
    (does soldier (throw ?dir ?dist)))

;;; Cell (?x,?y) is attacked by the soldier if the soldier performs the shoot
;;;  action and that cell is within a line of sight ?dir of the soldier.

(<= (attacks ?x ?y soldier)
    (does soldier (shoot ?dir))
    (true (location soldier ?x ?y)))
(<= (attacks ?x2 ?y2 soldier)
    (does soldier (shoot ?dir))
    (true (location soldier ?x1 ?y1))
    (index ?n)
    (nSteps ?n ?dir ?x1 ?y1 ?x2 ?y2)
    (not (pathBlocked ?dir ?x1 ?y1 ?x2 ?y2)))
    
;;; Cell (?x,?y) is attacked by the soldier if the soldier performs the throw
;;;  action and that cell is within a one cell radius of where the item thrown
;;;  by the soldier lands.

(<= (attacks ?x2 ?y2 soldier)
    (does soldier (throw ?dir ?dist))
    (true (location soldier ?x1 ?y1))
    (nSteps ?dist ?dir ?x1 ?y1 ?x2 ?y2))
(<= (attacks ?x3 ?y3 soldier)
    (does soldier (throw ?dir ?dist))
    (true (location soldier ?x1 ?y1))
    (nSteps ?dist ?dir ?x1 ?y1 ?x2 ?y2)
    (nSteps 1 ?dirAny ?x2 ?y2 ?x3 ?y3))

;;; Any character of type terrorist attacks a cell (?x,?y) if that character
;;;  will be standing there at the beginning of the next time-step.

(<= (attacks ?x ?y ?terrorist)
    (type ?terrorist terrorist)
    (intendedLocation ?terrorist ?x ?y))

;;; A terrorist attacks a cell (?x,?y) if any character of type terrorist 
;;;  attacks that cell.

(<= (terroristAttacks ?x ?y)
    (type ?terrorist terrorist)
    (attacks ?x ?y ?terrorist))

;;; At the beginning of the next time-step the soldier will either be one step
;;;  away if he performed the step action, or in the same place if he performed
;;;  some other action.

(<= (intendedLocation soldier ?x2 ?y2)
    (true (location soldier ?x1 ?y1))
    (does soldier (step ?dir))    
    (nSteps 1 ?dir ?x1 ?y1 ?x2 ?y2))
(<= (intendedLocation soldier ?x ?y)
    (true (location soldier ?x ?y))
    (not (does soldier (step N)))
    (not (does soldier (step S)))
    (not (does soldier (step E)))
    (not (does soldier (step W))))    

;;; A dead terrorist is incapacitated and will not move.

(<= (intendedLocation ?terrorist ?x ?y)
    (true (location ?terrorist ?x ?y))
    (type ?terrorist terrorist)
    (dead ?terrorist))
    
;;; A character of type [horizontal,vertical]-terrorist will perform two
;;; [horizontal,vertical] steps per turn.

(<= (intendedLocation ?terrorist ?x3 ?y3)
    (type ?terrorist horizontalTerrorist)
    (not (dead ?terrorist))
    (intendedLocation soldier ?xS ?yS)
    (true (location ?terrorist ?x1 ?y1))
    (horizontalStep ?x1 ?y1 ?x2 ?y2 ?xS ?yS)
    (horizontalStep ?x2 ?y2 ?x3 ?y3 ?xS ?yS))
(<= (intendedLocation ?terrorist ?x3 ?y3)
    (type ?terrorist verticalTerrorist)
    (not (dead ?terrorist))
    (intendedLocation soldier ?xS ?yS)
    (true (location ?terrorist ?x1 ?y1))
    (verticalStep ?x1 ?y1 ?x2 ?y2 ?xS ?yS)
    (verticalStep ?x2 ?y2 ?x3 ?y3 ?xS ?yS))

;;; A [horizontal,vertical] step is one that will move [horizontally,vertically]
;;;  toward the intended location of the soldier before it will move 
;;;  [vertically,horizontally].

(<= (horizontalStep ?x1 ?y1 ?x2 ?y2 ?xT ?yT)
    (wouldStepHorizontal ?dir ?x1 ?y1 ?xT ?yT)
    (nSteps 1 ?dir ?x1 ?y1 ?x2 ?y2))
(<= (horizontalStep ?x1 ?y1 ?x2 ?y2 ?xT ?yT)
    (wouldStepVertical ?dir ?x1 ?y1 ?xT ?yT)
    (nSteps 1 ?dir ?x1 ?y1 ?x2 ?y2)
    (not (wouldStepHorizontal E ?x1 ?y1 ?xT ?yT))
    (not (wouldStepHorizontal W ?x1 ?y1 ?xT ?yT)))
(<= (horizontalStep ?x ?y ?x ?y ?xT ?yT)
    (cell ?x ?y)
    (cell ?xT ?yT)
    (not (wouldStepHorizontal E ?x ?y ?xT ?yT))
    (not (wouldStepHorizontal W ?x ?y ?xT ?yT))
    (not (wouldStepVertical N ?x ?y ?xT ?yT))
    (not (wouldStepVertical S ?x ?y ?xT ?yT)))
    
(<= (verticalStep ?x1 ?y1 ?x2 ?y2 ?xT ?yT)
    (wouldStepVertical ?dir ?x1 ?y1 ?xT ?yT)
    (nSteps 1 ?dir ?x1 ?y1 ?x2 ?y2))
(<= (verticalStep ?x1 ?y1 ?x2 ?y2 ?xT ?yT)
    (wouldStepHorizontal ?dir ?x1 ?y1 ?xT ?yT)
    (nSteps 1 ?dir ?x1 ?y1 ?x2 ?y2)
    (not (wouldStepVertical N ?x1 ?y1 ?xT ?yT))
    (not (wouldStepVertical S ?x1 ?y1 ?xT ?yT)))
(<= (verticalStep ?x ?y ?x ?y ?xT ?yT)
    (cell ?x ?y)
    (cell ?xT ?yT)
    (not (wouldStepVertical N ?x ?y ?xT ?yT))
    (not (wouldStepVertical S ?x ?y ?xT ?yT))
    (not (wouldStepHorizontal E ?x ?y ?xT ?yT))
    (not (wouldStepHorizontal W ?x ?y ?xT ?yT)))
    
;;; True if the step from (?x1,?y1) toward (?x2,?y2) along the direction ?dir
;;;  is not blocked by a wall.
   
(<= (wouldStepHorizontal ?dir ?x1 ?y1 ?x2 ?y2)
    (horizontalRelation ?dir ?x2 ?y2 ?x1 ?y1)
    (not (stepBlocked ?dir ?x1 ?y1)))
(<= (wouldStepVertical ?dir ?x1 ?y1 ?x2 ?y2)
    (verticalRelation ?dir ?x2 ?y2 ?x1 ?y1)
    (not (stepBlocked ?dir ?x1 ?y1)))	

;;; The soldier's health is incremented by 1 if he performs the heal action,
;;;  0 otherwise.

(<= (healthIncrement soldier 1)
    (does soldier heal))
(<= (healthIncrement soldier 0)
    (not (does soldier heal)))
    
;;; The soldier's health is decremented by 1 if he is attacked by a terrorist,
;;;  0 otherwise.

(<= (healthDecrement soldier 1)
    (intendedLocation soldier ?x ?y)
    (terroristAttacks ?x ?y))
(<= (healthDecrement soldier 0)
    (intendedLocation soldier ?x ?y)
    (not (terroristAttacks ?x ?y)))

;;; A terrorist's health may never be incremented

(<= (healthIncrement ?terrorist 0)
    (type ?terrorist terrorist))
    
;;; A terrorist's health is decremented by 1 if he is attacked by the soldier,
;;;  0 otherwise.

(<= (healthDecrement ?terrorist 1)
    (type ?terrorist terrorist)
    (intendedLocation ?terrorist ?x ?y)
    (attacks ?x ?y soldier))
(<= (healthDecrement ?terrorist 0)
    (type ?terrorist terrorist)
    (intendedLocation ?terrorist ?x ?y)
    (not (attacks ?x ?y soldier)))

;;; A character with 0 health is dead.

(<= (dead ?object)
    (true (health ?object 0)))

;;; Two cells are distinct if they differ on either an x- or y- coordinate

(<= (distinctCell ?x1 ?y1 ?x2 ?y2)
    (cell ?x1 ?y1)
    (cell ?x2 ?y2)
    (distinct ?x1 ?x2))
(<= (distinctCell ?x1 ?y1 ?x2 ?y2)
    (cell ?x1 ?y1)
    (cell ?x2 ?y2)
    (distinct ?y1 ?y2))

;;; A cell is composed of two indices in the range [1,8]

(<= (cell ?x ?y)
    (index ?x)
    (index ?y))

;;; Timeout occurs at time t=timeFinal

(<= timeout
    (true (time ?t))
    (timeFinal ?t))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Static Relations
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Indices in the range [1,8].

(index 1) (index 2) (index 3) (index 4) (index 5) (index 6) (index 7) (index 8)

;;; The cardinal directions {N,S,E,W}.

(direction N) (direction S) (direction E) (direction W)

;;; The time at which the game will end.

(timeFinal 50)

;;; Type heirarchies.

(type    flag item)
(type    gun1 item) (type    gun1     losItem) 
(type    gun2 item) (type    gun2     losItem) 
(type grenade item) (type grenade     aoeItem)

(type    soldier animate)
(type terrorist1 animate) (type terrorist1 terrorist) (type terrorist1 horizontalTerrorist)
(type terrorist2 animate) (type terrorist2 terrorist) (type terrorist2 horizontalTerrorist)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Stand-ins for built-in math functions (Uncomment as necessary)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;(< 1 2) (< 1 3) (< 1 4) (< 1 5) (< 1 6) (< 1 7) (< 1 8) 
;(< 2 3) (< 2 4) (< 2 5) (< 2 6) (< 2 7) (< 2 8) 
;(< 3 4) (< 3 5) (< 3 6) (< 3 7) (< 3 8) 
;(< 4 5) (< 4 6) (< 4 7) (< 4 8) 
;(< 5 6) (< 5 7) (< 5 8) 
;(< 6 7) (< 6 8) 
;(< 7 8) 

;(> 8 7) (> 8 6) (> 8 5) (> 8 4) (> 8 3) (> 8 2) (> 8 1) 
;(> 7 6) (> 7 5) (> 7 4) (> 7 3) (> 7 2) (> 7 1) 
;(> 6 5) (> 6 4) (> 6 3) (> 6 2) (> 6 1) 
;(> 5 4) (> 5 3) (> 5 2) (> 5 1) 
;(> 4 3) (> 4 2) (> 4 1) 
;(> 3 2) (> 3 1) 
;(> 2 1) 

;(+ 0 0 0) (+ 0 1 1) (+ 0 2 2) (+ 0 3 3) (+ 0 4 4) (+ 0 5 5) (+ 0 6 6) (+ 0 7 7) (+ 0 8 8) 
;(+ 1 0 1) (+ 1 1 2) (+ 1 2 3) (+ 1 3 4) (+ 1 4 5) (+ 1 5 6) (+ 1 6 7) (+ 1 7 8) 
;(+ 2 0 2) (+ 2 1 3) (+ 2 2 4) (+ 2 3 5) (+ 2 4 6) (+ 2 5 7) (+ 2 6 8) 
;(+ 3 0 3) (+ 3 1 4) (+ 3 2 5) (+ 3 3 6) (+ 3 4 7) (+ 3 5 8) 
;(+ 4 0 4) (+ 4 1 5) (+ 4 2 6) (+ 4 3 7) (+ 4 4 8) 
;(+ 5 0 5) (+ 5 1 6) (+ 5 2 7) (+ 5 3 8) 
;(+ 6 0 6) (+ 6 1 7) (+ 6 2 8) 
;(+ 7 0 7) (+ 7 1 8) 
;(+ 8 0 8) 

;(- 0 0 0) 
;(- 1 0 1) (- 1 1 0) 
;(- 2 0 2) (- 2 1 1) (- 2 2 0) 
;(- 3 0 3) (- 3 1 2) (- 3 2 1) (- 3 3 0) 
;(- 4 0 4) (- 4 1 3) (- 4 2 2) (- 4 3 1) (- 4 4 0) 
;(- 5 0 5) (- 5 1 4) (- 5 2 3) (- 5 3 2) (- 5 4 1) (- 5 5 0) 
;(- 6 0 6) (- 6 1 5) (- 6 2 4) (- 6 3 3) (- 6 4 2) (- 6 5 1) (- 6 6 0) 
;(- 7 0 7) (- 7 1 6) (- 7 2 5) (- 7 3 4) (- 7 4 3) (- 7 5 2) (- 7 6 1) (- 7 7 0) 
;(- 8 0 8) (- 8 1 7) (- 8 2 6) (- 8 3 5) (- 8 4 4) (- 8 5 3) (- 8 6 2) (- 8 7 1) (- 8 8 0) 

;(+ 1 1 2) (+ 2 1 3) (+ 3 1 4) (+ 4 1 5) (+ 5 1 6) (+ 6 1 7) (+ 7 1 8) (+ 8 1 9) (+ 9 1 10) (+ 10 1 11) (+ 11 1 12) (+ 12 1 13) (+ 13 1 14) (+ 14 1 15) (+ 15 1 16) (+ 16 1 17) (+ 17 1 18) (+ 18 1 19) (+ 19 1 20) (+ 20 1 21) (+ 21 1 22) (+ 22 1 23) (+ 23 1 24) (+ 24 1 25) (+ 25 1 26) (+ 26 1 27) (+ 27 1 28) (+ 28 1 29) (+ 29 1 30) (+ 30 1 31) (+ 31 1 32) (+ 32 1 33) (+ 33 1 34) (+ 34 1 35) (+ 35 1 36) (+ 36 1 37) (+ 37 1 38) (+ 38 1 39) (+ 39 1 40) (+ 40 1 41) (+ 41 1 42) (+ 42 1 43) (+ 43 1 44) (+ 44 1 45) (+ 45 1 46) (+ 46 1 47) (+ 47 1 48) (+ 48 1 49) (+ 49 1 50) 
