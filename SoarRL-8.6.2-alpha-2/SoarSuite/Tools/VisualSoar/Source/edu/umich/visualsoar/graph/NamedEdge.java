package edu.umich.visualsoar.graph;

import edu.umich.visualsoar.parser.*;
import edu.umich.visualsoar.operatorwindow.*;
import edu.umich.visualsoar.datamap.*;
import edu.umich.visualsoar.util.*;
import javax.swing.JOptionPane;
import java.util.*;

/**
 * This represents an attribute in Working Memomry
 * @author Brad Jones
 * @version 0.5a Oct 1999
 */

public class NamedEdge extends Edge 
{
///////////////////////////////////////////////////////////////////
// Data Members
///////////////////////////////////////////////////////////////////
    /**
     * The name of this named edge
     */
    protected String name = "";
         
    /**
     * Comments user attributes to this edge on the datamap
     */
    private String comment = "";

    /**
     * Knowledge of whether generated by DataMap generator.
     * If it is true, will show up as green on the datamap
     * until validated by user.
     */
    private boolean generated;

    /**
     * These are used to hold the information of where in the rules that
     * this NamedEdge was generated during the datamap generation.
     */
    private OperatorNode node = null;
    private int lineNumber = 0;

    /**
     *  Status of NamedEdge as to whether NamedEdge is tested or created by a production
     *  0 = Never tested or created by project's productions
     *  1 = Tested by a rule  (condition)
     *  2 = Created by a rule (action)
     *  3 = Both tested and created by rules
     */
    private int testedStatus;
    /*  keeps track of if edge was already reported as never tested/created
        so that it doesn't show up multiple times in feedback list
    */
    private boolean errorNoted;
    
///////////////////////////////////////////////////////////////////
// Constructors
///////////////////////////////////////////////////////////////////
    // Deny Default Construction
    /**
     * A named edge is logically a connection between two
     * vertices, from v0 to v1, with a name
     * @param v0 where the edge starts
     * @param v1 where the edge ends
     * @param _name the name that you want to name the string, note
     * if you change this string you also change the name of the node
     */
    public NamedEdge(Vertex v0, Vertex v1, String _name) 
    {
        super(v0,v1);
        name = _name;
        generated = false;
        testedStatus = 0;
        errorNoted = false;
    }
    
///////////////////////////////////////////////////////////////////
// Methods
///////////////////////////////////////////////////////////////////
    /**
     * This method returns the name of the node, note if the return
     * value of this string is changed so is the name of the node
     * @return the name of this node
     */
    public String getName() 
    {
        return name;
    }

    /**
     * This method changes the name of the node from whatever it was
     * to the parameter passed, note changes to s will change the
     * name of the node
     * @param s what you want to rename the node to
     * @return the name of this node
     */
    public void rename(String s) 
    {
        name  = s;
    }
    
    /**
     * This presents a String representation of this class
     * it is the name of the edge followed by representation
     * of v1's toString() method
     * @return a string just described
     */
    public String toString() 
    {
        return name + v1.toString();
    }
    
    /**
     * This is the write method that writes out a representation
     * of this edge to the Writer that can later be read back in
     * to recreate this edge
     * @param w the stream to write the representation to
     * @throws IOException if an error writing to the stream occurs
     */
    public void write(java.io.Writer w) throws java.io.IOException 
    {
        w.write("" + v0.getValue() + ' ' + name + ' ' + v1.getValue() + '\n');
    }
    
    /**
     * an edge is equal to another object if and only if
     * the other object is an edge, not null and the starting
     * ending vertexs are equal and the names are the same
     * @param o the object that you want to test equality
     * @return whether the test was true or false like just described
     */
    public boolean equals(Object o) 
    {
        if (o instanceof NamedEdge && o != null) 
        {
            NamedEdge anotherEdge = (NamedEdge)o;
            if(v0.getValue() == anotherEdge.V0().getValue() &&
               v1.getValue() == anotherEdge.V1().getValue() &&
               name.equals(anotherEdge.getName())) 
            {
                return true;
            }
            else
            return false;
        }
        else
        return this == o;
    }
    
    /**
     * satisfies tests whether or not this edge could be used to
     * satisfy the constraint passed in, if so, it returns true
     * else false
     * @param triple the constraint to test satisfaction to
     * @return whether or not this NamedEdge can satisfy that constraint
     */
    public boolean satisfies(Triple triple) 
    {
        if (!TripleUtils.isVariable(triple.getAttribute().getString()))
        if (!triple.getAttribute().getString().equals(name))
        return false;
        if (TripleUtils.isVariable(triple.getValue().getString()))
        return true;
        SoarVertex sv = (SoarVertex)V1();
        return sv.isValid(triple.getValue().getString());
    }



    public boolean hasComment() 
    {
        if (comment.equals(""))
        return false;
        else
        return true;
    }

    public void setComment(String newComment) 
    {
        comment = newComment;
    }

    public String getComment() 
    {
        return comment;
    }

    public boolean isGenerated() 
    {
        return generated;
    }

    /*
     *  Called when the datamap automatically generates the edge on the
     *  datamap.  Displayed as green text on datamap.
     */
    public void setAsGenerated() 
    {
        generated = true;
    }

    /*
     *  When user validates the edge generated by the datamap generator
     *  generated variable goes to false and subsequently the datamap know
     *  displays the edge as normal black color text.
     */
    public void validate() 
    {
        generated = false;
        lineNumber = 0;
        node = null;
    }

    /**
     *  If this edge was already reported as non created/tested, then
     *  it will return true so that the error is not reported multiple times
     */
    public boolean getErrorNoted() 
    {
        return errorNoted;
    }

    /**
     *  Sets the errorNoted variable of this edge as true, meaning that it has already
     *  been reported to the feedback list as non tested/created
     */
    public void setErrorNoted() 
    {
        errorNoted = true;
    }

    /**
     *  resets the errorNoted variable of this edge as false, meaning that is have never
     *  been reported by the feedback list as non tested/created.
     */
    public void resetErrorNoted() 
    {
        errorNoted = false;
    }


    /**
     *  Returns the value of testedStatus
     */
    public int getTestedStatus() 
    {
        return testedStatus;
    }

    /**
     *  If this edge was created by a production (action side of production)
     *  this will return true.
     */
    public boolean isCreated() 
    {
        if((testedStatus == 2) || (testedStatus == 3)) 
        {
            return true;
        }
        else 
        {
            return false;
        }
    }

    /**
     *  Returns true only if edge was created but NEVER tested
     */
    public boolean isCreatedNoTest() 
    {
        if(testedStatus == 2) 
        {
            return true;
        }
        else 
        {
            return false;
        }
    }
  
    /**
     *  Returns true only if edge was tested but NEVER created
     */
    public boolean isTestedNoCreate() 
    {
        if(testedStatus == 1) 
        {
            return true;
        }
        else 
        {
            return false;
        }
    }

    /**
     *  If this edge was tested by a production (condition side of production)
     *  this will return true.
     */
    public boolean isTested() 
    {
        if((testedStatus == 1) || (testedStatus == 3)) 
        {
            return true;
        }
        else 
        {
            return false;
        }
    }

    /**
     *  If this edge was never tested or created by a production
     *  this will return true.
     */
    public boolean notMentioned() 
    {
        if(testedStatus == 0) 
        {
            return true;
        }
        else 
        {
            return false;
        }
    }

    /**
     *  Sets the value of testedStatus
     *  @param value the requested value to change testedStatus to
     *  @return false if value not 0-3
     */
    public boolean setTestedStatus(int value) 
    {
        if ((value >= 0) && (value < 5)) 
        {
            testedStatus = value;
            return true;
        }
        else
        return false;
    }

    /**
     * Sets testedStatus to zero
     */
    public void resetTestedStatus() 
    {
        testedStatus = 0;
    }

    /**
     *  If edge was already created by a production,
     *  sets testedStatus to 3 (both).
     *  Otherwise, sets testedStatus to 1 (tested).
     */
    public void tested() 
    {
        if(testedStatus == 0) 
        {
            testedStatus = 1;
        }
        else if(testedStatus == 2) 
        {
            testedStatus = 3;
        }
    }

    /**
     *  If edge was already tested by a production,
     *  sets testedStatus to 3 (both).
     *  Otherwise, sets testedStatus to 2 (created).
     */
    public void created() 
    {
        if(testedStatus == 0) 
        {
            testedStatus = 2;
        }
        else if(testedStatus == 1) 
        {
            testedStatus = 3;
        }
    }


    /**
     *  Initializes/Sets all of the edges on the output link as tested.
     *  @return false if this edge is not the output-link
     */
    public boolean setOutputLinkTested(SoarWorkingMemoryModel swmm) 
    {
        // make sure this is the output-link
        if(!getName().equals("output-link"))
        return false;
        edu.umich.visualsoar.util.Queue queue = new QueueAsLinkedList();
        int numberOfVertices = swmm.getNumberOfVertices();
        boolean[] visitedVertices = new boolean[numberOfVertices];
        for(int i = 0; i < numberOfVertices; i++)
        visitedVertices[i] = false;
        queue.enqueue(this.V1());
        this.tested();
        this.setErrorNoted();

        while(!queue.isEmpty()) 
        {
            SoarVertex w = (SoarVertex)queue.dequeue();
            visitedVertices[w.getValue()] = true;
            if(w.allowsEmanatingEdges()) 
            {
                Enumeration edges = swmm.emanatingEdges(w);
                while(edges.hasMoreElements()) 
                {
                    NamedEdge theEdge = (NamedEdge)edges.nextElement();
                    theEdge.tested();
                    theEdge.setErrorNoted();
                    if(! visitedVertices[theEdge.V1().getValue()]) 
                    {
                        visitedVertices[w.getValue()] = true;
                        queue.enqueue(theEdge.V1());
                    }   // if haven't visited this vertex, add to the queue
                } // while looking at all of the edges of the vertex
            }
        }   // while queue is not empty, examine each vertex in it
        return true;
    } // end of setOutputLinkTested()

    /**
     *  Initializes/Sets all of the edges on the input link as created.
     *  @return false if this edge is not the input-link
     */
    public boolean setInputLinkCreated(SoarWorkingMemoryModel swmm) 
    {
        // make sure this is the output-link
        if(!getName().equals("input-link"))
        return false;
        edu.umich.visualsoar.util.Queue queue = new QueueAsLinkedList();
        int numberOfVertices = swmm.getNumberOfVertices();
        boolean[] visitedVertices = new boolean[numberOfVertices];
        for(int i = 0; i < numberOfVertices; i++)
        visitedVertices[i] = false;
        queue.enqueue(this.V1());
        this.created();
        setErrorNoted();

        while(!queue.isEmpty()) 
        {
            SoarVertex w = (SoarVertex)queue.dequeue();
            visitedVertices[w.getValue()] = true;
            if(w.allowsEmanatingEdges()) 
            {
                Enumeration edges = swmm.emanatingEdges(w);
                while(edges.hasMoreElements()) 
                {
                    NamedEdge theEdge = (NamedEdge)edges.nextElement();
                    theEdge.created();
                    theEdge.setErrorNoted();
                    if(! visitedVertices[theEdge.V1().getValue()]) 
                    {
                        visitedVertices[w.getValue()] = true;
                        queue.enqueue(theEdge.V1());
                    }   // if haven't visited this vertex, add to the queue
                } // while looking at all of the edges of the vertex
            }
        }   // while queue is not empty, examine each vertex in it
        return true;
    } // end of setInputLinkCreated()



    public OperatorNode getNode() 
    {
        return node;
    }

    public void setNode(OperatorNode newNode) 
    {
        node = newNode;
    }

    public int getLine() 
    {
        return lineNumber;
    }

    public void setLineNumber(int number) 
    {
        lineNumber = number;
    }

}
