## -*- Mode: sde -*-
## $Id$
##
############################# -*- Mode: Soar -*- #############################
## 
## File            : default.soar
## Author          : John Laird
## Created on      : Mon Feb 27 16:15:34 1989  
## Last Modified By: Allan Rempel (for Scott Huffman and Mark Portelli)
## Last Modified On: Mon Sep 19 11:00:40 1994
## 
## Contents:     Default productions for Soar 6.2.4 NNPSCM
##
###############################################################################

###
###		i.	Table of Contents
###
###	i.	Table of Contents
###	ii.	Change Log
###	iv.	Possible Problems
###	7.1	Default knowledge for the top context
###		A.	default*top-goal*elaborate*state*name*top-goal*top-state
###		B.	default*top-goal*elaborate*state*io-state
###		C.	default*top-goal*elaborate*state*problem-space*desired
###		D.	default*top-ps*propose*wait
###		E.	default*terminate*wait
###             F.      default*top-goal*halt*operator*failure
###		
###	7.2	Default knowledge for impasses
###     7.2.1   Multi-choice impasses
###		A.	default*select*indifferent-and-worst*tied 
###		B.	default*select*reject-and-reconsider*conflict
###		
###     7.2.2   Operator no-change impasses
###		
###     7.2.3   Other no-change impasses
###	        A.      default*elaborate*operator*failed*no-change
###		B.	default*select*reject-and-reconsider*failed*operator
###		
###     7.2.4   Constraint-failure impasses
###	        A.      default*elaborate*operator*failed*constraint-failure
###
###	7.3	The selection space for multi-choice impasses
###		A.	default*selection*propose*space*selection
###		B.	default*selection*elaborate*state*found-value-true
###		C.	default*selection*elaborate*state*wait-true-not-all-objects-evaluated
###
###     7.3.1	The evaluate-object operator
###		A.	default*selection*propose*evaluate-object
###		B.	default*selection*select*evaluate-object*indifferent
###		C.	default*selection*elaborate*operator*evaluate-object*type-evaluation
###		D.	default*selection*elaborate*state*evaluation
###		E.	default*selection*elaborate*evaluate-object*desired
###		F.	default*selection*elaborate*evaluate-object*superproblem-space
###		G.	default*selection*elaborate*evaluate-object*superstate
###		H.	default*selection*elaborate*evaluate-object*all-objects-novalue
###
###     7.3.1.1 Evaluation Objects
###		A.	default*selection*elaborate*evaluation*value
###		B.	default*selection*elaborate*evaluation*desired
###		C.	default*selection*elaborate*evaluation*object
###		D.	default*selection*elaborate*evaluation*type
###
###     7.3.1.2 Applying the evaluate-object operator
###		A.	default*terminate*evaluate-object
###
###     7.3.2   The evaluation subgoal
###		A.	default*evaluate-object*elaborate*state*desired
###		B.	default*evaluate-object*elaborate*state*name
###		C.	default*evaluate-object*elaborate*state*problem-space
###		D.	default*evaluate-object*elaborate*state*duplicate-of
###		E.	default*evaluate-object*elaborate*state*look-ahead-operator*copy
###		F.	default*evaluate-object*elaborate*state*look-ahead-operator*no-copy
###		G.	default*evaluate-object*propose*look-ahead
###		H.	default*evaluate-object*elaborate*state*tried-tied-operator*copy
###		I.	default*evaluate-object*elaborate*state*tried-tied-operator*no-copy
###		J.	default*evaluate-object*elaborate*evaluation*failure*no-operators
###		K.	default*evaluate-object*elaborate*evaluation*failure*constraint-failure
###		L.	default*evaluate-object*elaborate*evaluation*from-subgoal
###		M.	default*evaluate-object*elaborate*evaluation*from-subgoal*duplicate-desired
###
###     7.3.2.1 State copying
###		A.	default*evaluate-object*elaborate*operator*type-evaluation*default-for-default-state-copy-is-yes
###		B.	default*evaluate-object*elaborate*operator*type-evaluation*default-state-copy-from-problem-space
###		C.	default*evaluate-object*elaborate*state*default-state-copy-from-type-evaluation-operator
###		D.	default*evaluate-object*elaborate*state*default-copy-is-all-attributes-at-level-one
###		E.	default*evaluate-object*elaborate*state*copy-all-attributes-at-level-one-from-problem-space
###		F.	default*evaluate-object*elaborate*state*initial*require-duplicate-state 
###		G.	default*evaluate-object*elaborate*state*create-duplicates-table
###		H.	default*evaluate-object*elaborate*state*add-one-level-attributes
###		I.	default*evaluate-object*elaborate*state*add-all-attributes-at-level-one
###		J.	default*evaluate-object*elaborate*state*change-one-level-attribute-to-duplicate
###		K.	default*evaluate-object*elaborate*state*change-all-attributes-at-level-one-to-duplicate
###		L.	default*evaluate-object*elaborate*state*duplicate-id-for-attribute
###		M.	default*evaluate-object*elaborate*state*duplicate-id-for-all-attributes
###		N.	default*evaluate-object*elaborate*add-attribute-to-duplicate
###		O.	default*evaluate-object*elaborate*add-duplicated-attribute-to-duplicate
###		P.	default*evaluate-object*elaborate*state*add-duplicate-to-state
###		Q.	default*evaluate-object*elaborate*state*add-duplicates-for-all-attributes
###		R.	default*evaluate-object*elaborate*state*eval*desired
###		S.	default*duplicate-desired*copy-old-value
###		T.	default*duplicate-desired*replace-old-value
###
###     7.3.2.3 Operator copying
###		B.	default*evaluate-object*elaborate*operator*default-operator-copy-is-yes
###		C.	default*evaluate-object*elaborate*operator*copy-default-operator-copy-from-problem-space
###		D.	default*evaluate-object*elaborate*state*copy-default-operator-copy-from-type-evaluation-operator
###		A.	default*evaluate-object*elaborate*state*create-duplicates-table-for-operator-only
###		E.	default*evaluate-object*elaborate*operator*add-attribute-to-duplicate-operator
###		F.	default*evaluate-object*elaborate*operator*add-duplicated-attribute-to-duplicate-operator
###
###     7.3.3   Computing evaluations
###     7.3.3.1 Computing numeric evaluations
###     7.3.3.2 Comparing numeric Evaluations
###		A.	default*selection*compare*equal-evaluation-indifferent
###		B.	default*selection*compare*higher-evaluation-better
###		C.	default*selection*compare*prefer-lower-evaluation
###		
###     7.3.3.3 Computing symbolic evaluations
###		A.	default*selection*compare*same-symbolic-evaluations-are-indifferent
###		B.	default*selection*compare*success-evaluation-better-than-partial-success
###		C.	default*selection*compare*partial-failure-evaluation-better-than-failure
###		D.	default*selection*select*required-success-evaluation-becomes-required-preference
###		E.	default*selection*select*success-evaluation-becomes-best-preference
###		F.	default*selection*select*indifferent-evaluation-becomes-indifferent-preference
###		G.	default*selection*select*partial-failure-evaluation-becomes-worst-preference
###		H.	default*selection*select*failure-evaluation-becomes-reject-preference
###		I.	default*selection*select*prohibit-failure-evaluation-becomes-prohibit-preference
###
###     7.3.3.4 Default evaluations
###		A.	default*pass-back-success
###
###     7.3.3.5 Novalue evaluations
###		A.	default*selection*compare*novalue-evaluation-always-worse
###
###     7.3.4   Halting Soar with success or failure
###		A.	default*top-goal*halt*success
###		B.	default*top-goal*halt*failure
###
###     7.4     Operator subgoaling
###		A.	default*generic*opsub*propose*space*generic
###		B.	default*generic*opsub*elaborate*state*name*operator-subgoal
###		C.	default*generic*opsub*elaborate*state*desired
###		D.	default*generic*opsub*copy*superstate
###		E.	default*generic*opsub*goal*elaborate*all-desireds
###		F.	default*generic*select*reject-desired
###		G.	default*generic*opsub*detect*state*success
###             H.      default*opsub*select-operator*subgoaling
###             I.      default*generic*opsub*failure*no-operator
###             J.      default*generic*evaluation*failure*no-operator
###             K.      default*generic*opsub*avoid*duplicate-operator
###             L.      default*generic*opsub*operator-subgoals
###             M.      default*generic*opsub*subgoal-on-all-desired-super-desireds
###             N.      default*generic*opsub*subgoal-on-all-super-desireds
###             O.      default*apply*evaluate*augment*evaluation-operator-super-desired
###             P.      default*elaborate*state*eval*super-desired
###
###     7.5     Execution monitoring
###		A.	default*monitor*goal*success
###		B.	default*monitor*goal*failure
###		C.	default*monitor*operator*evaluation
###		D.	default*monitor*attribute-impasses
###
###	16.	Stop-default

###
###		ii.	 Change Log
###

## Change log for 6.2.1 NNPSCM:  Significant number of changes.  Not itemized here.
## Change log for 6.2.3 NNPSCM:  Significant number of changes.  Not itemized here.
##       1. Renamed productions:
##          A. Eliminated the word implement
##          B. Rename those that propose problem space or state to be
##             elaborate state
##          C. Rename those that elaborate goal to be elaborate state
##          D. Propose*operator --> propose
##          E. terminate*operator --> terminate
##          F. *generic* --> evaluate-object
##       2. Changed variable names:  
##          A. <s> --> <ts> or <ss> as appropriate
##          B. <g> --> <s>
##          C. <top> --> <ts>
###############################################################################

###
###		iv.	Possible Problems
###
###	The default knowledge has a mind set that all evaluate-object operators
### will either be directly implemented, or will be implemented in a subspace
### that is performing look ahead style evaluation.  This should be checked to
### see if it causes errors.
###
###	There is still one opp-app declaration, due to a bug in support classification.
###
###	Evaluate-rejected and evaluate-primary are still in this knowledge as
### operator names, but are not proposed by this knowledge.
###
###	Operator subgoaling has known outstanding problems.
###

###
###
###		7.1	Default knowledge for the top context
###

## Elaborate the top goal with name top-goal and top-state.
##  both are required for backward compatibility
## Make it worst so it will be overridden by all other names.

sp {default*top-goal*elaborate*state*name*top-goal*top-state
    "Propose top-goal as name of top goal. Make it worst."
    :default
    (state <s> ^superstate nil)
    -->
    (<s> ^name top-goal + &, top-goal <
         ^name top-state + &, top-state <)}

## Elaborate state with io-state pointer.

sp {default*top-ps*elaborate*state*io-state
   "Elaborate the initial state in the top problem space."
   :default
   (state <s> ^name top-goal)
   -->
   (<s> ^io-state <s>)}

## Propose the top problem space, top-ps.
## Make it worst so it will only be selected if there are no others.
## Augment state with a desired.  Necessary for look-ahead.
## Other productions can elaborate the desired later.

sp {default*top-goal*elaborate*state*problem-space*desired
   "Propose top-ps as problem space for goal top-goal."
   :default
   (state <s> ^name top-goal)
   -->
   (<s> ^problem-space <p> + <, ^desired <d> + <)
   (<p> ^name top-ps)}

### Make wait always acceptable in the top-ps problem space.

sp {default*top-ps*propose*wait
   "Propose operator wait whenever in problem space top-ps."
   :default
   (state <s> ^problem-space.name top-ps)
   -->
   (<s> ^operator <o> <o> <)
   (<o> ^name wait)}

### Terminate wait as soon as it is selected so that another
### operator can be selected if situation changes.

sp {default*terminate*wait 
   "Terminate wait as soon as it is selected."
   :default
   (state <s> ^operator <o>)
   (<o> ^name wait)
   -->
   (<s> ^operator <o> @)}

sp {default*top-goal*halt*operator*failure
   "Halt if no operator can be selected for the top goal."
   :default
   (state <s> ^superstate nil)
   (state <ss> ^impasse constraint-failure ^superstate <s>)
   -->
   (write (crlf) |No operator can be selected for top goal.| )
   (write (crlf) |Soar must halt.| )
   (halt)}

###
###		7.2	Default knowledge for impasses
###
###
###		7.2.1	Multi-choice impasses 
###
### /* SBH/mvp 7-8-94 */
### If the problem space for handling the subgoal fails, signified by the 
### choices none impasse below it, make an indifferent and worst-preference 
### for each tied object.
### Only applies to operators in NNPSCM because operators are the only context slot
### that can tie.

sp {default*select*indifferent-and-worst*tied
   "Indifferent an object if it leads to a tie that can not be solved."
   :default
   (state <s2> ^problem-space.name selection
	       ^superstate <s1>
	       ^item <o>
	       ^quiescence t)
   (state <s3> ^attribute state
	       ^choices none
	       ^superstate <s2>
	       ^quiescence t)
   (state <s1> ^operator <o> +)
   -->
   (<s1> ^operator <o> =, < )}

### If the problem space for handling the subgoal fails, signified by 
### the choices none impasse below it, make a reject-preference for each 
### conflicted object.

sp {default*select*reject-and-reconsider*conflict
   "Reject an object if it leads to a conflict that can not be solved."
   :default
   (state <s2> ^impasse conflict
	       ^attribute operator
	       ^superstate <s1>
	       ^item <obj>
	       ^quiescence t)
   (state <s3> ^attribute state
	       ^choices none
	       ^superstate <s2>
	       ^quiescence t)
   (state <s1> ^operator <obj> +)
   -->
   (<s1> ^operator <obj> -)}


###
###	     7.2.2   Operator no-change impasses
###
### See operator subgoaling, as this is the default action here.

###		
###     	7.2.3   Other no-change impasses
###

### If no objects are available for a slot, and there is no operator to
### find more, reject next higher object.

sp {default*elaborate*operator*failed
   "Mark an operator as failed if can not suggest operators in subgoal"
   :default
   :o-support	     ;# required so fail persists following operator rejection
   (state <s4> ^attribute state
	       ^choices none
	       ^superstate <s3>
	       ^quiescence t)
   (state <s3> ^attribute state
	       ^choices none
	       ^superstate <s2>
	       ^quiescence t)
   (state <s2> ^attribute operator
	       ^choices none
	       ^superstate <s1>
	       ^quiescence t)
   (state <s1> ^operator <o>)
   -->
   (<o> ^failed t + &)}

sp {default*select*reject-and-reconsider*failed*operator
   "Reject an object if it leads to a no-change that cannot be solved."
   :default
   (state <s1> ^operator <o> +)
   (<o> ^failed t)
   -->
   (<s1> ^operator <o> - @)}


###		
###     	7.2.4   Constraint-failure impasses
###

### If there is a constraint-failure for a operator, below an object, 
### reject that object.

sp {default*elaborate*operator*failed*constraint-failure
   :default
   :o-support
   (state <s2> ^impasse constraint-failure
	       ^superstate <s1>
	       ^quiescence t)
   (state <s1> ^superstate <s0>
	       ^attribute operator
	       ^choices none)
   (state <s0> ^operator <o>)
   -->
   (<o> ^failed t + &)}

###
###		7.3	The selection space for multi-choice impasses
###

### Use the selection problem space for all choice multiple, impasses 
### - make it worst so that any other will dominate.

sp {default*selection*propose*space*selection
   :default
   (state <s> ^choices multiple)
   -->
   (<s> ^problem-space <p> + <p> < )
   (<p> ^name selection)}

### Signal that a value other than novalue has been assigned.

sp {default*selection*elaborate*state*found-value-true
   :default
   (state <s> ^problem-space.name selection
	      ^choices multiple)
   (<s> ^evaluation <e>)
   (<e> ^ << numeric-value symbolic-value >> <> novalue)
   -->
   (<s> ^found-value true)}


### Signal that there are still objects to evaluate.

sp {default*selection*elaborate*state*wait-true-not-all-objects-evaluated
   :default
   (state <s> ^problem-space.name selection
	      ^operator <o> +
	      ^choices multiple)
   - {(<o> ^type evaluation
	   ^evaluation <e>)
     (<e> ^ << numeric-value symbolic-value >> )}
   -->
   (<s> ^wait true)}

###
###		7.3.1	The evaluate-object operator
###

### Create evaluate operator in selection problem space.

sp {default*selection*propose*evaluate-object
   :default
   (state <s> ^problem-space.name selection
	      ^item <x>)
   -{(state <s> ^evaluation <e>)	;#"state" added. AA/mvp 9-2-94
    (<e> ^object <x>
	 ^value t)}
   -->
   (<o> ^state <s> ^name evaluate-object ^object <x>)
   (<s> ^operator <o> +)}


### Make them indifferent if not ^operator-selection not-indifferent.

sp {default*selection*select*evaluate-object*indifferent
   :default
   (state <s> ^problem-space <p>
	      ^operator <o> +)
   (<p> ^name selection
      - ^operator-selection not-indifferent)
   (<o> ^name evaluate-object)
   -->
   (<s> ^operator <o> =)}

### Label all evaluation operators with ^type evaluation.

sp {default*selection*elaborate*operator*evaluate-object*type-evaluation 
   :default
   (state <s> ^operator <o>)
   (<o> ^name << evaluate-object evaluate-dominated evaluate-primary >> )
   -->
   (<o> ^type evaluation)}    

### Create evaluation once the eval operator is selected.
 
sp {default*selection*elaborate*state*evaluation
   :default
   (state <s> ^operator <o>)
   (<o> ^type evaluation)
   -->
   (<s> ^evaluation <e> + &) 
   (<e> ^state <s> ^operator <o>)
   (<o> ^evaluation <e>)}

sp {default*selection*elaborate*evaluate-object*desired
   :default
   (state <s> ^operator <o>
	      ^superstate.desired <d>)
   (<o> ^type evaluation)
   -->
   (<o> ^desired <d> + &)}

sp {default*selection*elaborate*evaluate-object*superproblem-space
   :default
   (state <s> ^problem-space.name selection
	      ^operator <o>
	      ^superstate.problem-space <p2>)
   (<o> ^type evaluation)
   -->
   (<o> ^superproblem-space <p2>)}

sp {default*selection*elaborate*evaluate-object*superstate
   :default
   (state <s> ^problem-space.name selection
	      ^operator <o>
	      ^superstate <s2>)
   (<o> ^type evaluation)
   -->
   (<o> ^superstate <s2>)}

### If all objects have been evaluated, and all have value novalue, and
### there is a object being evaluated in a higher context, assign that
### object novalue.

sp {default*selection*elaboare*evaluate-object*all-objects-novalue
   :default
   (state <s> ^superstate.superstate <sss>
	      ^operator <o>
	    - ^wait
	    - ^found-value
	      ^quiescence t
	      ^choices multiple)
   (state <sss> ^problem-space.name selection
		^operator <sso>)
   (<sso> ^type evaluation)
   -->
   (<sso> ^numeric-value novalue ^evaluation-type final)}


###
###		7.3.1.1 Evaluation Objects
###

sp {default*selection*elaborate*evaluation*value
   :default
   (state <s> ^evaluation <e>)
   (<e> ^ << numeric-value symbolic-value >>)
   -->
   (<e> ^value t)}

sp {default*selection*elaborate*evaluation*desired
   :default
   (state <s> ^superstate.desired <d>
	      ^evaluation <e>)
   -->
   (<e> ^desired <d> <d> &)}

sp {default*selection*elaborate*evaluation*object
   :default
   (state <s> ^operator <o>
	      ^evaluation <e>)
   (<o> ^object <x>
	^evaluation <e>
	^type evaluation)
   -->
   (<e> ^object <x>)}

sp {default*selection*elaborate*evaluation*type
   :default
   (state <s> ^operator <o>
	      ^evaluation <e>)
   (<o> ^name <name>
	^evaluation <e>
	^type evaluation)
   -->
   (<e> ^type <name>)}


###
###		7.3.1.2 Applying the evaluate-object operator
###
###	Domain specific code may directly implement an evaluation, or an operator no-change may occur
### to do the job, see the next section.

### Reconsider evaluation operator after it finished in selection space.
                                      
sp {default*terminate*evaluate-object
   :default
   (state <s> ^operator <o>
	      ^evaluation <e>)
   (<o> ^object <x>)
   (<e> ^object <x>
	^value t)
   -->
   (<s> ^operator <o> @)}


###
###		7.3.2   The evaluation subgoal
###

###
### These productions which fire once an evaluation subgoal has been created
### have also been generalized.

### SBH/mvp 9-2-94
sp {default*evaluate-object*elaborate*state*desired
   :default
   (state <s> ^impasse no-change
	      ^attribute operator 
              ^superstate.operator <so>)
   (<so> -^default-desired-copy yes ^type evaluation ^desired <d>)
   -->
   (<s> ^desired <d> + &)}


sp {default*evaluate-object*elaborate*state*name
   :default
   (state <s> ^impasse no-change 
              ^attribute operator 
              ^superstate.operator.name evaluate-object)
   -->
   (<s> ^name implement-evaluate-object)}

sp {default*evaluate-object*elaborate*state*problem-space
   :default
   (state <s> ^impasse no-change
	      ^attribute operator
	      ^superstate.operator <so>)
   (<so> ^type evaluation
	 ^superproblem-space <p>)
   -->
   (<s> ^problem-space <p>)}

## install a copy of the state, when ^default-state-copying and there
## is an operator tie.

sp {default*evaluate-object*elaborate*state*duplicate-of
   :default
   (state <s> ^problem-space <p>
	      ^superstate <ss>
	      ^default-state-copy yes)
   (state <ss> ^operator <so>)
   (<so> ^type evaluation
	 ^superstate <sss>) 
   -->
   (<s> ^duplicate-of* <sss>)}

### Added test for superproblem-space.  This restricts these productions
### to only fire in a lookahead.  Previously, these productions made it
### impossible to use evaluation problem spaces other than lookahead.
### JEL 6/21/91

sp {default*evaluate-object*elaborate*state*look-ahead-operator*copy
   :default
   (state <s> ^problem-space.name <n> ^superstate.operator <so>)
   (<so> ^type evaluation 
	 ^default-operator-copy yes ^object <o> ^superproblem-space.name <n>)
   -->
   (<s> ^look-ahead-operator <copy-o>)
   (<copy-o> ^duplicate-of* <o>)}   


## Create pointer for uniform access even in no copy

### Added test for superproblem-space.  This restricts these productions
### to only fire in a lookahead.  Previously, these productions made it
### impossible to use evaluation problem spaces other than lookahead.
### JEL 6/21/91

sp {default*evaluate-object*elaborate*state*look-ahead-operator*no-copy
   :default
   (state <s> ^problem-space <p> ^superstate.operator <so>)
   (<so> ^type evaluation 
	 ^default-operator-copy no ^object <o> ^superproblem-space <p>)
   -->
   (<s> ^look-ahead-operator <o>)}   

### install copy of operator in lookahead context.
### <p> / <ssp> checks to correct bug from TJ
### Modified by JEL/mvp 07-Nov-93

sp {default*evaluate-object*propose*look-ahead
   :default
   (state <s> ^problem-space.name <n> ^look-ahead-operator <o> ^superstate <ss>)
   (state <ss> ^superstate.problem-space.name <n> ^operator.type evaluation)
  -(<s> ^tried-tied-operator <o>)
   -->
   (<s> ^operator <o> ! +)}


### Detect that the operator has been tried when a duplicate is being used.

sp {default*evaluate-object*elaborate*state*tried-tied-operator*copy
   :default
   (state <s> ^problem-space <p> ^operator <o-copy> 
	      ^superstate <ss> ^default-operator-copy yes)
   (state <ss> ^operator <so>)
   (<so> ^type evaluation 
	 ^superproblem-space <p> ^object <o>)
   (<o-copy> ^duplicate-of* <o>)
   -->
   (<s> ^tried-tied-operator <o-copy> + &)}

## Detect that the operator has been tried when a duplicate is not being used.

sp {default*evaluate-object*elaborate*state*tried-tied-operator*no-copy
   :o-support
   :default
   (state <s> ^problem-space <p> ^operator <o>
	      ^superstate <ss> ^default-operator-copy no)
   (state <ss> ^operator <so>)
   (<so> ^type evaluation
	 ^superproblem-space <p> ^object <o>)
   -->
   (<s> ^tried-tied-operator <o> + &)}


### Give symbol-value failure when no operators are proposed in subgoals

sp {default*evaluate-object*elaborate*evaluation*failure*no-operators
   :default
   (state <select-g> ^operator <o2>)
   (<select-g> ^evaluation <e2>)
   (<o2> ^type evaluation ^evaluation <e2>)
   (state <eval-g> ^superstate <select-g> ^quiescence t)
   (state <state-nc> ^superstate <eval-g> ^attribute state ^impasse no-change ^quiescence t)
   (state <goal-nc> ^superstate <state-nc> ^attribute state ^impasse no-change ^quiescence t)
   -->
   (<e2> ^symbolic-value failure)}


sp {default*evaluate-object*elaborate*evaluation*failure*constraint-failure
   :default
   (state <select-g> ^operator <o2>)
   (<select-g> ^evaluation <e2>)
   (<o2> ^type evaluation ^evaluation <e2>)
   (state <eval-g> ^superstate <select-g>)
   (state <rej-state-imp> ^superstate <eval-g> ^attribute operator
			  ^impasse constraint-failure)
   -->
   (<e2> ^symbolic-value failure)}

sp {default*evaluate-object*elaborate*evaluation*from-subgoal
   :default
   (state <s> ^superstate <ss>
	      ^ { << required-success success partial-success 
		indifferent partial-failure failure prohibit-failure
		draw lose win >> <svalue> } <eb> )
   (state <ss> ^operator <so> ^evaluation <e>)
   (<so> ^type evaluation ^evaluation <e> ^desired <eb>)
   -->
   (<e> ^symbolic-value <svalue>)}


##                                Added to handle duplicated desireds
sp {default*evaluate-object*elaborate*evaluation*from-subgoal*duplicate-desired
   :default
   (state <s> ^superstate <ss>
	      ^ { << required-success success partial-success 
		indifferent partial-failure failure prohibit-failure
		draw lose win >> <svalue> } <deb> )
   (state <ss> ^operator <so>
	       ^evaluation <e>)
   (<so> ^type evaluation ^evaluation <e> ^desired <eb>)
   (<deb> ^duplicate-of* <eb>)
   -->
   (<e> ^symbolic-value <svalue>)}


###
###		7.3.2.1.	State Copying
###

## If no signals on problem space, the default is to copy both state and operator

sp {default*evaluate-object*elaborate*operator*type-evaluation*default-for-default-state-copy-is-yes 
   :default
   (state <ss>^operator <so>)
   (<so> ^type evaluation 
	 ^superproblem-space <p>)
  -(<p> ^default-state-copy no)
   -->
   (<so> ^default-state-copy yes)}

sp {default*evaluate-object*elaborate*operator*type-evaluation*default-state-copy-from-problem-space 
   :default
   (state <ss> ^operator <so>)
   (<so> ^type evaluation 
	 ^superproblem-space <p>)
   (<p> ^default-state-copy <yes-or-no>)
   -->
   (<so> ^default-state-copy <yes-or-no>)}

### Default is that all-attributes-at-level are copied

sp {default*evaluate-object*elaborate*state*default-state-copy-from-type-evaluation-operator 
   :default
   (state <s> ^impasse no-change ^attribute operator ^superstate <ss>)
   (state <ss> ^operator <so>)
   (<so> ^type evaluation ^default-state-copy <yes-no>)
   -->
   (<s> ^default-state-copy <yes-no>)}

sp {default*evaluate-object*elaborate*state*default-copy-is-all-attributes-at-level-one 
   :default
   (state <s> ^impasse no-change ^attribute operator ^superstate <ss>)
   (state <ss> ^operator <so>)
   (<so> ^type evaluation 
	 ^superproblem-space <p>)
   (<p> -^all-attributes-at-level two
       -^one-level-attributes
       -^two-level-attributes
       -^dont-copy
       -^dont-copy-anything)
   -->
   (<s> ^all-attributes-at-level one)}

### We want ^all-attributes-at-level one to be on the goal, but if someone
### puts it on the space along with the other copying flags, we should allow
### that.  So, copy it from the space to the goal.

sp {default*evaluate-object*elaborate*state*copy-all-attributes-at-level-one-from-problem-space 
   :default
   (state <s> ^problem-space <p> ^default-state-copy yes)
   (<p> ^all-attributes-at-level one)
   -->
   (<s> ^all-attributes-at-level one)}

### Set up identifier mapping table for state duplication. 

sp {default*evaluate-object*elaborate*state*create-duplicates-table 
   :default
   (state <s> ^impasse no-change ^attribute operator ^superstate <ss>)
   (state <ss> ^operator <so>)
   (<so> ^type evaluation
         ^default-state-copy yes)
   -->
   (<s> ^duplicates* <d> +)}

### Copy one-level-attributes.

### Replaced test for implement-evaluate-object with test for superproblem-
### space. Makes the productions more general and is consistent with other
### default productions for lookahead search.  JEL 6/21/91 

sp {default*evaluate-object*elaborate*state*add-one-level-attributes 
   :default
   (state <ss> ^operator <so>)
   (<so> ^superproblem-space <p>)
   (state <s> ^problem-space <p> ^superstate <ss>
	      ^default-state-copy yes)  
   (<p> ^one-level-attributes <att>)
   (<s> ^duplicate-of* <ds>)
   (<ds> ^<att> <val>)
   -->
   (<s> ^<att> <val> + &)}

## Copy all attributes, when ^all-attributes-at-level one.

### Replaced test for implement-evaluate-object with test for superproblem-
### space. Makes the productions more general and is consistent with other
### default productions for lookahead search.  JEL 6/21/91 

sp {default*evaluate-object*elaborate*state*add-all-attributes-at-level-one 
   :default
   (state <sg> ^operator <so>)
   (<so> ^superproblem-space <p>)
   (state <s> ^problem-space <p> ^superstate <sg>
	      ^default-state-copy yes ^all-attributes-at-level one
	      ^duplicate-of* <ss>)
   (<p> - ^dont-copy-anything - ^dont-copy <att>
      - ^two-level-attributes <att>)
   (<ss> ^{ <> duplicate-of* <> tried-tied-operator <> problem-space 
            <> impasse <> attribute <> choices <> quiescence 
            <> operator <> superstate 
            <att> } <val>)
   -->
   (<s> ^<att> <val> + &)}

### If we copied a one-level-attribute, and it later turned
### out that its value happened to be something that was pointed to by a
### two-level-attribute, change its value to be the copied object.

sp {default*evaluate-object*elaborate*state*change-one-level-attribute-to-duplicate 
   :default
   (state <s> ^problem-space <p>
	      ^duplicates* <d>
	      ^default-state-copy yes
	      ^duplicate-of* <ss>)
   (<p> ^one-level-attributes <att>)
   (<ss> ^<att> <id>)
   (<d> ^<id> <new-id>)
   -->
   (<s> ^<att> <id> - <new-id> + &)}

### Fixes, when all-attributess-at-level one.

sp {default*evaluate-object*elaborate*state*change-all-attributes-at-level-one-to-duplicate
   :default
   (state <s> ^problem-space <p>
	      ^duplicates* <d>
	      ^default-state-copy yes
	      ^all-attributes-at-level one
	      ^duplicate-of* <ss>)
   (<p> - ^dont-copy <att>)
   (<ss> ^{ <> tried-tied-operator <att> } <id>)
   (<d> ^<id> <new-id>)
   -->
   (<s> ^<att> <id> - <new-id> + &)}

### Create new ids for two-level-attributes.

sp {default*evaluate-object*elaborate*state*duplicate-id-for-attribute 
   :default
   (state <s> ^problem-space <p>
	      ^duplicates* <d> ^default-state-copy yes
	      ^duplicate-of* <ss>)
   (<p> ^two-level-attributes <att>)
   (<ss> ^<att> <id>)
   -->
   (<d> ^<id> <new-id> + =)}

### Create new ids for all attributes, when ^all-attributes-at-level two.

sp {default*evaluate-object*elaborate*state*duplicate-id-for-all-attributes 
   :default
   (state <s> ^problem-space <p>
	      ^duplicates* <d>
	      ^default-state-copy yes
	      ^duplicate-of* <ss>)
   (<p> -^dont-copy-anything
       -^dont-copy <att>
	^all-attributes-at-level two
       -^one-level-attributes <att>)
   (<ss> ^{ <> duplicate-of* <> tried-tied-operator <> problem-space 
            <> impasse <> attribute <> choices <> quiescence
            <> operator <> superstate 
            <att> } <id>)
   -->
   (<d> ^<id> <new-id> + =)}

### Create a copy of the old object on the new link.  First copy
### augmentations that don't point to objects that have been
### duplicated. 

set warnings off
sp {default*evaluate-object*elaborate*add-attribute-to-duplicate 
   :default
   (state <s> ^duplicates* <d> 
	      ^default-state-copy yes)
   (<d> ^<id> <new-id>
      - ^<sub-val>)
   (<id> ^ { <> tried-tied-operator <sub-att> } <sub-val>)
   -->
   (<new-id> ^<sub-att> <sub-val> + &)}
set warnings on

### Next copy augmentations that point to duplicated objects:

set warnings off
sp {default*evaluate-object*elaborate*add-duplicated-attribute-to-duplicate 
   :default
   (state <s>
	^duplicates* <d> ^default-state-copy yes)
   (<d> ^<id> <new-id>
	^<sub-val> <new-val>)
   (<id> ^ { <> tried-tied-operator <sub-att> } <sub-val>)
   -->
   (<new-id> ^<sub-att> <new-val> + &)}
set warnings on

### Added ^two-level-attributes <att>.  Previously, it
### would copy any attribute that happened to point to the same value as
### one of the two-level-attributes.

sp {default*evaluate-object*elaborate*state*add-duplicate-to-state 
   :default
   (state <s> ^problem-space <p>
	      ^duplicates* <d> ^default-state-copy yes
	      ^duplicate-of* <ss>)
   (<p> ^two-level-attributes <att>)
   (<ss> ^<att> <id>)
   (<d> ^<id> <new-id>)
   -->
   (<s> ^<att> <new-id> + &)}


### moves the new links to the state when ^all-atts two.

sp {default*evaluate-object*elaborate*state*add-duplicates-for-all-attributes 
   :default
   (state <s> ^problem-space <p>
	      ^duplicates* <d>
	      ^default-state-copy yes
	      ^duplicate-of* <ss>)
   (<p> ^all-attributes-at-level two
      - ^dont-copy-anything
      - ^dont-copy <att>
      - ^one-level-attributes <att>)
   (<ss> ^{ <> tried-tied-operator <att> } <id>)
   (<d> ^<id> <new-id>)
   -->
   (<s> ^<att> <new-id> + &)}

## -------------------------------
## Desired copying:
## -------------------------------

## Copy attributes to the duplicate desired state.  We
## do this after the state is installed so that the duplicates table
## will already have been filled in.  We just copy all attributes over
## from the original operator, except that attributes that pointed to 
## objects that have been duplicated (on the state) are modified to point
## to the duplicate objects.

sp {default*evaluate-object*elaborate*state*eval*desired 
   :default
   (state <s> ^superstate <ss>)
   (state <ss> ^operator <so>)
   (<so> ^type evaluation ^desired <d> ^default-desired-copy yes )
   -->
   (<s> ^desired <d-copy>)
   (<d-copy> ^duplicate-of* <d>)}   


## Copy attributes whose values haven't been duplicated.

### SBH/mvp 9-2-94
### Added parallel preference to the copied attribute.
### Also, added the condition that the desired be attached to
### an evaluation superoperator.  This is because if we use the same 
### desired in a lower lookahead context, this production re-firing 
### can cause stupid chunks. 

sp {default*duplicate-desired*copy-old-value
   :default
   (state <g> ^superstate <sg> ^duplicates* <d> ^desired <o-copy>)
   (state <sg> ^operator <so>)
   (<so> ^type evaluation ^desired <o>)
   (<o-copy> ^duplicate-of* <o>)
   (<o> ^{ <> duplicate-of* <att> } <val> -^dont-copy <att>)
 - (<d> ^<val>)
 -->
   (<o-copy> ^<att> <val> + <val> &)}

## Copy attributes whose values have been duplicated.

sp {default*duplicate-desired*replace-old-value
   :default
   (state <s> ^duplicates* <d> ^desired <o-copy>)
   (<o-copy> ^duplicate-of* <o>)
   (<o> ^ { <> duplicate-of* <att> } <id>
      - ^dont-copy <att>)
   (<d> ^<id> <copy-id>)
   -->
   (<o-copy> ^<att> <copy-id>)}



###		7.3.2.3 Operator copying	
###
### Copy attributes to the duplicate operator.  We
### do this after the state is installed so that the duplicates table
### will already have been filled in.  We just copy all attributes over
### from the original operator, except that attributes that pointed to 
### objects that have been duplicated (on the state) are modified to point
### to the duplicate objects.


sp {default*evaluate-object*elaborate*operator*default-operator-copy-is-yes 
   :default
   (state <ss> ^operator <so>)
   (<so> ^type evaluation 
	 ^superproblem-space <p>)
  -(<p> ^default-operator-copy no)
   -->
   (<so> ^default-operator-copy yes)}


sp {default*evaluate-object*elaborate*operator*copy-default-operator-copy-from-problem-space 
   :default
   (state <ss> ^operator <so>)
   (<so> ^type evaluation 
	 ^superproblem-space <p>)
   (<p> ^default-operator-copy <yes-or-no>)
   -->
   (<so> ^default-operator-copy <yes-or-no>)}


sp {default*evaluate-object*elaborate*state*copy-default-operator-copy-from-type-evaluation-operator 
   :default
   (state <s> ^impasse no-change ^attribute operator ^superstate <ss>)
   (state <ss> ^operator <so>)
   (<so> ^type evaluation ^default-operator-copy <yes-no>)
   -->
   (<s> ^default-operator-copy <yes-no>)}

### Set up identifier mapping table for operator

sp {default*evaluate-object*elaborate*state*create-duplicates-table-for-operator-only 
   :default
   (state <s> ^impasse no-change ^attribute operator ^superstate <ss>)
   (state <ss> ^operator <so>)
   (<so> ^type evaluation
         ^default-operator-copy yes 
       - ^default-state-copy yes)
   -->
   (<s> ^duplicates* <d> +)}

### Copy attributes whose values haven't been duplicated.
###

sp {default*evaluate-object*elaborate*operator*add-attribute-to-duplicate-operator 
   :default
   (state <s> ^duplicates* <d> ^look-ahead-operator <o-copy>)
   (<o-copy> ^duplicate-of* <o>)
   (<o> ^ { <> duplicate-of* <att> } <val>
      - ^ dont-copy <att>)
   (<d> - ^<val>)
   -->
   (<o-copy> ^<att> <val>)}

### Copy attributes whose values have been duplicated.

sp {default*evaluate-object*elaborate*operator*add-duplicated-attribute-to-duplicate-operator 
   :default
   (state <s> ^duplicates* <d> ^look-ahead-operator <o-copy>)
   (<o-copy> ^duplicate-of* <o>)
   (<o> ^ { <> duplicate-of* <att> } <id>
      - ^dont-copy <att>)
   (<d> ^<id> <copy-id>)
   -->
   (<o-copy> ^<att> <copy-id>)}


###
###     7.3.3   Computing evaluations
###
###
###     7.3.3.1 Computing numeric evaluations
###
### This is domain specific, so there are no default productions for this.

###
###     7.3.3.2 Comparing numeric evaluations
###

### If two objects have equal evaluations they are indifferent.

sp {default*selection*compare*equal-evaluation-indifferent 
   :default
   (state <s> ^problem-space.name selection ;#^attribute <role>  ;#REMOVED.
              ^superstate <ss>
              ^evaluation <e1>  { <> <e1> <e2> })
   (<ss> ^desired <d>)
   (<e1> ^object <x> ^numeric-value <v> ^desired <d> 
	 ^type evaluate-object)
   (<e2> ^object <y> ^numeric-value <v> ^desired <d> 
	 ^type evaluate-object)
 - (<d> ^equal not-indifferent)
   -->
   (<ss> ^operator <x> = <y>)}	;# was ^<role> 


###
### Generate operator preferences based on their evaluations and info 
### as to whether higher or lower evaluations are better.

sp {default*selection*compare*higher-evaluation-better ;# default*evaluate-object*elaborate*
   :default
   (state <s> ^problem-space.name selection ;#^attribute <role>  ;#REMOVED. 
              ^superstate <ss>
	      ^evaluation <e1> ^evaluation { <> <e1> <e2> })
   (state <ss> ^problem-space <p2> ^desired <d>)
   (<e1> ^object <o1> ^numeric-value <v> ^desired <d>
	 ^type evaluate-object)
   (<e2> ^object <o2> ^numeric-value < <v> ^desired <d> 
	 ^type evaluate-object)
   (<d> ^better higher)
   -->
   (<ss> ^operator <o2> < <o1>)}	;# was ^<role> 

sp {default*selection*compare*prefer-lower-evaluation ;# default*evaluate-object*elaborate*
   :default
   (state <s> ^problem-space.name selection ;#^attribute <role>   ;#REMOVED. 
              ^superstate <ss>
	      ^evaluation <e1> ^evaluation { <> <e1> <e2> })
   (state <ss> ^problem-space <p2> ^desired <d>)
   (<e1> ^object <o1> ^numeric-value <v> ^desired <d> 
	 ^type evaluate-object)
   (<e2> ^object <o2> ^numeric-value > <v> ^desired <d> 
	 ^type evaluate-object)
   (<d> ^better lower)
   -->
   (<ss> ^operator <o2> < <o1>)}  ;# Aladin's rectification, was ^<role> 


###
###		7.3.3.3 Computing symbolic evaluations
###


sp {default*selection*compare*same-symbolic-evaluations-are-indifferent
   :default
   (state <s> ^problem-space.name selection ^superstate <ss>
	      ^evaluation <e1>  { <> <e1> <e2> })
   (state <ss> ^desired <d>)
   (<e1> ^object <x> ^symbolic-value <v> ^desired <d> 
	 ^type evaluate-object)
   (<e2> ^object <y> ^symbolic-value <v> ^desired <d> 
	 ^type evaluate-object)
   -->
   (<ss> ^operator <x> = <y>)}	;# was ^<role> [unbound] SBH/mvp 9-2-94

sp {default*selection*compare*success-evaluation-better-than-partial-success
   :default
   (state <s> ^problem-space.name selection ^superstate <ss>
              ^evaluation <e1>  { <> <e1> <e2> })
   (state <ss> ^desired <d>)
   (<e1> ^object <x> ^symbolic-value success ^desired <d> 
         ^type evaluate-object)
   (<e2> ^object { <> <x> <y> } ^symbolic-value partial-success 
         ^desired <d> ^type evaluate-object)
   -->
   (<ss> ^operator <x> > <y>)}	;# was ^<role> [unbound] SBH/mvp 9-2-94

sp {default*selection*compare*partial-failure-evaluation-better-than-failure
   :default
   (state <s> ^problem-space.name selection ^superstate <ss>
              ^evaluation <e1>  { <> <e1> <e2> })
   (state <ss> ^desired <d>)
   (<e1> ^object <x> ^symbolic-value partial-failure ^desired <d> 
         ^type evaluate-object)
   (<e2> ^object { <> <x> <y> } ^symbolic-value failure ^desired <d>
         ^type evaluate-object)
   -->
   (<ss> ^operator <x> > <y>)}	;# was ^<role> [unbound] SBH/mvp 9-2-94

sp {default*selection*select*required-success-evaluation-becomes-required-preference
   :default
   (state <s> ^problem-space.name selection ^operator <o> ^superstate <ss>
	      ^evaluation <e1>)
   (state <ss> ^desired <eb> ^operator <o1> +)
   (<o> ^name evaluate-object ^evaluation <e1>
	^desired <eb> ^object <o1>)
   (<e1> ^symbolic-value required-success)
   -->
   (<ss> ^operator <o1> ! )}

sp {default*selection*select*success-evaluation-becomes-best-preference
   :default
   (state <s> ^problem-space.name selection ^operator <o> ^superstate <ss>
              ^evaluation <e1>)
   (state <ss> ^desired <eb> ^operator <o1> +)
   (<o> ^name evaluate-object ^evaluation <e1>
	^desired <eb> ^object <o1> )
   (<e1> ^symbolic-value << partial-success success >> )
   -->
   (<ss> ^operator <o1> > )}

sp {default*selection*select*indifferent-evaluation-becomes-indifferent-preference
   :default
   (state <s> ^problem-space.name selection ^operator <o> ^superstate <ss>
	      ^evaluation <e1>)
   (state <ss> ^desired <eb> ^operator <o1> +)
   (<o> ^name evaluate-object ^evaluation <e1>
	^desired <eb> ^object <o1>)
   (<e1> ^symbolic-value indifferent)
   -->
   (<ss> ^operator <o1> =)}

sp {default*selection*select*partial-failure-evaluation-becomes-worst-preference
   :default
   (state <s> ^problem-space.name selection ^operator <o> ^superstate <ss>
              ^evaluation <e1>)
   (state <ss> ^desired <e> ^operator <o1> +)
   (<o> ^name evaluate-object ^evaluation <e1> 
	^desired <e>
        ^object <o1>)
   (<e1> ^symbolic-value partial-failure)
   -->
   (<ss> ^operator <o1> < )}

sp {default*selection*select*failure-evaluation-becomes-reject-preference
   :default
   (state <s> ^problem-space.name selection ^operator <o> ^superstate <ss>
	      ^evaluation <e1>)
   (state <ss> ^desired <e> ^operator <o1> +)
   (<o> ^name evaluate-object ^evaluation <e1> ^desired <e>
	^object <o1>)
   (<e1> ^symbolic-value << lose failure >> )
   -->
   (<ss> ^operator <o1> - )}

sp {default*selection*select*prohibit-failure-evaluation-becomes-prohibit-preference
   :default
   (state <s> ^problem-space.name selection ^operator <o> ^superstate <ss>
              ^evaluation <e1>)
   (state <ss> ^desired <e> ^operator <o1> +)
   (<o> ^name evaluate-object ^evaluation <e1> ^desired <e>
	^object <o1>)
   (<e1> ^symbolic-value prohibit-failure)
   -->
   (<ss> ^operator <o1> ~ )}



###
###		7.3.3.4 Default evaluations
###

###			A.	default*pass-back-success
## if an operator leads to success and it is being
## tried out in a subgoal to evaluate another operator -
## give that second operator a success evaluation also


### AA/mvp 9-2-94
sp {default*pass-back-success 	
   :default
   (state <s> ^operator <o> ^superstate <ss>)	;# removed ^evaluation <e1>
   (<o> ^name evaluate-object ^evaluation <e1>)
   (<e1> ^symbolic-value << required-success success >> )
   (state <ss> ^superstate <sss>)
   (state <sss> ^operator <sso>)	;# removed ^evaluation <e2>
   (<sso> ^name evaluate-object ^evaluation <e2> ^object <x>)
   (<x> ^name)
   -->
   (<e2> ^symbolic-value partial-success )}



###
###		7.3.3.5 Novalue evaluations
###

### Make novalue worse than any other value.

sp {default*selection*compare*novalue-evaluation-always-worse
   :default
   (state <s> ^problem-space.name selection ;#^attribute <role>   ;#REMOVED. 
              ^superstate <ss>
	      ^evaluation <e1> ^evaluation { <> <e1> <e2> })
   (state <ss> ^desired <d>)
   (<e1> ^object <o1> ^numeric-value novalue ^desired <d>
	 ^type evaluate-object)
   (<e2> ^object <o2> ^numeric-value <> novalue ^desired <d>
	 ^type evaluate-object)
   -->
   (<ss> ^operator <o2> > <o1>)}	;# was ^<role>


###
###	     7.3.4   Halting Soar with success or failure
###

###			A.	default*top-goal*halt*state*success
### Handle state augmentations dealing with goal termination for the top-level goal.

sp {default*top-goal*halt*success
   :default
   (state <s> ^name <name>
	      ^desired <eb>
	      ^superstate nil
	      ^<< required-success success >> <eb>)
   -->
   (write (crlf)   <name>  | achieved | )
   (halt)}

###			B.	default*top-goal*halt*state*failure

sp {default*top-goal*halt*failure
   :default
   (state <s> ^superstate nil
	      ^desired <eb>
	      ^name <name>
	      ^ << prohibit-failure failure >> <eb>)
   -->
   (write (crlf)  <name>  | failed| )
   (halt)}


###
###		7.4	Operator Subgoaling (modified extensively by JEL/mvp 07-Nov-93)
#######################################################################################
###  RESTRICTIONS ON USE:
###
###     1. The problem space used for operator implmentation can not be exactly
###     the same problem space used for operator subgoaling (or the original
###     task problem space).  It can be a duplicate, but can not have the same
###     identifier.  This is because operator subgoaling is signalled by the
###     selection of the task space as the problem space in the operator
###     no-change subgoal.
###
###     2. For operator subgoaling and operator implementation to work
###     together, there must be a production that tests when the preconditions
###     of the operator have been achieved (operator subgoaling is successful)
###     and whose action is to reconsider the problem space.  This is necessary
###     so that the switch can be made from the operator subgoaling problem
###     space (the original task space) and the operator implementation problem
###     space.
###
###     sp {task*reconsider*problem-space*operator-subgoaling
###       (state <s> ^impasse no-change ^attribute operator ^object <ss>
###          ^problem-space <p>)
###       (state <ss> ^problem-space <p> ^operator <o>)
###       (state <s> ^attributes that test operator instantiated)
###       (operator <o> ^name ...)
###       -->
###       (state <s> ^problem-space <sp> @)}
###
###     3. All operators must be augmented with ^achieved <x> when they have
###     successfully applied.  This helps avoid problems where chunks learned
###     through operator subgoaling, can undo operator actions, and vice
###     versa.
###   
###     4. Operators must apply by changing existing structures on the state,
###     not by creating new ones, or destroying existing ones.
###
#####################################################################################

#####################################################################################
###  OVERVIEW
###
### For look-ahead searches, always select the operator that subgoaling on
### after another operator has applied.  If it then sucessfully applied, the
### look-ahead search was a success.
###
#####################################################################################


### make the super-problem space the default
###         when there is a no-change for the operator
###   make is worst so operator implementation will win out

sp {default*generic*opsub*propose*space*generic
   :default
   (state <s> ^impasse no-change ^attribute operator 
	      ^superstate <ss>)
   (state <ss> ^problem-space <p2>)
   -->
   (<s> ^problem-space <p2> + < )}

###if the superproblem-space is selected as the
###         current problem space then operator subgoaling
###         is being used so select the superstate -
###         the super-operator becomes the desired)
###
###  The name gets a parallel preference because the state
###   above (which is being copied down to this state) may
###   also have a name.

sp {default*generic*opsub*elaborate*state*name*operator-subgoal
   :default
   (state <s> ^problem-space <p> 
	      ^impasse no-change ^attribute operator ^superstate <ss>)
   (state <ss> ^problem-space <p>)
   -->
   (<s> ^name operator-subgoal + & operator-subgoal < )}

sp {default*generic*opsub*elaborate*state*desired
   :default
   (state <s> ^problem-space <p> ^name operator-subgoal ^superstate <ss>)
   (state <ss> ^operator <o>)
   -->
   (<s> ^desired <o>)}

sp {default*generic*opsub*copy*superstate
   :default
   (state <s> ^name operator-subgoal ^superstate <ss>)
   (<ss> ^ { <att> <> problem-space <> impasse <> object <> name
                   <> superstate <> attribute <> operator <> desired }
	   <value>)
   -->
   (<s> ^<att> <value> + &)}

### The following is commented out; it would provide for keeping track
###  of all levels of operator subgoaling, not just the most recent. 
### Pass down all super operator subgoals as well.
#
# sp {default*generic*opsub*goal*elaborate*all-desireds
#   :default
#   (state <s> ^problem-space <p> 
#	      ^impasse no-change ^attribute operator ^superstate <ss>)
#   (state <ss> ^problem-space <p> ^desired <o>)
#   -->
#   (state <s> ^desired <o>)}
#
#
###don't select the operator for the operator that we are 
###        subgoaling on.  

sp {default*generic*select*reject-desired
   :default
   (state <s> ^name operator-subgoal ^problem-space <p> ^desired <o>)
   -->
   (<s> ^operator <o> - )}

##if there is an evaluation subgoal within
###         an operator subgoal and the operator being
###         subgoaled on is applied - success

sp {default*generic*opsub*detect*state*success
   :default
   (state <g-eval> ^problem-space <p> ^desired <o> ^applied <o>)
   (<o> ^achieved <ss>)
   -->
   (<ss> ^success <o>)}

sp {opsub*select-operator*subgoaling
   :default
   (state <s1> ^name implement-evaluate-object ^problem-space <p>
	       ^operator <> <o> ^desired <o>)
   (<o> ^name)
   -->
   (<s1> ^operator <o> <o> !)}
 
sp {default*generic*opsub*failure*no-operator
   :default
   (state <s> ^superstate <ss> ^impasse no-change ^attribute state ^quiescence t)
   (<ss> ^name operator-subgoal ^desired <d>)
   -->
   (<ss> ^failure <d> <d> &)}
 
sp {default*generic*evaluation*failure*no-operator
   :default
   (state <s> ^superstate <ss> ^impasse no-change ^name operator-subgoal
	      ^attribute operator ^desired <d> ^quiescence t
	      ^failure <d>)
   (<ss> ^operator <so> ^desired <sd>)
   -->
   (<ss> ^failure <sd> <sd> &)}
 
   
sp {default*generic*opsub*avoid*duplicate-operator
   :default
   (state <s> ^impasse no-change ^name operator-subgoal
	      ^attribute operator ^operator <o> + ^super-desired <sd>)
   (<o> ^name <name>)
   (<sd> ^name <name>)
   -->
   (<s> ^operator <o> -)}
 
sp {default*generic*opsub*operator-subgoals
   :default
   (state <s> ^name implement-evaluate-object ^problem-space <p>
	      ^operator <o> ^desired <o>)
   (state <ss> ^name operator-subgoal ^superstate <s>)
   -->
   (<s> ^operator <o> @)}
     
## These maintain the super-desireds
 
sp {default*generic*opsub*subgoal-on-all-desired-super-desireds
   :default
   (state <s> ^problem-space <p>
	      ^impasse no-change ^attribute operator ^superstate <ss>)
   (<ss> ^problem-space <p> ^desired <o>)
   -->
   (<s> ^super-desired <o> <o> &)}
 
sp {default*generic*opsub*subgoal-on-all-super-desireds
   :default
   (state <s> ^problem-space <p>
	      ^impasse no-change ^attribute operator ^superstate <ss>)
   (<ss> ^problem-space <p> ^super-desired <o>)
   -->
   (<s> ^super-desired <o> <o> &)}
 
sp {default*apply*evaluate*augment*evaluation-operator-super-desired
   :default
   (state <s> ^operator <o> ^superstate <ss>)
   (<ss> ^super-desired <d>)
   (<o> ^evaluation <e> ^type evaluation)
   -->
   (<o> ^super-desired <d> <d> &)}
 
sp {default*elaborate*state*eval*super-desired
   :default
   (state <s> ^impasse no-change ^attribute operator ^superstate <ss>)
   (<ss> ^operator <so>)
   (<so> ^type evaluation ^super-desired <d>)
   -->
   (<s> ^super-desired <d> <d> &)}

###
###		7.5     Execution monitoring
###

### If the state is marked with ^success <d>, the goal succeeds.

sp {default*monitor*goal*success
   :default
   (state <ts> ^superstate nil - ^verbose false)
   (state <s> ^name <gname> ^desired <d>
	      ^<< partial-success required-success success >> <d>)
   -->
   (write (crlf) |  Goal | <gname> | succeeded. |)}

### If the state is marked with ^failure <d>, the goal fails.

sp {default*monitor*goal*failure
   :default
   (state <ts> ^superstate nil - ^verbose false)
   (state <s> ^name <gname> ^desired <d>
	      ^<< partial-failure failure prohibit-failure >> <d>)
   -->
   (write (crlf) |  Goal | <gname> | failed. |)}

### Print the evaluation of any object that has a name (which doesn't
### get states).

sp {default*monitor*operator*evaluation
   :default
   (state <ts> ^superstate nil -^verbose false)
   (state <s> ^operator <o>)
   (<o> ^type evaluation ^object <obj> ^evaluation <e>)
   (<e> ^ << numeric-value symbolic-value >> <n>)
   (<obj> ^name <name>)
   -->
   (write (crlf) |  Evaluation of | <obj> | (|
					     <name> |) is | <n>)}

sp {default*monitor*attribute-impasses 
   :default
   (state <ts> ^superstate nil -^verbose false)
   (impasse <i> ^object <obj> ^attribute <att> ^impasse <impasse>)
   -->
   (write (crlf) |  Impasse for | <obj> | ^|
   <att> | type: | <impasse>)}


